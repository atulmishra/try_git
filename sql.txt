DROP TABLE AccessEntityDataObjectMap;
CREATE TABLE AccessEntityDataObjectMap (AccessEntity VARCHAR(40), SourceDataObject VARCHAR(256) NULL, DestinationDataObject VARCHAR(40) NULL, DataComponent VARCHAR(40) NULL, ConditionType VARCHAR(40) NULL, SchemaType VARCHAR(24) NULL);
DROP TABLE AppRequestIDPrivilegeMap;
CREATE TABLE AppRequestIDPrivilegeMap (RequestID INT, Privilege VARCHAR(75), RequestName VARCHAR(75) NULL, Description VARCHAR(75) NULL, Owner VARCHAR(100) NULL);
DROP TABLE Attribute;
CREATE TABLE Attribute (DatasetID INT, AttributeID INT, AttributeName VARCHAR(40) NULL, AttributeType VARCHAR(40) NULL, IsDeleted INT NULL, IsMandatory INT NULL, CreatedBy VARCHAR(75) NULL, CreatedDate DATETIME NULL, CreatedDateTZ VARCHAR(15) NULL, LastModifiedBy VARCHAR(75) NULL, LastModifiedDate DATETIME NULL, LastModifiedDateTZ VARCHAR(15) NULL);
DROP TABLE AuditedCodeEntries;
CREATE TABLE AuditedCodeEntries (CodeName VARCHAR(255), Event VARCHAR(255));
DROP TABLE BusinessUnitRefresh;
CREATE TABLE BusinessUnitRefresh (BusinessUnitCode VARCHAR(5) NULL, BusinessUnitName VARCHAR(50) NULL, Strategy VARCHAR(5) NULL);
DROP TABLE CMPOrderDetail;
CREATE TABLE CMPOrderDetail (OrderID VARCHAR(15), OrderbyUserId VARCHAR(15) NULL, OrderbyUserName VARCHAR(75) NULL, UserId VARCHAR(15) NULL, UserName VARCHAR(75) NULL, ProductID VARCHAR(40) NULL, ModelAfter VARCHAR(75) NULL, AddRole VARCHAR(255) NULL, RemoveRole VARCHAR(255) NULL, BusinessApprover VARCHAR(75) NULL, SubmitStatus VARCHAR(40) NULL, OrderDate DATETIME NULL, Comments VARCHAR(255) NULL);
DROP TABLE CalendarMapping;
CREATE TABLE CalendarMapping (MappingID INT, Calendar BINARY(48) NULL, CalendarID INT NULL);
DROP TABLE ClassificationCode;
CREATE TABLE ClassificationCode (Class VARCHAR(40), SchemaName VARCHAR(40), Code VARCHAR(255), LongName VARCHAR(255) NULL, Description VARCHAR(255) NULL);
DROP TABLE ClassificationSchema;
CREATE TABLE ClassificationSchema (Class VARCHAR(40), SchemaName VARCHAR(40), MultipleEntryIndicator INT NULL, Description VARCHAR(255) NULL, CRC INT NULL);
DROP TABLE ClientHosts;
CREATE TABLE ClientHosts (HostName VARCHAR(255) NULL);
DROP TABLE Code;
CREATE TABLE Code (Type VARCHAR(255), Code VARCHAR(255), ExternalCode VARCHAR(255) NULL, LongName VARCHAR(255) NULL, Description VARCHAR(255) NULL, CRC INT NULL);
DROP TABLE CodeAttachments;
CREATE TABLE CodeAttachments (CommentAttachmentID INT, CommentID INT, UserDocument VARCHAR(255), LastModifiedBy VARCHAR(75), LastModifiedTimeStamp DATETIME);
DROP TABLE CodeComments;
CREATE TABLE CodeComments (CommentID INT, Type VARCHAR(255), UserNotes VARCHAR(255), LastModifiedBy VARCHAR(75), LastModifiedTimeStamp DATETIME, LastApprovedBy VARCHAR(75) NULL, LastApprovedTimeStamp DATETIME NULL, PRIMARY KEY (CommentID));
DROP TABLE CodeTableAudit;
CREATE TABLE CodeTableAudit (EventTimeStamp DATETIME NULL, Event VARCHAR(30) NULL, HostName VARCHAR(40) NULL, IPAddress VARCHAR(40) NULL, HostProcessID VARCHAR(30) NULL, ProgramName VARCHAR(75) NULL, SqlUserName VARCHAR(30) NULL, SpID INT NULL, OldType VARCHAR(255) NULL, NewType VARCHAR(255) NULL, OldCode VARCHAR(255) NULL, NewCode VARCHAR(255) NULL, OldExternalCode VARCHAR(255) NULL, NewExternalCode VARCHAR(255) NULL, OldLongName VARCHAR(255) NULL, NewLongName VARCHAR(255) NULL, OldDescription VARCHAR(255) NULL, NewDescription VARCHAR(255) NULL, OldCRC INT NULL, NewCRC INT NULL);
DROP TABLE ConfigData;
CREATE TABLE ConfigData (DatasetID INT, ValueNumber INT, Column1 VARCHAR(255) NULL, Column2 VARCHAR(255) NULL, Column3 VARCHAR(255) NULL, Column4 VARCHAR(255) NULL, Column5 VARCHAR(255) NULL, Column6 VARCHAR(255) NULL, Column7 VARCHAR(255) NULL, Column8 VARCHAR(255) NULL, Column9 VARCHAR(255) NULL, Column10 VARCHAR(255) NULL, Column11 VARCHAR(255) NULL, Column12 VARCHAR(255) NULL, Column13 VARCHAR(255) NULL, Column14 VARCHAR(255) NULL, Column15 VARCHAR(255) NULL, Column16 VARCHAR(255) NULL, Column17 VARCHAR(255) NULL, Column18 VARCHAR(255) NULL, Column19 VARCHAR(255) NULL, Column20 VARCHAR(255) NULL, CreatedBy VARCHAR(75) NULL, CreatedDate DATETIME NULL, CreatedDateTZ VARCHAR(15) NULL, LastModifiedBy VARCHAR(75) NULL, LastModifiedDate DATETIME NULL, LastModifiedDateTZ VARCHAR(15) NULL);
DROP TABLE ConfigurationSegment;
CREATE TABLE ConfigurationSegment (TeamMember VARCHAR(75), ConfigurationName VARCHAR(255), SegmentNumber INT, Configuration VARCHAR(255) NULL);
DROP TABLE ConfirmationHeader;
CREATE TABLE ConfirmationHeader (DocumentationType VARCHAR(40), LegalEntity VARCHAR(255), CompanyName VARCHAR(255) NULL, Addr1 VARCHAR(255) NULL, Addr2 VARCHAR(255) NULL, Addr3 VARCHAR(255) NULL, Addr4 VARCHAR(255) NULL, LmTeleNumber VARCHAR(255) NULL, TeleNumber1 VARCHAR(255) NULL, TeleNumber2 VARCHAR(255) NULL, OperationsCenter VARCHAR(40), Addr5 VARCHAR(255) NULL, TeleNumber3 VARCHAR(255) NULL, TeleLabel1 VARCHAR(255) NULL, TeleLabel2 VARCHAR(255) NULL, TeleLabel3 VARCHAR(255) NULL);
DROP TABLE ConfirmationSignature;
CREATE TABLE ConfirmationSignature (SOEID VARCHAR(25) NULL, SignatureImagePath VARCHAR(200) NULL);
DROP TABLE CorpusMap;
CREATE TABLE CorpusMap (ParentClassID INT, ChildClassID INT, SinglePayRecDir INT NULL, ShortCorpus INT NULL, LongCorpus INT NULL, TotalCorpus INT NULL, IsAutoAdded INT NULL, UndefinedCorpus INT NULL);
DROP TABLE CusipList;
CREATE TABLE CusipList (RequestID INT, Cusip VARCHAR(15) NULL);
DROP TABLE CustomMessage;
CREATE TABLE CustomMessage (MessageID INT, ProcessingApplicationName VARCHAR(255) NULL, MessagePurpose VARCHAR(255) NULL, CustomMessage TEXT NULL, CustomMessageSize INT NULL, ActiveMessage INT NULL);
DROP TABLE CustomReport;
CREATE TABLE CustomReport (Report VARCHAR(75), DBName VARCHAR(40) NULL, StoredProc VARCHAR(255) NULL);
DROP TABLE DBArchPurgeSetup;
CREATE TABLE DBArchPurgeSetup (SetupID INT, DBName VARCHAR(30) NULL, DBType VARCHAR(10) NULL, Comments VARCHAR(255) NULL, HostName VARCHAR(50) NULL, UserName VARCHAR(50) NULL, LastModified DATETIME DEFAULT getdate());
DROP TABLE DBArchPurgeStrategyGrp;
CREATE TABLE DBArchPurgeStrategyGrp (GroupStrategyID INT, SetupID INT, StrategyGroupName VARCHAR(255) NULL, StrategyOpType CHAR(1), CycleType VARCHAR(10) NULL, CycleInterval VARCHAR(50) NULL, CycleIntervalMeasure VARCHAR(10) NULL, StartCycleLimit VARCHAR(50) NULL, EndCycleLimit VARCHAR(50) NULL, LastCycleLimit VARCHAR(50) NULL, BatchSize INT NULL, SPName VARCHAR(255) NULL, MailingAdd1 VARCHAR(100) NULL, MailingAdd2 VARCHAR(100) NULL, MailingAdd3 VARCHAR(100) NULL, Comments VARCHAR(255) NULL, HostName VARCHAR(50), UserName VARCHAR(50), LastModified DATETIME DEFAULT getdate());
DROP TABLE DataMapConfig;
CREATE TABLE DataMapConfig (DataMapID VARCHAR(255), DataMapDescription VARCHAR(1000) NULL, KeyFieldCount INT NULL, ListFieldCount INT NULL, SingleElementList VARCHAR(255) NULL, LastModifiedBy VARCHAR(255) NULL, LastModifiedOn DATETIME NULL, ApplicationID VARCHAR(100) NULL, IsKeyColumnVisible VARCHAR(10) NULL, IsUserEditable VARCHAR(10) NULL, LastUserEditedTimestamp DATETIME NULL);
DROP TABLE DataMapContent;
CREATE TABLE DataMapContent (DataMapSequenceNumber INT, DataMapID VARCHAR(100), DataInstanceNumber INT, DataMapInstanceStatus VARCHAR(20));
DROP TABLE DataServer;
CREATE TABLE DataServer (DataServer VARCHAR(255), Type VARCHAR(255) NULL, Description VARCHAR(255) NULL);
DROP TABLE Dataset;
CREATE TABLE Dataset (DatasetID INT, ApplicationName VARCHAR(40), DatasetName VARCHAR(40) NULL, NumberOfAttributes INT NULL, IsEnumType INT NULL, CreatedBy VARCHAR(75) NULL, CreatedDate DATETIME NULL, CreatedDateTZ VARCHAR(15) NULL, LastModifiedBy VARCHAR(75) NULL, LastModifiedDate DATETIME NULL, LastModifiedDateTZ VARCHAR(15) NULL);
DROP TABLE DatasetMap;
CREATE TABLE DatasetMap (DatamapID INT, DataSet1 INT NULL, DataSet2 INT NULL, DataSet1Value INT NULL, MappingValue INT NULL, CreatedBy VARCHAR(75) NULL, CreatedDate DATETIME NULL, CreatedDateTZ VARCHAR(15) NULL, LastModifiedBy VARCHAR(75) NULL, LastModifiedDate DATETIME NULL, LastModifiedDateTZ VARCHAR(15) NULL);
DROP TABLE DealManagerAdvanceSearch;
CREATE TABLE DealManagerAdvanceSearch (SearchID INT, ColName VARCHAR(30) NULL, ColVal VARCHAR(255) NULL, Operator VARCHAR(10) NULL, PRIMARY KEY (SearchID));
DROP TABLE DealManagerSearch;
CREATE TABLE DealManagerSearch (SearchID INT, SearchName VARCHAR(75) NULL, TeamMember VARCHAR(75) NULL, IdentifierName VARCHAR(30) NULL, IdentifierValue VARCHAR(100) NULL, TradeDate INT NULL, TerminationDate INT NULL, ProductClass INT NULL, PartyAccount VARCHAR(100) NULL, PartyLegalEntity VARCHAR(100) NULL, CounterPartyAccount VARCHAR(100) NULL, CounterPartyName VARCHAR(100) NULL, Trader VARCHAR(75) NULL, SalesPerson VARCHAR(75) NULL, InsertTimestamp DATETIME NULL, SaveFlag INT NULL, Digest VARCHAR(500), PRIMARY KEY (SearchID));
DROP TABLE DefaultCusData;
CREATE TABLE DefaultCusData (ViewFormat VARCHAR(255), SortFormat VARCHAR(255), Attribute VARCHAR(255), ColumnHeading VARCHAR(255) NULL, NullRep VARCHAR(255) NULL);
DROP TABLE Document;
CREATE TABLE Document (DocumentId INT, DocRootId INT NULL, DocumentType INT NULL, LatestVersion VARCHAR(255) NULL, DocExtension VARCHAR(15) NULL, Secured INT NULL, DocName VARCHAR(255) NULL, DocPath VARCHAR(255) NULL, Index1 VARCHAR(40) NULL, Index2 VARCHAR(40) NULL, Index3 VARCHAR(40) NULL, Index4 VARCHAR(40) NULL, Index5 VARCHAR(40) NULL);
DROP TABLE DocumentHistory;
CREATE TABLE DocumentHistory (DocumentId INT, Version VARCHAR(255), DocExtension VARCHAR(15) NULL, DocSize INT NULL, Deleted INT NULL, CreatedBy VARCHAR(75) NULL, CreatedTimeStamp DATETIME NULL, CreatedTimeStampTZ VARCHAR(4) NULL, LastModifiedBy VARCHAR(75) NULL, LastModifiedTimeStamp DATETIME NULL, LastModifiedTimeStampTZ VARCHAR(4) NULL);
DROP TABLE DocumentRoot;
CREATE TABLE DocumentRoot (DocRootId INT, ApplicationId INT NULL, DocRootName VARCHAR(255) NULL, DocRootPath VARCHAR(255) NULL);
DROP TABLE EmployeeDetails;
CREATE TABLE EmployeeDetails (TeamMember VARCHAR(75), SOEID VARCHAR(255) NULL, EmployeeIdentification INT NULL, Department VARCHAR(255) NULL, EMailAddress VARCHAR(255) NULL, Telephone VARCHAR(255) NULL, Fax VARCHAR(255) NULL, Location VARCHAR(255) NULL, RITSID INT NULL, CostCentre VARCHAR(40) NULL, Title VARCHAR(40) NULL, LastModifiedTimeStamp DATETIME NULL, FirstName VARCHAR(75) NULL, LastName VARCHAR(75) NULL, Supervisor VARCHAR(75) NULL, Region VARCHAR(40) NULL, Country VARCHAR(40) NULL, sybfi5_1 VARCHAR(75) NULL);
DROP TABLE EndOfTransactionLogMarker;
CREATE TABLE EndOfTransactionLogMarker (LogMarkerMessage VARCHAR(100) NULL, EntryTime DATETIME NULL);
DROP TABLE Entity;
CREATE TABLE Entity (EntityName VARCHAR(255), DatabaseName VARCHAR(255) NULL, JavaPackageName VARCHAR(255) NULL, JavaClassName VARCHAR(255) NULL, TableFileName VARCHAR(255) NULL, IndexFileName VARCHAR(255) NULL, InsertProcFileName VARCHAR(255) NULL, DeleteProcFileName VARCHAR(255) NULL, UpdateProcFileName VARCHAR(255) NULL);
DROP TABLE EntityAttribute;
CREATE TABLE EntityAttribute (EntityName VARCHAR(255), AttributeName VARCHAR(255), VariableName VARCHAR(255) NULL, OasysDataType VARCHAR(255) NULL, CompositeIndicator INT NULL, KeyIndicator INT NULL, AllowNullIndicator INT NULL, DataDefinition VARCHAR(255) NULL);
DROP TABLE Enumeration;
CREATE TABLE Enumeration (EnumerationName VARCHAR(255), EnumerationValue INT, ShortName VARCHAR(255) NULL, Description VARCHAR(255) NULL, LongName VARCHAR(255) NULL, Identifier VARCHAR(255) NULL);
DROP TABLE ExceptionHandling;
CREATE TABLE ExceptionHandling (ExceptionID INT IDENTITY, ExceptionKey VARCHAR(255), ExceptionProcess INT NULL, ApplicationName VARCHAR(255) NULL, ExceptionTeamMember VARCHAR(255) NULL, ExceptionTime DATETIME NULL, ExceptionProcessSystem VARCHAR(255) NULL, ProcessStatus INT NULL, ProcessedTime DATETIME NULL, ReprocessFailureReason VARCHAR(255) NULL, BatchTeamMember VARCHAR(255) NULL, Location VARCHAR(255) NULL, Option2 VARCHAR(255) NULL, Option3 VARCHAR(255) NULL, Option4 VARCHAR(255) NULL);
DROP TABLE Filter;
CREATE TABLE Filter (ReportType VARCHAR(40), Report VARCHAR(75), TeamMember VARCHAR(75) NULL, Operation INT NULL, TableName VARCHAR(255) NULL, TableKey VARCHAR(255) NULL, Column VARCHAR(255) NULL, ColumnValue VARCHAR(255) NULL);
DROP TABLE Holiday;
CREATE TABLE Holiday (Calendar INT, Holiday INT, HolidayName VARCHAR(255) NULL, CRC INT NULL);
DROP TABLE HolidayDefinition;
CREATE TABLE HolidayDefinition (Calendar INT, Weekend BINARY(1) NULL, CalendarName VARCHAR(255) NULL);
DROP TABLE HostBlackList;
CREATE TABLE HostBlackList (HostName VARCHAR(100), HostCategory VARCHAR(25), HostType VARCHAR(4), ContactGroup VARCHAR(100) NULL, ContactGroupEmail VARCHAR(100) NULL, PrimaryContact VARCHAR(100) NULL, EntryTimestamp DATETIME DEFAULT getdate(), EntryHost VARCHAR(100) DEFAULT 'host_name()', EntryLogin VARCHAR(50) DEFAULT 'suser_name()', CONSTRAINT PK_BlackHostList PRIMARY KEY (HostName));
DROP TABLE ISDAProductTaxonomy;
CREATE TABLE ISDAProductTaxonomy (AssetClass VARCHAR(40), BaseProduct VARCHAR(100) NULL, SubProduct VARCHAR(100) NULL, TypeOfSubProduct VARCHAR(100) NULL, SettlementType VARCHAR(100) NULL, ReportingObligation VARCHAR(40) NULL, ISDADefinedProduct INT NULL, DoddFrankEligible INT NULL);
DROP TABLE IntegerKeyAllocation;
CREATE TABLE IntegerKeyAllocation (KeyType VARCHAR(255), MinimumKeyInRange INT NULL, MaximumKeyInRange INT NULL, MaximumUsedKeyInRange INT NULL);
DROP TABLE JoinCondition;
CREATE TABLE JoinCondition (ReportType VARCHAR(255), FirstTableName VARCHAR(255), FirstColumnName VARCHAR(255), SecondTableName VARCHAR(255), SecondColumnName VARCHAR(255), JoinConditionType INT NULL);
DROP TABLE KeyDataConfig;
CREATE TABLE KeyDataConfig (DataMapID VARCHAR(255), KeyFieldNumber INT, KeyFieldName VARCHAR(255) NULL, LookupID INT NULL, LookupDataType VARCHAR(25) NULL);
DROP TABLE KeyDataContent;
CREATE TABLE KeyDataContent (DataMapID VARCHAR(255), DataInstanceNumber INT, KeyFieldNumber INT, KeyFieldValue VARCHAR(255) NULL);
DROP TABLE LabelAndTextGroup;
CREATE TABLE LabelAndTextGroup (ParentPanelName VARCHAR(255), FieldName VARCHAR(255), DisplayName VARCHAR(255) NULL, IOField INT NULL, PermitEditable INT NULL, MaximumDisplayChars INT NULL, MaximumEnterableChars INT NULL, OffSet INT NULL, CodeName VARCHAR(255) NULL);
DROP TABLE LegalEntityLogo;
CREATE TABLE LegalEntityLogo (LogoName VARCHAR(40), Logo TEXT NULL);
DROP TABLE ListDataConfig;
CREATE TABLE ListDataConfig (DataMapID VARCHAR(255), ListFieldNumber INT, ListFieldName VARCHAR(255) NULL, LookupID INT NULL, LookupDataType VARCHAR(25) NULL);
DROP TABLE ListDataContent;
CREATE TABLE ListDataContent (DataMapID VARCHAR(255), DataInstanceNumber INT, ListElementNumber INT, ListFieldNumber INT, ListFieldValue VARCHAR(255) NULL);
DROP TABLE LoginWhiteList;
CREATE TABLE LoginWhiteList (LoginName VARCHAR(30), LastModified DATETIME DEFAULT getdate(), EntryHost VARCHAR(100) DEFAULT 'host_name()', EntryLogin VARCHAR(50) DEFAULT 'suser_name()', CONSTRAINT LoginWhiteList PRIMARY KEY (LoginName));
DROP TABLE LookupDataConfig;
CREATE TABLE LookupDataConfig (LookupID INT, LookupFieldName VARCHAR(255));
DROP TABLE LookupDataContent;
CREATE TABLE LookupDataContent (LookupID INT, LookupFieldNumber INT, LookupFieldValue VARCHAR(255));
DROP TABLE MATRatesIMMDates;
CREATE TABLE MATRatesIMMDates (EffectiveDate INT NULL);
DROP TABLE MATRatesMACCoupon;
CREATE TABLE MATRatesMACCoupon (EffectiveDate INT NULL, Tenor INT, CCY VARCHAR(255) NULL, FixedRate FLOAT NULL);
DROP TABLE MATRatesProducts;
CREATE TABLE MATRatesProducts (NotionalCurrency VARCHAR(3), RateIndex VARCHAR(255) NULL, StartDateType VARCHAR(255) NULL, EarlyTermOption VARCHAR(255) NULL, FixedPayFreq VARCHAR(255) NULL, FixedDayCount VARCHAR(255) NULL, FloatResetFreq VARCHAR(255) NULL, FloatDayCount VARCHAR(255) NULL, XCCY VARCHAR(255) NULL, FixedNotional VARCHAR(255) NULL, PAR_MAC VARCHAR(255) NULL, Spread VARCHAR(255) NULL, Tenor VARCHAR(255) NULL, GoLiveDate INT NULL, Stub VARCHAR(1) NULL, Jurisdiction VARCHAR(25) NULL);
DROP TABLE MCCreditEMIRMatrix;
CREATE TABLE MCCreditEMIRMatrix (RuleNo INT NULL, PartyLegalEntity VARCHAR(40) NULL, PartyEMIRClearingCategoryCredit VARCHAR(20) NULL, PartyEUPersonFlag VARCHAR(20) NULL, PartyEUBranchOfThirdCountryFC VARCHAR(20) NULL, PartyEUGuaranteed VARCHAR(20) NULL, PartyEMIRClassification VARCHAR(20) NULL, CptyEMIRClearingCategoryCredit VARCHAR(20) NULL, CptyEUPersonFlag VARCHAR(20) NULL, CptyEUBranchOfThirdCountryFC VARCHAR(20) NULL, CptyEUGuaranteed VARCHAR(20) NULL, CptyEMIRClassification VARCHAR(20) NULL, CptyAIFMDClassification VARCHAR(20) NULL, CptyPensionFundExempt VARCHAR(20) NULL, CptyPublicBodyCentralBankExemption VARCHAR(20) NULL, CptyEMIRExemptPensionFund VARCHAR(20) NULL, FrontLoadingWave VARCHAR(20) NULL, MandatoryClearingWave VARCHAR(20) NULL);
DROP TABLE MCCreditEMIRRefData;
CREATE TABLE MCCreditEMIRRefData (Param1 VARCHAR(40), Param2 VARCHAR(40) NULL, Value VARCHAR(100) NULL, Description VARCHAR(100) NULL);
DROP TABLE MCCreditProducts;
CREATE TABLE MCCreditProducts (Ticker VARCHAR(255) NULL, Tenor INT, MaturityDate INT NULL, MATEffectiveDate INT NULL, MATExpiryDate INT NULL, EMIRClearing VARCHAR(1) NULL);
DROP TABLE MCCreditRefData;
CREATE TABLE MCCreditRefData (Param1 VARCHAR(40), Param2 VARCHAR(40) NULL, Value VARCHAR(100) NULL, Description VARCHAR(100) NULL);
DROP TABLE MCRatesEMIRMatrix;
CREATE TABLE MCRatesEMIRMatrix (RuleNo INT NULL, PartyLegalEntity VARCHAR(40) NULL, PartyEMIRClearingCategoryRates VARCHAR(20) NULL, PartyEMIRClearingCategoryRatesEEA VARCHAR(20) NULL, PartyEUPersonFlag VARCHAR(20) NULL, PartyEUBranchOfThirdCountryFC VARCHAR(20) NULL, PartyEUGuaranteed VARCHAR(20) NULL, PartyEMIRClassification VARCHAR(20) NULL, CptyEMIRClearingCategoryRates VARCHAR(20) NULL, CptyEMIRClearingCategoryRatesEEA VARCHAR(20) NULL, CptyEUPersonFlag VARCHAR(20) NULL, CptyEUBranchOfThirdCountryFC VARCHAR(20) NULL, CptyEUGuaranteed VARCHAR(20) NULL, CptyEMIRClassification VARCHAR(20) NULL, CptyAIFMDClassification VARCHAR(20) NULL, CptyPensionFundExempt VARCHAR(20) NULL, CptyPublicBodyCentralBankExemption VARCHAR(20) NULL, CptyEMIRExemptPensionFund VARCHAR(20) NULL, FrontLoadingWaveG4 VARCHAR(20) NULL, MandatoryClearingWaveG4 VARCHAR(20) NULL, FrontLoadingWaveEEA VARCHAR(20) NULL, MandatoryClearingWaveEEA VARCHAR(20) NULL);
DROP TABLE MCRatesEMIRProducts;
CREATE TABLE MCRatesEMIRProducts (NotionalCurrency VARCHAR(3), RateIndex VARCHAR(15), XCCY CHAR(1), TenorInYears INT, GoLiveDate INT, ProductType VARCHAR(30));
DROP TABLE MCRatesEMIRRefData;
CREATE TABLE MCRatesEMIRRefData (Param1 VARCHAR(40), Param2 VARCHAR(40) NULL, Value VARCHAR(100) NULL, Description VARCHAR(100) NULL);
DROP TABLE MCRatesProducts;
CREATE TABLE MCRatesProducts (NotionalCurrency VARCHAR(3), RateIndex VARCHAR(15), XCCY CHAR(1), TenorInYears INT, GoLiveDate INT, Optionality CHAR(1), ProductType VARCHAR(30), Jurisdiction VARCHAR(25) NULL);
DROP TABLE MCRatesRefData;
CREATE TABLE MCRatesRefData (Param1 VARCHAR(40), Param2 VARCHAR(40) NULL, Value VARCHAR(100), Description VARCHAR(100) NULL);
DROP TABLE MakerCheckerQueue;
CREATE TABLE MakerCheckerQueue (MakerCheckerID INT, ApplicationName VARCHAR(100), OriginalXML TEXT, ModifiedXML TEXT, CreatedTimestamp DATETIME, CreatedBy VARCHAR(75), LastModifiedBy VARCHAR(75), LastModifiedTimeStamp DATETIME, PRIMARY KEY (MakerCheckerID));
DROP TABLE MarkImportEnvConfig;
CREATE TABLE MarkImportEnvConfig (Environment VARCHAR(25), Machine VARCHAR(50), DataBaseServer VARCHAR(50) NULL, ArchiveMarkDir VARCHAR(150) NULL, BrowserMarkDir VARCHAR(150) NULL, CollectorMarkDir VARCHAR(150) NULL, CreditMarkDir VARCHAR(150) NULL, FinancialMarkDir VARCHAR(150) NULL, StatusDir VARCHAR(150) NULL, UploadMarkDir VARCHAR(150) NULL, CreditMTMKeyDir VARCHAR(150) NULL, CreditMTMKeyQADir VARCHAR(150) NULL, OafnServer VARCHAR(50) NULL, OafnContServer VARCHAR(50) NULL, FtpID VARCHAR(25) NULL, FtpPassword VARCHAR(25) NULL, SwapcoServer VARCHAR(50) NULL, SwapcoContServer VARCHAR(50) NULL, SwapcoFtpID VARCHAR(25) NULL, SwapcoFtpPassword VARCHAR(25) NULL, OperatorHomeDir VARCHAR(150) NULL, UsersHomeDir VARCHAR(150) NULL, FtpHomeDir VARCHAR(150) NULL, OatcFtpServer VARCHAR(50) NULL, OatcContFtpServer VARCHAR(50) NULL, CPMBrowserMarkDir VARCHAR(50) NULL);
DROP TABLE MarkImportFeedConfig;
CREATE TABLE MarkImportFeedConfig (MarkFileName VARCHAR(150), MarkingSystem VARCHAR(25), FeedType VARCHAR(25) NULL, InputFileDir VARCHAR(150) NULL, CalculateBrowserMarks VARCHAR(4) NULL, MakeSwapBufferOnly VARCHAR(4) NULL, NoMarkAdjustment VARCHAR(4) NULL, NoMarkAdjPmtOnValueDate VARCHAR(4) NULL, NoMarkAdjPerStartMisMatch VARCHAR(4) NULL, NoMarkFeeAdjustment VARCHAR(4) NULL, PrintSwapBufferOnly VARCHAR(4) NULL, SaveBrowserMarksToDB VARCHAR(4) NULL, SaveMarksToDB VARCHAR(4) NULL, TestSwapBuffer VARCHAR(4) NULL, TrxMarkAdjustment VARCHAR(4) NULL, UseActualMTMPolicy VARCHAR(4) NULL, CollectorMarkOption VARCHAR(25) NULL, BrowserMarkFlag INT NULL, CollectorMarkFlag INT NULL, CreditMarkFlag INT NULL, FinancialMarkFlag INT NULL, JobStatusFlag INT NULL, ImportMarkFlag INT NULL, MarkFileSplitFlag INT NULL, MarkFileSplitSize INT NULL, MaxFileSplitNumber INT NULL, MaxReprocessNumber INT NULL, MarkFileSourceLocation VARCHAR(40) NULL, OafnLocationCode VARCHAR(25) NULL, OafnDeskCode VARCHAR(25) NULL, OafnSwapCode VARCHAR(25) NULL, Environment VARCHAR(25) NULL, Machine VARCHAR(50) NULL, DataBaseServer VARCHAR(50) NULL, OafnTargetDir VARCHAR(150) NULL, OafnContTargetDir VARCHAR(150) NULL, JobStatusTargetServer VARCHAR(50) NULL, JobStatusTargetDir VARCHAR(150) NULL, JobStatusFtpID VARCHAR(25) NULL, JobStatusFtpPassword VARCHAR(25) NULL, MarkingSystemContact VARCHAR(255) NULL, MarkingSystemGroupEmail VARCHAR(255) NULL, MarkingSysPassedFlag INT NULL, CheckMarkFileSize INT NULL, CPMBrowserMarkFlag INT NULL, CPMFinancialMarkFlag INT NULL, FinancialSftpFlag INT NULL, JobStatusSftpFlag INT NULL, SkipPFSFlag INT NULL, FinMarkFileGenFirst INT NULL);
DROP TABLE MasterIndexTable;
CREATE TABLE MasterIndexTable (IndexId INT, DocRootId INT, IndexName VARCHAR(40) NULL);
DROP TABLE OasysDataTypeMapping;
CREATE TABLE OasysDataTypeMapping (OasysDataType VARCHAR(255), JavaDataType VARCHAR(255) NULL, SybaseDataType VARCHAR(255) NULL);
DROP TABLE OasysPublicKey;
CREATE TABLE OasysPublicKey (StartDate INT, PublicKey TEXT);
DROP TABLE PreferredReport;
CREATE TABLE PreferredReport (ReportType VARCHAR(40), Report VARCHAR(75), TeamMember VARCHAR(75), AssignedTo VARCHAR(75));
DROP TABLE Query;
CREATE TABLE Query (QueryID INT, SQLOperation INT NULL);
DROP TABLE QueryAction;
CREATE TABLE QueryAction (QueryID INT, ActionID INT, TableName VARCHAR(255) NULL, ColumnName VARCHAR(255) NULL, Value VARCHAR(255) NULL);
DROP TABLE QueryCondition;
CREATE TABLE QueryCondition (QueryID INT, ConditionNumber INT, LogicalOperator INT NULL, Parent INT NULL);
DROP TABLE QueryConditionValue;
CREATE TABLE QueryConditionValue (QueryID INT, ConditionNumber INT, RelationalOperator INT, TableName VARCHAR(50), ColumnName VARCHAR(50), Value VARCHAR(1800));
DROP TABLE QueryIndex;
CREATE TABLE QueryIndex (QueryID INT, TableName VARCHAR(50), IndexName VARCHAR(50));
DROP TABLE Report;
CREATE TABLE Report (ReportType VARCHAR(40), Report VARCHAR(75), TeamMember VARCHAR(75) NULL, DynamicSQLIndicator INT NULL, OverRideDynamicQueryLimit INT NULL, FilterType INT NULL, CustomResultsColumnName VARCHAR(255) NULL, CRC INT NULL, QueryID INT NULL, AccessType INT NULL, HistoryAllowed INT NULL, ParentReport VARCHAR(255) NULL, IsDefault INT NULL, Description VARCHAR(255) NULL, CreatedBy VARCHAR(75) NULL, CreatedTimestamp DATETIME NULL, ModifiedBy VARCHAR(75) NULL, ModifiedTimestamp DATETIME NULL);
DROP TABLE ReportActivity;
CREATE TABLE ReportActivity (TeamMember VARCHAR(75) NULL, ReportType VARCHAR(40) NULL, Report VARCHAR(75) NULL, Action VARCHAR(255) NULL, ActionTime DATETIME NULL, ActionTimeZone VARCHAR(255) NULL, Note VARCHAR(255) NULL);
DROP TABLE ReportCustomization;
CREATE TABLE ReportCustomization (ReportType VARCHAR(40), Report VARCHAR(75), TeamMember VARCHAR(75) NULL, ViewIndicator INT, SortIndicator INT, Attribute VARCHAR(255) NULL, Header VARCHAR(255) NULL, CustomizationOrder INT, Format VARCHAR(255) NULL, NullRepresentation VARCHAR(255) NULL, Total INT NULL, SubTotalLevel INT NULL, TableName VARCHAR(40) NULL, DisplayWidth INT NULL);
DROP TABLE ReportGroup;
CREATE TABLE ReportGroup (TeamMember VARCHAR(75), ReportGroup VARCHAR(40), ReportType VARCHAR(40), Report VARCHAR(75), AddTime DATETIME NULL, AddTimeZone VARCHAR(255) NULL, Note VARCHAR(255) NULL);
DROP TABLE ReportSegment;
CREATE TABLE ReportSegment (ReportType VARCHAR(40), Report VARCHAR(75), TeamMember VARCHAR(75) NULL, Type INT, SegmentNumber INT, Segment VARCHAR(255) NULL);
DROP TABLE RestrictedDataAccesEntity;
CREATE TABLE RestrictedDataAccesEntity (AccessObject VARCHAR(40), AccessEntity VARCHAR(40), AccessEntityValue VARCHAR(40));
DROP TABLE RuleDocLink;
CREATE TABLE RuleDocLink (RuleNumber INT, AttachmentID INT, DisplayName VARCHAR(255) NULL, FileLink VARCHAR(255) NULL);
DROP TABLE RuleHeader;
CREATE TABLE RuleHeader (RuleNumber INT, TeamMember VARCHAR(75) NULL, LastModified DATETIME NULL, ApplicationName VARCHAR(255) NULL, RuleName VARCHAR(255) NULL, QueryID INT NULL, DBLastModifiedTime DATETIME NULL, SeqNumber INT NULL, RuleType VARCHAR(255) NULL, Comments VARCHAR(500) NULL, ReviewedBy VARCHAR(40) NULL, ReviewedTimeStamp DATETIME NULL, ReviewedTZ VARCHAR(10) NULL, LastModifiedBy VARCHAR(40) NULL, RuleApplicationMode INT DEFAULT 2, Active INT NULL, USDEqvMax FLOAT NULL, USDEqvMin FLOAT NULL);
DROP TABLE SiteMinderConfiguration;
CREATE TABLE SiteMinderConfiguration (Type VARCHAR(255) NULL, AgentName VARCHAR(255), AgentConfigObject VARCHAR(255) NULL, EmailPasswordURL VARCHAR(255) NULL, ChangePasswordURL VARCHAR(255) NULL);
DROP TABLE StoredProcParam;
CREATE TABLE StoredProcParam (Name VARCHAR(255), ParamName VARCHAR(255), Type VARCHAR(255), ResCol1 VARCHAR(255) NULL, ResCol2 VARCHAR(255) NULL, ResCol3 VARCHAR(255) NULL);
DROP TABLE StructuredNote;
CREATE TABLE StructuredNote (Class VARCHAR(40), Type VARCHAR(40), LongName VARCHAR(255) NULL, Description VARCHAR(255) NULL, CRC INT NULL);
DROP TABLE StructuredNoteSegment;
CREATE TABLE StructuredNoteSegment (Class VARCHAR(40), Type VARCHAR(40), NoteSegmentNumber INT, NoteSegment VARCHAR(255) NULL);
DROP TABLE TPEWLStore;
CREATE TABLE TPEWLStore (id INT, type INT, handle INT, record IMAGE, PRIMARY KEY (id));
DROP TABLE TableMetaData;
CREATE TABLE TableMetaData (TableName VARCHAR(255), ColumnNumber INT, ColumnName VARCHAR(255) NULL, DataType VARCHAR(255) NULL, ApplicableForConfirms VARCHAR(1) DEFAULT 'N');
DROP TABLE TaxCenter;
CREATE TABLE TaxCenter (TaxCenterID INT, TaxCenterName VARCHAR(255) NULL);
DROP TABLE TaxEvent;
CREATE TABLE TaxEvent (TaxCenterID INT, EventType INT, EventSubType INT NULL);
DROP TABLE TaxProductMapping;
CREATE TABLE TaxProductMapping (TaxCenterID INT, ProductClass INT, TaxedType INT, Taxable INT NULL, TaxRetentionCode VARCHAR(255) NULL);
DROP TABLE TaxRate;
CREATE TABLE TaxRate (TaxCenterID INT, TaxedType INT, CustomerType VARCHAR(40), CustomerBranch VARCHAR(255) NULL, Domicile VARCHAR(255) NULL, EffectiveStart INT, EffectiveEnd INT, TenorStart INT, TenorEnd INT, TaxRate FLOAT NULL, LastModified DATETIME NULL, LastModifiedTimeZone VARCHAR(255) NULL, LastModifiedBy VARCHAR(75) NULL, LastSigned DATETIME NULL, LastSignedTimeZone VARCHAR(255) NULL, LastSignedBy VARCHAR(75) NULL, ProductClass INT NULL);
DROP TABLE TeamMember;
CREATE TABLE TeamMember (TeamMember VARCHAR(75), Department VARCHAR(255) NULL, SybaseID VARCHAR(255) NULL, EmployeeIdentification INT NULL, EMailAddress VARCHAR(255) NULL, Telephone VARCHAR(255) NULL, CRC INT NULL, CostCentre VARCHAR(40) NULL, PWD VARCHAR(40) NULL, OldPWD VARCHAR(255) NULL, PreExpired INT NULL, Disabled INT NULL, LoginAttempts INT NULL, EntryDate INT NULL, ExpiryDate INT NULL, TeamMemberType INT NULL, SiteminderAuthentication INT NULL, FunctionalAccount INT NULL, Owner VARCHAR(255) NULL, Description VARCHAR(255) NULL, FirstName VARCHAR(75) NULL, LastName VARCHAR(75) NULL, Supervisor VARCHAR(75) NULL, Region VARCHAR(40) NULL, Country VARCHAR(40) NULL, Location VARCHAR(255) NULL, BusinessAreaID INT NULL, ApprovedBy VARCHAR(75) NULL, Approved DATETIME NULL, ApprovedTimeZone VARCHAR(40) NULL, CreatedBy VARCHAR(75) NULL, Created DATETIME NULL, CreatedTimeZone VARCHAR(40) NULL, BusinessLine VARCHAR(40) NULL, LastModifyBy VARCHAR(75) NULL, LastModify DATETIME NULL, LastModifyTimeZone VARCHAR(40) NULL);
DROP TABLE TeamMemberDataAccessPrivileges;
CREATE TABLE TeamMemberDataAccessPrivileges (TeamMember VARCHAR(75), AccessObject VARCHAR(255), AccessPrivilege INT, AccessEntity VARCHAR(255), AccessEntityValue VARCHAR(255), FilterType VARCHAR(255) NULL, ApprovedBy VARCHAR(75) NULL, Approved DATETIME NULL, ApprovedTimeZone VARCHAR(40) NULL);
DROP TABLE TeamMemberGroupLink;
CREATE TABLE TeamMemberGroupLink (TeamMember VARCHAR(75), TeamMemberGroup VARCHAR(75), ApprovedBy VARCHAR(75) NULL, Approved DATETIME NULL, ApprovedTimeZone VARCHAR(40) NULL);
DROP TABLE TeamMemberLimits;
CREATE TABLE TeamMemberLimits (TeamMember VARCHAR(75), Type VARCHAR(255), Limit INT NULL, ApprovedBy VARCHAR(75) NULL, Approved DATETIME NULL, ApprovedTimeZone VARCHAR(40) NULL);
DROP TABLE TeamMemberPreferences;
CREATE TABLE TeamMemberPreferences (TeamMember VARCHAR(75), Type VARCHAR(255), Value VARCHAR(255) NULL);
DROP TABLE TeamMemberPrivileges;
CREATE TABLE TeamMemberPrivileges (TeamMember VARCHAR(75), TeamMemberPrivilege VARCHAR(255), ApprovedBy VARCHAR(75) NULL, Approved DATETIME NULL, ApprovedTimeZone VARCHAR(40) NULL);
DROP TABLE Ticket;
CREATE TABLE Ticket (TicketID INT, CurrentQueue VARCHAR(255) NULL, PrevQueue VARCHAR(255) NULL, Originator VARCHAR(255) NULL, CreatedBy VARCHAR(75) NULL, CreatedTimeStamp DATETIME NULL, LastModifiedBy VARCHAR(75) NULL, LastModifiedTimeStamp DATETIME NULL, Status VARCHAR(255) NULL, Type VARCHAR(255) NULL, State INT NULL);
DROP TABLE TransactionLog;
CREATE TABLE TransactionLog (Class VARCHAR(30), ClassKey VARCHAR(212), TeamMember VARCHAR(75), ApplicationName VARCHAR(255) NULL, HostName VARCHAR(255), LogTime DATETIME NULL, LogTimeZone VARCHAR(255) NULL, Status INT NULL, Comment VARCHAR(255) NULL, TeamMemberTerminator VARCHAR(75) NULL, HostNameTerminator VARCHAR(255) NULL, spid INT NULL);
DROP TABLE UserActivity;
CREATE TABLE UserActivity (ActivityID INT, ModuleName VARCHAR(100) NULL, ReferenceKey INT, ActivityDescription VARCHAR(100) NULL, Maker VARCHAR(100) NULL, MakerOperationTimestamp DATETIME NULL, Checker VARCHAR(100) NULL, CheckerOperationTimestamp DATETIME NULL, UserOperationType VARCHAR(25), IsLastAuditEntry VARCHAR(25), CrossReferenceKey INT NULL);
DROP TABLE ViolationLog;
CREATE TABLE ViolationLog (SybaseID VARCHAR(255), ViolationTimeGMT DATETIME, ViolationType VARCHAR(255), TeamMember VARCHAR(75) NULL, CostCentre VARCHAR(40) NULL, PrivilegeName VARCHAR(255) NULL, LoginAttempts INT NULL, HostName VARCHAR(255) NULL, HostTimeStamp DATETIME NULL, HostTimeZone VARCHAR(255) NULL, Description VARCHAR(255) NULL);
DROP TABLE WFDActivity;
CREATE TABLE WFDActivity (ProcessID VARCHAR(255), ActivityID VARCHAR(255), BlockActivityID VARCHAR(255) NULL, ActivityDescription VARCHAR(255) NULL, Type INT NULL, ResourceID INT NULL, UserViewable INT NULL, IsBlockActivity INT NULL);
DROP TABLE WFDDeadline;
CREATE TABLE WFDDeadline (ProcessID VARCHAR(255), ActivityID VARCHAR(255), DeadlineID INT, Type INT NULL, DeadlineValue INT NULL);
DROP TABLE WFDProcess;
CREATE TABLE WFDProcess (ProcessID VARCHAR(255), Description VARCHAR(255) NULL);
DROP TABLE WFDResource;
CREATE TABLE WFDResource (ResourceID VARCHAR(255), ResourceName VARCHAR(255), Type INT NULL);
DROP TABLE WFDTransition;
CREATE TABLE WFDTransition (ProcessID VARCHAR(255), TransitionID INT, FromActivity VARCHAR(255) NULL, ToActivity VARCHAR(255) NULL, HasTransitionCondition INT NULL);
DROP TABLE WFDTransitionReference;
CREATE TABLE WFDTransitionReference (ProcessID VARCHAR(255), ActivityID VARCHAR(255), TransitionRestriction INT, TransitionID INT);
DROP TABLE WFDTransitionRestriction;
CREATE TABLE WFDTransitionRestriction (ProcessID VARCHAR(255), ActivityID VARCHAR(255), TransitionRestriction INT);
DROP TABLE WFRTActivity;
CREATE TABLE WFRTActivity (TicketID INT, ProcessID VARCHAR(255), ActivityID VARCHAR(255), State INT NULL, CreatedTimeStamp DATETIME NULL, LastModifiedTimeStamp DATETIME NULL);
DROP TABLE WFRTAndJoinEntry;
CREATE TABLE WFRTAndJoinEntry (TicketID INT, ProcessID VARCHAR(255), ToActivityID VARCHAR(255), FromActivityID VARCHAR(255), CreatedTimeStamp DATETIME NULL, LastModifiedTimeStamp DATETIME NULL);
DROP TABLE WFRTDeadline;
CREATE TABLE WFRTDeadline (TicketID INT, ProcessID VARCHAR(255), ActivityID VARCHAR(255), DeadlineID INT, ActivityStartTime DATETIME NULL);
DROP TABLE WFRTEventAudit;
CREATE TABLE WFRTEventAudit (TicketID INT, ProcessID VARCHAR(255), ActivityID VARCHAR(255), ActivityDescription VARCHAR(255) NULL, Status VARCHAR(255) NULL, State INT NULL, LastModifiedBy VARCHAR(75) NULL, LastModifiedTimeStamp DATETIME NULL, StartTimeStamp DATETIME NULL, EndTimeStamp DATETIME NULL);
DROP TABLE WFRTProcess;
CREATE TABLE WFRTProcess (TicketID INT, ProcessID VARCHAR(255), State INT NULL, CreatedTimeStamp DATETIME NULL, LastModifiedTimeStamp DATETIME NULL);
DROP TABLE WFRTWorklist;
CREATE TABLE WFRTWorklist (TicketID INT, ProcessID VARCHAR(255), ActivityID VARCHAR(255), State INT NULL, CreatedTimeStamp DATETIME NULL, LastModifiedTimeStamp DATETIME NULL);
DROP TABLE Word;
CREATE TABLE Word (Word VARCHAR(255));
ALTER TABLE EmployeeDetails ADD CONSTRAINT EmployeeDe_sybfi5_366936679 CHECK (TeamMember) MATERIALIZE);
DROP VIEW CodeView;
CREATE VIEW CodeView (Type, Code) AS select Type, Code from CDB..Code where Type ='MicroControlCode'
;
DROP VIEW sysquerymetrics;
CREATE VIEW sysquerymetrics (uid, gid, hashkey, id, sequence, exec_min, exec_max, exec_avg, elap_min, elap_max, elap_avg, lio_min, lio_max, lio_avg, pio_min, pio_max, pio_avg, cnt, abort_cnt, qtext) AS select  a.uid, -a.gid, a.hashkey, a.id, a.sequence, convert(int, substring(b.text, charindex('e1', b.text) + 3, charindex('e2', b.text) - charindex('e1', b.text) - 4)), convert(int, substring(b.text, charindex('e2', b.text) + 3, charindex('e3', b.text) - charindex('e2', b.text) - 4)), convert(int, substring(b.text, charindex('e3', b.text) + 3, charindex('t1', b.text) - charindex('e3', b.text) - 4)), convert(int, substring(b.text, charindex('t1', b.text) + 3, charindex('t2', b.text) - charindex('t1', b.text) - 4)), convert(int, substring(b.text, charindex('t2', b.text) + 3, charindex('t3', b.text) - charindex('t2', b.text) - 4)), convert(int, substring(b.text, charindex('t3', b.text) + 3, charindex('l1', b.text) - charindex('t3', b.text) - 4)), convert(int, substring(b.text, charindex('l1', b.text) + 3, charindex('l2', b.text) - charindex('l1', b.text) - 4)), convert(int, substring(b.text, charindex('l2', b.text) + 3, charindex('l3', b.text) - charindex('l2', b.text) - 4)), convert(int, substring(b.text, charindex('l3', b.text) + 3, charindex('p1', b.text) - charindex('l3', b.text) - 4)), convert(int, substring(b.text, charindex('p1', b.text) + 3, charindex('p2', b.text) - charindex('p1', b.text) - 4)), convert(int, substring(b.text, charindex('p2', b.text) + 3, charindex('p3', b.text) - charindex('p2', b.text) - 4)), convert(int, substring(b.text, charindex('p3', b.text) + 3, charindex('c', b.text) - charindex('p3', b.text) - 4)), convert(int, substring(b.text, charindex('c', b.text) + 2, charindex('ac', b.text) - charindex('c', b.text) - 3)), convert(int, substring(b.text, charindex('ac', b.text) + 3, char_length(b.text) - charindex('ac', b.text) - 2)), a.text from sysqueryplans a, sysqueryplans b where (a.type = 10) and (b.type =1000) and (a.id = b.id) and a.uid = b.uid and a.gid = b.gid;
DROP PROCEDURE AccessEntityDataObjectMapDel;
--/
CREATE PROCEDURE AccessEntityDataObjectMapDel (
/**************************************************************************
**
** Procedure:	AccessEntityDataObjectMapDel
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@AccessEntity          varchar(40),
	@SourceDataObject      varchar(40)
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from AccessEntityDataObjectMap 
where AccessEntity = @AccessEntity
and    SourceDataObject = @SourceDataObject
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from AccessEntityDataObjectMap table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from AccessEntityDataObjectMap table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "AccessEntity '" + convert(varchar(255), @AccessEntity) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "SourceDataObject '" + convert(varchar(255), @SourceDataObject) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode AccessEntityDataObjectMapDel, unchained;
DROP PROCEDURE AccessEntityDataObjectMapIns;
--/
CREATE PROCEDURE AccessEntityDataObjectMapIns (
/**************************************************************************
**
** Procedure:	AccessEntityDataObjectMapIns
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@AccessEntity          varchar(40),
	@SourceDataObject      varchar(40),
	@DestinationDataObject varchar(40) = NULL,
	@DataComponent         varchar(40) = NULL,
	@ConditionType         varchar(40) = NULL
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into AccessEntityDataObjectMap (
	AccessEntity,
	SourceDataObject,
	DestinationDataObject,
	DataComponent,
	ConditionType )
values (
	@AccessEntity,
	@SourceDataObject,
	@DestinationDataObject,
	@DataComponent,
	@ConditionType )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into AccessEntityDataObjectMap table for key(s) "
	select @ErrorMessage = @ErrorMessage + "AccessEntity '" + convert(varchar(255), @AccessEntity) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "SourceDataObject '" + convert(varchar(255), @SourceDataObject) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode AccessEntityDataObjectMapIns, unchained;
DROP PROCEDURE AccessEntityDataObjectMapUpd;
--/
CREATE PROCEDURE AccessEntityDataObjectMapUpd (
/**************************************************************************
**
** Procedure:	AccessEntityDataObjectMapUpd
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@AccessEntity          varchar(40),
	@SourceDataObject      varchar(40),
	@DestinationDataObject varchar(40) = "#$%@",
	@DataComponent         varchar(40) = "#$%@",
	@ConditionType         varchar(40) = "#$%@"
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @destinationDataObject varchar(40),
        @dataComponent         varchar(40),
        @conditionType         varchar(40)
Select @destinationDataObject = DestinationDataObject,
       @dataComponent = DataComponent,
       @conditionType = ConditionType
from AccessEntityDataObjectMap
  where AccessEntity = @AccessEntity
  and SourceDataObject = @SourceDataObject
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from AccessEntityDataObjectMap table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from AccessEntityDataObjectMap table for key(s) "
	goto ERROR_EXIT
end
if @DestinationDataObject != "#$%@"
	select @destinationDataObject = @DestinationDataObject
if @DataComponent != "#$%@"
	select @dataComponent = @DataComponent
if @ConditionType != "#$%@"
	select @conditionType = @ConditionType
Update AccessEntityDataObjectMap
set	DestinationDataObject = @destinationDataObject,
	DataComponent = @dataComponent,
	ConditionType = @conditionType
  where AccessEntity = @AccessEntity
  and SourceDataObject = @SourceDataObject
if @@error != 0
begin
	select @ErrorMessage = "Could not update AccessEntityDataObjectMap table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "AccessEntity '" + convert(varchar(255), @AccessEntity) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "SourceDataObject '" + convert(varchar(255), @SourceDataObject) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode AccessEntityDataObjectMapUpd, unchained;
DROP PROCEDURE AccountClassification;
--/
CREATE PROCEDURE AccountClassification
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "@(#)AccountClassification.sp	131.1 10/20/09"
select "CodeType", "AccountClassification", NULL, NULL, NULL, NULL
select "AccountClassification", Code, NULL, NULL, NULL, NULL
from CDB.dbo.Code 
where Type = 'ISDAAccountClassification'


/
EXEC sp_procxmode AccountClassification, unchained;
DROP PROCEDURE ActivateTransaction;
--/
CREATE PROCEDURE ActivateTransaction
/*M***************************************************************************
**
** Classes: 	ActivateTransaction
**
** Version: 	@(#)ActivateTransaction.proc	63.1 08/06/01
**
** Notes:
**
*****************************************************************************/
	(
	@Class			varchar(255),
	@ClassKey		varchar(255),
	@TeamMember		varchar(75),
	@Application		varchar(255),
	@spid			int
	)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
	declare		@Version  varchar(255)
	select @Version = "@(#)ActivateTransaction.proc	63.1 08/06/01"
declare	@NumberRows		int,
	@HostName		varchar(255),
	@ErrorMessage		varchar(255)
if (not (@Class != NULL)) begin select @ErrorMessage =  "Class is NULL" raiserror 20003 @ErrorMessage goto ERROR_EXIT end
if (not (@ClassKey != NULL)) begin select @ErrorMessage =  "Key is NULL" raiserror 20003 @ErrorMessage goto ERROR_EXIT end
if (not (@Application != NULL)) begin select @ErrorMessage =  "Application is NULL" raiserror 20003 @ErrorMessage goto ERROR_EXIT end
if (not (@TeamMember != NULL)) begin select @ErrorMessage =  "TeamMember is NULL in TeamMemberCode." raiserror 20003 @ErrorMessage goto ERROR_EXIT end
if (not (@spid != NULL)) begin select @ErrorMessage =  "spid can not be NULL." raiserror 20003 @ErrorMessage goto ERROR_EXIT end
select @HostName = host_name()
update TransactionLog set Status = 2 where Class =  @Class and ClassKey =  @ClassKey and TeamMember =  @TeamMember and HostName =  @HostName and ApplicationName =  @Application and (Status = 1 or Status = 2) select  @NumberRows = @@rowcount if @@error != 0 begin goto ERROR_EXIT end if ( @NumberRows = 0) begin select  @ErrorMessage = "The transaction can not be ACTIVATED "+ "because it has not been OPENED." raiserror  20002  @ErrorMessage goto ERROR_EXIT end
ERROR_EXIT:


/
EXEC sp_procxmode ActivateTransaction, unchained;
DROP PROCEDURE AffirmStaffAsCode;
--/
CREATE PROCEDURE AffirmStaffAsCode
/**********************************************************************************
**
**
** Procedure : AffirmStaffAsCode
**
** Version   :    @(#)AffirmStaffAsCode.proc	63.1 08/07/01 
**
** Notes     :
**
**********************************************************************************/
as 
 set compatibility_mode off 
declare         @version  varchar(255)
select @version = "@(#)AffirmStaffAsCode.proc	63.1 08/07/01"
select "CodeType", "AffirmStaff", NULL, NULL, NULL, NULL
select "AffirmStaff", TeamMember, NULL, NULL, NULL, NULL from CDB..TeamMemberGroupLink
where TeamMemberGroup = 'PWMS-Settlement-grp'
order by TeamMember


/
EXEC sp_procxmode AffirmStaffAsCode, unchained;
DROP PROCEDURE AgreementType;
--/
CREATE PROCEDURE AgreementType
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "@(#)AgreementType.sp	130.1 06/25/09"
select "CodeType", "AgreementType", NULL, NULL, NULL, NULL
select "AgreementType", Code, NULL, NULL, NULL, NULL
from CDB.dbo.Code 
where Type = 'ISDAAgreementTypes'


/
EXEC sp_procxmode AgreementType, unchained;
DROP PROCEDURE AllClassificationCodes;
--/
CREATE PROCEDURE AllClassificationCodes
/**********************************************************************************
**
**
** Procedure : AllClassificationCodes
**
** Version   :   @(#)AllClassificationCodes.proc	63.1 08/06/01 
**
** Notes     :
**
**********************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select @version = "@(#)AllClassificationCodes.proc	63.1 08/06/01"
select distinct "CodeType", Class+"::"+SchemaName, NULL, NULL, NULL, NULL
from ClassificationCode
select Class+"::"+SchemaName, Code, NULL, LongName, Description, NULL
from ClassificationCode
order by 1,Code


/
EXEC sp_procxmode AllClassificationCodes, unchained;
DROP PROCEDURE AllClassificationCodesForDealManager;
--/
CREATE PROCEDURE AllClassificationCodesForDealManager
/**********************************************************************************
**
**
** Procedure : AllClassificationCodesForDealManager
**
** Version   :   @(#)AllClassificationCodesForDealManager.proc	63.1 08/06/01 
**
** Notes     :
**
**********************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select @version = "@(#)AllClassificationCodesForDealManager.proc	63.1 08/06/01"
select distinct "CodeType", Class+"::"+SchemaName, NULL, NULL, NULL, NULL
from ClassificationCode
select code.Class+"::"+sche.SchemaName, code.Code, NULL, LongName, code.Description,sche.MultipleEntryIndicator, NULL
from ClassificationCode code inner join ClassificationSchema sche on code.Class = sche.Class and code.SchemaName = sche.SchemaName
order by 1,Code


/
EXEC sp_procxmode AllClassificationCodesForDealManager, unchained;
DROP PROCEDURE AllClassificationKeys;
--/
CREATE PROCEDURE AllClassificationKeys 
/**************************************************************************
**
** Procedure:   AllClassificationKeys
**
** Version:     "@(#)AllClassificationKeys.proc	63.1 08/06/01"
**
** Notes:       
**
**************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select @version = "@(#)AllClassificationKeys.proc	63.1 08/06/01"
select  Class + "|" + SchemaName
from  ClassificationSchema


/
EXEC sp_procxmode AllClassificationKeys, unchained;
DROP PROCEDURE AllCodeKeys;
--/
CREATE PROCEDURE AllCodeKeys
/**********************************************************************************
**
**
** Procedure : 	AllCodeKeys
**
** Version   :  "@(#)AllCodeKeys.proc	63.1 08/06/01" 
**
** Notes     :
**
**********************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare  @version varchar(255)
select @version = "@(#)AllCodeKeys.proc	63.1 08/06/01"
select Code from Code
where Type = "CodeType"


/
EXEC sp_procxmode AllCodeKeys, unchained;
DROP PROCEDURE AllCodes;
--/
CREATE PROCEDURE AllCodes
/**********************************************************************************
**
**
** Procedure : AllCodes
**
** Version   :    @(#)AllCodes.proc	63.1 08/06/01 
**
** Notes     :
**
**********************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select @version = "@(#)AllCodes.proc	63.1 08/06/01"
/* Adaptive Server has expanded all '*' elements in the following statement */ select Code.Type, Code.Code, Code.ExternalCode, Code.LongName, Code.Description, Code.CRC from Code where Type =  "CodeType" and Code != "CodeType"
/* Adaptive Server has expanded all '*' elements in the following statement */ select Code.Type, Code.Code, Code.ExternalCode, Code.LongName, Code.Description, Code.CRC from Code where Type != "CodeType"
order by Type,Code


/
EXEC sp_procxmode AllCodes, unchained;
DROP PROCEDURE AllDealManagerRequestPrivileges;
--/
CREATE PROCEDURE AllDealManagerRequestPrivileges
/**********************************************************************************
**
**
** Procedure : AllDealManagerRequestPrivileges
**
** Version   :   @(#)AllDealManagerRequestPrivileges.proc       63.1 08/06/01
**
** Notes     :
**
**********************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select @version = "@(#)AllDealManagerRequestPrivileges.proc     63.1 08/06/01"
select distinct "CodeType", RequestID, NULL, NULL, NULL, NULL
from AppRequestIDPrivilegeMap
select RequestID,Privilege,NULL,NULL,NULL,NULL from AppRequestIDPrivilegeMap order by RequestID


/
EXEC sp_procxmode AllDealManagerRequestPrivileges, unchained;
DROP PROCEDURE AllHolidayKeys;
--/
CREATE PROCEDURE AllHolidayKeys
/**************************************************************************
**
** Procedure:  AllHolidayKeys 
**
** Version:     "@(#)AllHolidayKeys.proc	63.1 08/06/01"
**
** Notes:       
**
**************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select @version = "@(#)AllHolidayKeys.proc	63.1 08/06/01"
select distinct Calendar from Holiday


/
EXEC sp_procxmode AllHolidayKeys, unchained;
DROP PROCEDURE AllHolidays;
--/
CREATE PROCEDURE AllHolidays
/**********************************************************************************
**
**
** Procedure : AllHolidays
**
** Version   :    @(#)AllHolidays.proc	63.1 08/06/01
**
** Notes     :
**
**********************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select @version = "@(#)AllHolidays.proc	63.1 08/06/01"
/* Adaptive Server has expanded all '*' elements in the following statement */ select Holiday.Calendar, Holiday.Holiday, Holiday.HolidayName, Holiday.CRC from Holiday
order by Calendar, Holiday
/* Adaptive Server has expanded all '*' elements in the following statement */ select HolidayDefinition.Calendar, HolidayDefinition.Weekend, HolidayDefinition.CalendarName from HolidayDefinition
order by Calendar


/
EXEC sp_procxmode AllHolidays, unchained;
DROP PROCEDURE AllReportKeys;
--/
CREATE PROCEDURE AllReportKeys
/**************************************************************************
**
** Procedure:   AllReportKeys
**
** Version:     "@(#)AllReportKeys.proc	63.1 08/06/01"
**
** Notes:       
**
**************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select @version = "@(#)AllReportKeys.proc	63.1 08/06/01"
select TeamMember + "|" + ReportType + "|" + Report
from Report


/
EXEC sp_procxmode AllReportKeys, unchained;
DROP PROCEDURE AllSchemaCodes;
--/
CREATE PROCEDURE AllSchemaCodes
/**********************************************************************************
**
**
** Procedure : AllSchemaCodes
**
** Version   :   @(#)AllSchemaCodes.proc	63.1 08/06/01 
**
** Notes     :
**
**********************************************************************************/
as
declare         @version  varchar(255)
select @version = "@(#)AllSchemaCodes.proc	63.1 08/06/01"
select "CodeType", Class, NULL, NULL, NULL, NULL
from ClassificationSchema
select Class, SchemaName, NULL, NULL, Description, NULL
from ClassificationSchema
order by Class,SchemaName


/
EXEC sp_procxmode AllSchemaCodes, unchained;
DROP PROCEDURE AllStructuredNoteKeys;
--/
CREATE PROCEDURE AllStructuredNoteKeys 
/**************************************************************************
**
** Procedure:   AllStructuredNoteKeys
**
** Version:     "@(#)AllStructuredNoteKeys.proc	63.1 08/06/01"
**
** Notes:       
**
*************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select @version = "@(#)AllStructuredNoteKeys.proc	63.1 08/06/01"
select Class + "|" + Type 
from StructuredNote


/
EXEC sp_procxmode AllStructuredNoteKeys, unchained;
DROP PROCEDURE AllTeamMemberGroups;
--/
CREATE PROCEDURE AllTeamMemberGroups
/**************************************************************************
**
** Procedure: TeamMemberGroups
**
** Version: %W% %G%
**
** Notes:            Returns list of team member groups
**
**************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
set nocount on
declare @version  varchar(255)
select @version = '@(#) %W% %G%'
select 'CodeType', 'TeamMemberGroups', NULL, NULL, NULL, NULL
select 'TeamMemberGroups', TeamMember, NULL, NULL, NULL, NULL
from TeamMember
where TeamMemberType = 2


/
EXEC sp_procxmode AllTeamMemberGroups, unchained;
DROP PROCEDURE AllTeamMemberKeys;
--/
CREATE PROCEDURE AllTeamMemberKeys
/*************************************************************************
**
** Procedure:   AllTeamMemberKeys 
**
** Version:     "@(#)AllTeamMemberKeys.proc	63.1 08/06/01"
**
** Notes:       
**
**************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select @version = "@(#)AllTeamMemberKeys.proc	63.1 08/06/01"
select TeamMember from TeamMember


/
EXEC sp_procxmode AllTeamMemberKeys, unchained;
DROP PROCEDURE AllTeamMemberList;
--/
CREATE PROCEDURE AllTeamMemberList
as 
 set compatibility_mode off 
declare @version varchar(255)
select @version = "%W% %G%"
select "CodeType", "AllTeamMemberList", NULL, NULL, NULL, NULL
select distinct "AllTeamMemberList", TeamMember, NULL, NULL, NULL, NULL
from CDB.dbo.TeamMember


/
EXEC sp_procxmode AllTeamMemberList, unchained;
DROP PROCEDURE AllocateKey;
--/
CREATE PROCEDURE AllocateKey (
/*M***************************************************************************
**
** Classes:	AllocateKey.proc
**
** Version: 	@(#)AllocateKey.proc	63.1 08/06/01
**
** Notes:
**
*****************************************************************************/
	@Key		int	OUT,
	@KeyType	varchar(255),
	@BlockSize	int 	= 1
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @MaximumKeyInRange	int,
	@MaximumUsedKeyInRange	int,
	@RowCount		int,
	@ErrorMessage		varchar(255)
	begin Transaction AllocateKey
	update 	IntegerKeyAllocation
	set	MaximumUsedKeyInRange = MaximumUsedKeyInRange + @BlockSize
	where	KeyType = @KeyType
	select @MaximumKeyInRange = MaximumKeyInRange,
		@MaximumUsedKeyInRange = MaximumUsedKeyInRange
		from IntegerKeyAllocation 
	where	KeyType = @KeyType
	select @RowCount  = @@rowcount
			
	
if (not (@RowCount <= 1)) begin select @ErrorMessage =   		"There is more than one IntegerKeyAllocation row." raiserror 20003 @ErrorMessage goto ERROR_EXIT end 
	if (@RowCount = 0) begin
		select @ErrorMessage = "There are no " +
			"IntegerKeyAllocation rows for '" + @KeyType +
			"'."
		raiserror  20002 @ErrorMessage
		goto ERROR_EXIT
	end	
	if (@MaximumUsedKeyInRange > @MaximumKeyInRange) begin
		select @ErrorMessage = "There are no more keys " +
			"to allocate for key type '" + @KeyType +
			"'."
		raiserror  20002 @ErrorMessage
		select @Key = 0
		goto ERROR_EXIT
	end	
	select @Key = @MaximumUsedKeyInRange  - @BlockSize +1
	commit Transaction  AllocateKey
	
	goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	rollback transaction AllocateKey
	
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode AllocateKey, unchained;
DROP PROCEDURE AssignedToAsCode;
--/
CREATE PROCEDURE AssignedToAsCode
/**********************************************************************************
**
**
** Procedure : AssignedToAsCode
**
** Version   :    @(#)AssignedToAsCode.proc	63.1 08/07/01 
**
** Notes     :
**
**********************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select @version = "@(#)AssignedToAsCode.proc	63.1 08/07/01"
select "CodeType", "AssignedTo", NULL, NULL, NULL, NULL
select "AssignedTo", ServiceRep, NULL, NULL, NULL, NULL from CMDB..ServiceRepProfile
order by ServiceRep


/
EXEC sp_procxmode AssignedToAsCode, unchained;
DROP PROCEDURE Broker;
--/
CREATE PROCEDURE Broker
/*******************************************************************************
***
**
**
** Procedure : Broker
**
** Version   :
**
** Notes     :
**
********************************************************************************
**/
as 
 set compatibility_mode off 
declare         @version  varchar(255)
select distinct Mnemonic from ADB..ThirdPartyAccount where Type='Broker'


/
EXEC sp_procxmode Broker, unchained;
DROP PROCEDURE BusinessAreaList;
--/
CREATE PROCEDURE BusinessAreaList
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "%W% %G%"
select "CodeType", "BusinessAreaList", "ExternalCode", NULL, NULL, NULL
select "BusinessAreaList", Code, ExternalCode, NULL, NULL, NULL
from CDB.dbo.Code 
where Type = 'ISDAIndustryType'
ORDER BY Code


/
EXEC sp_procxmode BusinessAreaList, unchained;
DROP PROCEDURE BusinessGroups;
--/
CREATE PROCEDURE BusinessGroups
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "%W% %G%"
select "CodeType", "BusinessGroups", NULL, NULL, NULL, NULL
select "BusinessGroups", Code, NULL, NULL, NULL, NULL
from CDB.dbo.Code 
where Type = 'ISDABusinessGroups'


/
EXEC sp_procxmode BusinessGroups, unchained;
DROP PROCEDURE CPLGetBusinessRuleDataByMode;
--/
CREATE PROCEDURE CPLGetBusinessRuleDataByMode (@DataMapID varchar(100), @Status varchar(20), @Mode varchar(20), @CurrentUser varchar(100))
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
/*Case 1: SingleElementList*/
    declare 
    @CreateTableSql varchar(1000),
    @UpdateSql varchar(1000),
    @SelectSql varchar(3000),
    @SelectListColString varchar(1000),
    @SelectKeyColString varchar(1000),
    @KeyFieldName varchar(50),
    @ListFieldName varchar(50),
    @KeyFieldCount int,
    @ListFieldCount int,
	@IsKeyColumnVisible varchar(1),
    @KeyFieldCounter int,
    @ListFieldCounter int,
    @SingleElementList varchar(1),
    @KeyFieldValue varchar(255),
    @ListFieldValue varchar(1000),
    @DataInstanceNumber int,
	@ListElementNumber int
	
	
    select
    @KeyFieldCount = KeyFieldCount,
    @ListFieldCount = ListFieldCount,
    @SingleElementList = SingleElementList,
	@IsKeyColumnVisible = IsKeyColumnVisible
    from
    CDB..DataMapConfig
    where
    DataMapID = @DataMapID
	
	
	
	
    create table #DataMapRes
    (
    DataMapSequenceNumber int,
    DataInstanceNumber int,
    UserOperationType varchar(40) null,
    Maker varchar(100) null,
    MakerOperationTimestamp datetime null,
    Checker varchar(100) null,
    CheckerOperationTimestamp datetime null,
    KeyValue1 varchar(255) null,
    KeyValue2 varchar(255) null,
    KeyValue3 varchar(255) null,
    KeyValue4 varchar(255) null,
    KeyValue5 varchar(255) null,
    KeyValue6 varchar(255) null,
    KeyValue7 varchar(255) null,
    KeyValue8 varchar(255) null,
    KeyValue9 varchar(255) null,
    KeyValue10 varchar(255) null,
    KeyValue11 varchar(255) null,
    KeyValue12 varchar(255) null,
    KeyValue13 varchar(255) null,
    KeyValue14 varchar(255) null,
    KeyValue15 varchar(255) null,
    ListValue1 varchar(255) null,
    ListValue2 varchar(255) null,
    ListValue3 varchar(255) null,
    ListValue4 varchar(255) null,
    ListValue5 varchar(255) null,
    ListValue6 varchar(255) null,
    ListValue7 varchar(255) null,
    ListValue8 varchar(255) null,
    ListValue9 varchar(255) null,
    ListValue10 varchar(255) null
    )
	
	
   	if (@Status = 'Active')  
	begin
    insert into #DataMapRes
    (
        DataMapSequenceNumber,
        DataInstanceNumber,
        UserOperationType,
        Checker,
        CheckerOperationTimestamp
    )
    select DataMapSequenceNumber,
             DataInstanceNumber,
             UserOperationType,
             Checker,
             CheckerOperationTimestamp
    from
    CDB..DataMapContent a, CDB..UserActivity b
    where
        a.DataMapID = @DataMapID 
        and a.DataMapSequenceNumber = b.ReferenceKey 
        and b.IsLastAuditEntry = 'Y' 
        and DataMapInstanceStatus = 'Active'
	end   
    if @Status = 'Inactive'
    begin
        -- Gets DataInstanceNumber and DataMapSequenceNumber
        insert into #DataMapRes
        (
            DataMapSequenceNumber,
            DataInstanceNumber,
            UserOperationType,
            Maker,
            MakerOperationTimestamp
        )
    
    
        select
            DataMapSequenceNumber,
            DataInstanceNumber,
            UserOperationType,
            Maker,
            MakerOperationTimestamp
        from
        CDB..DataMapContent a, CDB..UserActivity b
        where
        a.DataMapID = @DataMapID and
        a.DataMapSequenceNumber = b.ReferenceKey and
        b.IsLastAuditEntry = 'Y' and 
        (
            DataMapInstanceStatus = 'Inactive' and 
                    (@Mode = 'Edit'
                 or (@Mode = 'Review' and Maker <> @CurrentUser))
        ) 
    end
    create table #DataMap
    (
        DataInstanceNumber int,
        ListValue1 varchar(255) null,
        ListValue2 varchar(255) null,
        ListValue3 varchar(255) null,
        ListValue4 varchar(255) null,
        ListValue5 varchar(255) null,
        ListValue6 varchar(255) null,
        ListValue7 varchar(255) null,
        ListValue8 varchar(255) null,
        ListValue9 varchar(255) null,
        ListValue10 varchar(255) null
    )
    
    
    
    if @SingleElementList = 'Y' 
    BEGIN
    
        insert into #DataMap(
            DataInstanceNumber,
            ListValue1,
            ListValue2,
            ListValue3,
            ListValue4,
            ListValue5,
            ListValue6,
            ListValue7,
            ListValue8,
            ListValue9,
            ListValue10)
        select 
            ldc.DataInstanceNumber,
            max(case when ldc.ListFieldNumber = 1 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 2 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 3 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 4 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 5 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 6 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 7 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 8 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 9 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 10 then ListFieldValue end)
        from CDB..ListDataContent ldc
        where ldc.DataMapID = @DataMapID
        group by ldc.DataMapID, ldc.DataInstanceNumber   
    END
    
    select @KeyFieldCounter = 0
    while (@KeyFieldCounter < @KeyFieldCount)
    begin 
        select @UpdateSql = 'update #DataMapRes set KeyValue' + convert(varchar,@KeyFieldCounter+1) + ' =  kdc.KeyFieldValue from CDB..KeyDataContent kdc where kdc.DataMapID = @DataMapID and kdc.DataInstanceNumber = #DataMapRes.DataInstanceNumber and kdc.KeyFieldNumber = ' + convert(varchar,@KeyFieldCounter+1)
        exec (@UpdateSql)
        
        select @KeyFieldCounter = @KeyFieldCounter + 1
    end
    
    if @SingleElementList = 'N' 
    BEGIN 
        declare @maxFieldElemntNumber int
        declare @maxDataInstanceNumber int
        declare @ListElementCounter int
        declare @DataInstanceNumberCounter int
        declare @FValue varchar(255)
        declare @FEValue varchar(255)
        declare @sqlDataMapInsert varchar(2000)
        declare @sqlInsertHeader varchar(255)
        
        select @maxFieldElemntNumber = max(ListElementNumber) 
        from CDB..ListDataContent 
        where DataMapID = @DataMapID
        
        
        select @maxDataInstanceNumber = max(DataInstanceNumber) 
        from CDB..ListDataContent 
        where DataMapID = @DataMapID
        select @sqlInsertHeader = 'INSERT INTO #DataMap(DataInstanceNumber'
        select @ListFieldCounter = 1
        while (@ListFieldCounter <= @ListFieldCount)
        begin            
            select @sqlInsertHeader = @sqlInsertHeader + ',ListValue' + convert(varchar, @ListFieldCounter) 
            select @ListFieldCounter = @ListFieldCounter + 1
        end
        
        select @sqlInsertHeader = @sqlInsertHeader + ') VALUES('
    
        select @DataInstanceNumberCounter = 1
        while @DataInstanceNumberCounter <= @maxDataInstanceNumber
        begin
            select @sqlDataMapInsert = @sqlInsertHeader + convert(varchar, @DataInstanceNumberCounter) 
            
            select @ListFieldCounter = 1
            while (@ListFieldCounter <= @ListFieldCount)
            begin
                select @FValue = null
                select @ListElementCounter = 1 
                while (@ListElementCounter <= @maxFieldElemntNumber)
                begin        
                    select @FEValue = null
                    select @FEValue = ListFieldValue 
                    from CDB..ListDataContent
                    where DataMapID = @DataMapID
                        and DataInstanceNumber = @DataInstanceNumberCounter                        
                        and ListFieldNumber = @ListFieldCounter
                        and ListElementNumber = @ListElementCounter                
                    --Modified by Raja on 01-Nov-2011, since all the list values are not displayed for Multiple List Rules(i.e SingleElementList ='N')
                    --select @FValue = COALESCE('', @FValue + '|') + @FEValue
    					if(@FEValue!=null and @FValue is null)
							select @FValue =@FEValue
						else if (@FEValue!=null)
							select @FValue = @FValue + '|' +@FEValue
                    select @ListElementCounter = @ListElementCounter + 1
                end
    
                select @sqlDataMapInsert = @sqlDataMapInsert + ',''' + @FValue + ''''
                
                select @ListFieldCounter = @ListFieldCounter + 1
            end
            
                select @sqlDataMapInsert = @sqlDataMapInsert + ')'
                
                
                exec (@sqlDataMapInsert)
                
            
            select @DataInstanceNumberCounter = @DataInstanceNumberCounter + 1
        end
    
    end
    update #DataMapRes 
    set  
        ListValue1 = dm.ListValue1,
        ListValue2 = dm.ListValue2,
        ListValue3 = dm.ListValue3,
        ListValue4 = dm.ListValue4,
        ListValue5 = dm.ListValue5,
        ListValue6 = dm.ListValue6,
        ListValue7 = dm.ListValue7,
        ListValue8 = dm.ListValue8,
        ListValue9 = dm.ListValue9,
        ListValue10 = dm.ListValue10
    from #DataMap dm
    where #DataMapRes.DataInstanceNumber = dm.DataInstanceNumber
    select @SelectKeyColString = ''
     
	select @KeyFieldCounter = 0
    while (@KeyFieldCounter < @KeyFieldCount)
    begin
        set rowcount 1
        select @KeyFieldName = KeyFieldName
        from
        CDB..KeyDataConfig
        where 
        DataMapID = @DataMapID and
        KeyFieldNumber = @KeyFieldCounter + 1
        set rowcount 0
        select @SelectKeyColString = @SelectKeyColString + ',KeyValue' + convert(varchar,@KeyFieldCounter + 1)  + ' ' + '''' + + 'Key-' + @KeyFieldName + ''''
        select @KeyFieldCounter = @KeyFieldCounter + 1
    end
    
    select @SelectListColString = ''
    select @ListFieldCounter = 0
    while (@ListFieldCounter < @ListFieldCount)
    begin
        set rowcount 1
        select @ListFieldName = ListFieldName
        from
        CDB..ListDataConfig
        where 
        DataMapID = @DataMapID and
        ListFieldNumber = @ListFieldCounter + 1
        set rowcount 0
        select @SelectListColString = @SelectListColString  + ',ListValue' + convert(varchar,@ListFieldCounter + 1)  + ' ' + '''' + 'Value-'+ @ListFieldName + ''''
        select @ListFieldCounter = @ListFieldCounter + 1
    end
    
	if (@Status = 'Active')  
	begin
		select @SelectSql = 'select distinct  DataMapSequenceNumber,UserOperationType,Checker,CheckerOperationTimestamp'
	end   
	else
	begin
		select @SelectSql = 'select distinct DataMapSequenceNumber,UserOperationType,Maker,MakerOperationTimestamp'
	end
    
	
    select @SelectSql = @SelectSql + @SelectKeyColString + @SelectListColString + ' from #DataMapRes'
    
    exec (@SelectSql)

/
EXEC sp_procxmode CPLGetBusinessRuleDataByMode, unchained;
DROP PROCEDURE CPLGetBusinessRuleDataNew;
--/
CREATE PROCEDURE CPLGetBusinessRuleDataNew (@DataMapID varchar(100), @Status varchar(20), @Mode varchar(20), @CurrentUser varchar(100))
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
/*Case 1: SingleElementList*/
    declare 
    @CreateTableSql varchar(1000),
    @UpdateSql varchar(1000),
    @SelectSql varchar(3000),
    @SelectListColString varchar(1000),
    @SelectKeyColString varchar(1000),
    @KeyFieldName varchar(50),
    @ListFieldName varchar(50),
    @KeyFieldCount int,
    @ListFieldCount int,
	@IsKeyColumnVisible varchar(1),
    @KeyFieldCounter int,
    @ListFieldCounter int,
    @SingleElementList varchar(1),
    @KeyFieldValue varchar(255),
    @ListFieldValue varchar(1000),
    @DataInstanceNumber int,
	@ListElementNumber int
	
	
    select
    @KeyFieldCount = KeyFieldCount,
    @ListFieldCount = ListFieldCount,
    @SingleElementList = SingleElementList,
	@IsKeyColumnVisible = IsKeyColumnVisible
    from
    CDB..DataMapConfig
    where
    DataMapID = @DataMapID
	
	
	
	
    create table #DataMapRes
    (
    DataMapSequenceNumber int,
    DataInstanceNumber int,
    UserOperationType varchar(40) null,
    Maker varchar(100) null,
    MakerOperationTimestamp datetime null,
    Checker varchar(100) null,
    CheckerOperationTimestamp datetime null,
    KeyValue1 varchar(255) null,
    KeyValue2 varchar(255) null,
    KeyValue3 varchar(255) null,
    KeyValue4 varchar(255) null,
    KeyValue5 varchar(255) null,
    KeyValue6 varchar(255) null,
    KeyValue7 varchar(255) null,
    KeyValue8 varchar(255) null,
    KeyValue9 varchar(255) null,
    KeyValue10 varchar(255) null,
    KeyValue11 varchar(255) null,
    KeyValue12 varchar(255) null,
    KeyValue13 varchar(255) null,
    KeyValue14 varchar(255) null,
    KeyValue15 varchar(255) null,
    ListValue1 text null,
    ListValue2 text null,
    ListValue3 varchar(255) null,
    ListValue4 varchar(255) null,
    ListValue5 varchar(255) null,
    ListValue6 varchar(255) null,
    ListValue7 varchar(255) null,
    ListValue8 varchar(255) null,
    ListValue9 varchar(255) null,
    ListValue10 varchar(255) null
    )
	
	
   	if (@Status = 'Active')  
	begin
    insert into #DataMapRes
    (
        DataMapSequenceNumber,
        DataInstanceNumber,
        UserOperationType,
        Checker,
        CheckerOperationTimestamp
    )
    select DataMapSequenceNumber,
             DataInstanceNumber,
             UserOperationType,
             Checker,
             CheckerOperationTimestamp
    from
    CDB..DataMapContent a, CDB..UserActivity b
    where
        a.DataMapID = @DataMapID 
        and a.DataMapSequenceNumber = b.ReferenceKey 
        and b.IsLastAuditEntry = 'Y' 
        and DataMapInstanceStatus = 'Active'
	end   
    if @Status = 'Inactive'
    begin
        -- Gets DataInstanceNumber and DataMapSequenceNumber
        insert into #DataMapRes
        (
            DataMapSequenceNumber,
            DataInstanceNumber,
            UserOperationType,
            Maker,
            MakerOperationTimestamp
        )
    
    
        select
            DataMapSequenceNumber,
            DataInstanceNumber,
            UserOperationType,
            Maker,
            MakerOperationTimestamp
        from
        CDB..DataMapContent a, CDB..UserActivity b
        where
        a.DataMapID = @DataMapID and
        a.DataMapSequenceNumber = b.ReferenceKey and
        b.IsLastAuditEntry = 'Y' and 
        (
            DataMapInstanceStatus = 'Inactive' and 
                    (@Mode = 'Edit'
                 or (@Mode = 'Review' and Maker <> @CurrentUser))
        ) 
    end
    create table #DataMap
    (
        DataInstanceNumber int,
        ListValue1 text null,
        ListValue2 text null,
        ListValue3 varchar(255) null,
        ListValue4 varchar(255) null,
        ListValue5 varchar(255) null,
        ListValue6 varchar(255) null,
        ListValue7 varchar(255) null,
        ListValue8 varchar(255) null,
        ListValue9 varchar(255) null,
        ListValue10 varchar(255) null
    )
    
    
    
    if @SingleElementList = 'Y' 
    BEGIN
    
        insert into #DataMap(
            DataInstanceNumber,
            ListValue1,
            ListValue2,
            ListValue3,
            ListValue4,
            ListValue5,
            ListValue6,
            ListValue7,
            ListValue8,
            ListValue9,
            ListValue10)
        select 
            ldc.DataInstanceNumber,
            max(case when ldc.ListFieldNumber = 1 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 2 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 3 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 4 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 5 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 6 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 7 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 8 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 9 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 10 then ListFieldValue end)
        from CDB..ListDataContent ldc
        where ldc.DataMapID = @DataMapID
        group by ldc.DataMapID, ldc.DataInstanceNumber   
    END
    
    select @KeyFieldCounter = 0
    while (@KeyFieldCounter < @KeyFieldCount)
    begin 
        select @UpdateSql = 'update #DataMapRes set KeyValue' + convert(varchar,@KeyFieldCounter+1) + ' =  kdc.KeyFieldValue from CDB..KeyDataContent kdc where kdc.DataMapID = @DataMapID and kdc.DataInstanceNumber = #DataMapRes.DataInstanceNumber and kdc.KeyFieldNumber = ' + convert(varchar,@KeyFieldCounter+1)
        exec (@UpdateSql)
        
        select @KeyFieldCounter = @KeyFieldCounter + 1
    end
    
    if @SingleElementList = 'N' 
    BEGIN 
        declare @maxFieldElemntNumber int
        declare @maxDataInstanceNumber int
        declare @ListElementCounter int
        declare @DataInstanceNumberCounter int
        declare @FValue varchar(16300)
        declare @FValue1 varchar(16300)
        declare @FValue2 varchar(16300)
        declare @FValueCounter int
        declare @FEValue varchar(255)
        declare @sqlDataMapInsert varchar(16384)
        declare @sqlInsertHeader varchar(16384)
        declare @sqlUpdateHeader varchar(500)
        declare @sqlUpdateFooter varchar(500)
        
        select @maxFieldElemntNumber = max(ListElementNumber) 
        from CDB..ListDataContent 
        where DataMapID = @DataMapID
        
        
        select @maxDataInstanceNumber = max(DataInstanceNumber) 
        from CDB..ListDataContent 
        where DataMapID = @DataMapID
        select @sqlInsertHeader = 'INSERT INTO #DataMap(DataInstanceNumber'
        select @sqlUpdateHeader = 'UPDATE #DataMap SET' 
       
        select @ListFieldCounter = 1
        while (@ListFieldCounter <= @ListFieldCount)
        begin            
            select @sqlInsertHeader = @sqlInsertHeader + ',ListValue' + convert(varchar, @ListFieldCounter) 
            select @sqlUpdateHeader = @sqlUpdateHeader + ' ListValue' + convert(varchar, @ListFieldCounter)   + ' = '  
            select @ListFieldCounter = @ListFieldCounter + 1
        end
        
        select @sqlInsertHeader = @sqlInsertHeader + ') VALUES('
    
        select @DataInstanceNumberCounter = 1
        while @DataInstanceNumberCounter <= @maxDataInstanceNumber
        begin
         
            select @sqlDataMapInsert = @sqlInsertHeader + convert(varchar, @DataInstanceNumberCounter) 
            select @sqlUpdateFooter = ' where DataInstanceNumber = ' + convert(varchar, @DataInstanceNumberCounter)
            
            select @ListFieldCounter = 1
            while (@ListFieldCounter <= @ListFieldCount)
            begin
                select @FValue = null
                select @FValue1 = null
                select @FValue2 = null
                select @ListElementCounter = 1 
                while (@ListElementCounter <= @maxFieldElemntNumber)
                begin        
                    select @FEValue = null
                    select @FEValue = ListFieldValue 
                    from CDB..ListDataContent
                    where DataMapID = @DataMapID
                        and DataInstanceNumber = @DataInstanceNumberCounter                        
                        and ListFieldNumber = @ListFieldCounter
                        and ListElementNumber = @ListElementCounter                
                    --Modified by Raja on 01-Nov-2011, since all the list values are not displayed for Multiple List Rules(i.e SingleElementList ='N')
                    --select @FValue = COALESCE('', @FValue + '|') + @FEValue
    		     if (@ListElementCounter <= 1500)
                            select @FValueCounter = 0
                        else if (@ListElementCounter > 1500 and @ListElementCounter <=3000 )
                            select @FValueCounter = 1
			else
			select @FValueCounter = 2	
                     if (@FValueCounter = 0)
                        begin
                            if(@FEValue!=null and @FValue is null)
                                select @FValue =@FEValue
                            else if (@FEValue!=null)
                                select @FValue = @FValue + '|' +@FEValue
                        end
                      else if (@FValueCounter = 1)
                        begin
                            if(@FEValue!=null and @FValue1 is null)
                                select @FValue1 = '|' +  @FEValue
                            else if (@FEValue!=null)
                                select @FValue1 = @FValue1 + '|' +@FEValue
                        end
                      else if (@FValueCounter = 2)
                        begin
                            if(@FEValue!=null and @FValue2 is null)
                                select @FValue2 = '|' +  @FEValue
                            else if (@FEValue!=null)
                                select @FValue2 = @FValue2 + '|' +@FEValue
                        end
                    select @ListElementCounter = @ListElementCounter + 1
                   
                end     
                          
                select @sqlDataMapInsert = @sqlDataMapInsert + ',''' + @FValue + ''''               
                
                select @ListFieldCounter = @ListFieldCounter + 1
            end
            
                select @sqlDataMapInsert = @sqlDataMapInsert + ')'
                
                exec (@sqlDataMapInsert)
                if (@FValueCounter = 1)
                    begin
                     exec(@sqlUpdateHeader +  '''' + @FValue + @FValue1 + '''' + @sqlUpdateFooter)
                    end
                
                else if (@FValueCounter = 2)
                    begin
                     exec(@sqlUpdateHeader +  '''' + @FValue + @FValue1 + @FValue2 + '''' +  @sqlUpdateFooter)
                    end
            
            select @DataInstanceNumberCounter = @DataInstanceNumberCounter + 1
        end
    
    end
    update #DataMapRes 
    set  
        ListValue1 = dm.ListValue1,
        ListValue2 = dm.ListValue2,
        ListValue3 = dm.ListValue3,
        ListValue4 = dm.ListValue4,
        ListValue5 = dm.ListValue5,
        ListValue6 = dm.ListValue6,
        ListValue7 = dm.ListValue7,
        ListValue8 = dm.ListValue8,
        ListValue9 = dm.ListValue9,
        ListValue10 = dm.ListValue10
    from #DataMap dm
    where #DataMapRes.DataInstanceNumber = dm.DataInstanceNumber
    select @SelectKeyColString = ''
     
	select @KeyFieldCounter = 0
    while (@KeyFieldCounter < @KeyFieldCount)
    begin
        set rowcount 1
        select @KeyFieldName = KeyFieldName
        from
        CDB..KeyDataConfig
        where 
        DataMapID = @DataMapID and
        KeyFieldNumber = @KeyFieldCounter + 1
        set rowcount 0
        select @SelectKeyColString = @SelectKeyColString + ',KeyValue' + convert(varchar,@KeyFieldCounter + 1)  + ' ' + '''' + + 'Key-' + @KeyFieldName + ''''
        select @KeyFieldCounter = @KeyFieldCounter + 1
    end
    
    select @SelectListColString = ''
    select @ListFieldCounter = 0
    while (@ListFieldCounter < @ListFieldCount)
    begin
        set rowcount 1
        select @ListFieldName = ListFieldName
        from
        CDB..ListDataConfig
        where 
        DataMapID = @DataMapID and
        ListFieldNumber = @ListFieldCounter + 1
        set rowcount 0
        select @SelectListColString = @SelectListColString  + ',ListValue' + convert(varchar,@ListFieldCounter + 1)  + ' ' + '''' + 'Value-'+ @ListFieldName + ''''
        select @ListFieldCounter = @ListFieldCounter + 1
    end
    
	if (@Status = 'Active')  
	begin
		select @SelectSql = 'select DataMapSequenceNumber,UserOperationType,Checker,CheckerOperationTimestamp'
	end   
	else
	begin
		select @SelectSql = 'select DataMapSequenceNumber,UserOperationType,Maker,MakerOperationTimestamp'
	end
    
	
    select @SelectSql = @SelectSql + @SelectKeyColString + @SelectListColString + ' from #DataMapRes'
    
    exec (@SelectSql)

/
EXEC sp_procxmode CPLGetBusinessRuleDataNew, unchained;
DROP PROCEDURE CPLGetDataMapConfig;
--/
CREATE PROCEDURE CPLGetDataMapConfig @DataMapID varchar(100)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
if(@DataMapID = null or @DataMapID = '')
begin
    select DataMapConfig.DataMapID,DataMapConfig.DataMapID,DataMapConfig.DataMapDescription, DataMapConfig.KeyFieldCount, DataMapConfig.ListFieldCount, DataMapConfig.SingleElementList, DataMapConfig.LastModifiedBy, DataMapConfig.LastModifiedOn from DataMapConfig
end
else
begin
    select DataMapConfig.DataMapID,DataMapConfig.DataMapID,DataMapConfig.DataMapDescription, DataMapConfig.KeyFieldCount, DataMapConfig.ListFieldCount, DataMapConfig.SingleElementList, DataMapConfig.LastModifiedBy, DataMapConfig.LastModifiedOn 
    from DataMapConfig
    where
    DataMapID = @DataMapID
end

/
EXEC sp_procxmode CPLGetDataMapConfig, unchained;
DROP PROCEDURE CPLGetDataMapContent;
--/
CREATE PROCEDURE CPLGetDataMapContent @DataMapID varchar(100)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
if(@DataMapID = null or @DataMapID = '')
begin
    select DataMapID, DataInstanceNumber, MaxDataInstanceNumber = max(DataInstanceNumber)
    from CDB..DataMapContent
    group by DataMapID having DataMapInstanceStatus = 'Active'
end
else
begin
    select DataMapID, DataInstanceNumber, MaxDataInstanceNumber = max(DataInstanceNumber)
    from CDB..DataMapContent
    group by DataMapID having DataMapInstanceStatus = 'Active' and DataMapID = @DataMapID
end

/
EXEC sp_procxmode CPLGetDataMapContent, unchained;
DROP PROCEDURE CPLGetDataMapValue;
--/
CREATE PROCEDURE CPLGetDataMapValue (@DataMapID varchar(200), @KeyValue varchar(200), @ListFieldNumber int, @ListFieldValue varchar(200) output)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
select
@ListFieldValue = ListFieldValue
from
CDB..KeyDataContent k, CDB..ListDataContent l, CDB..DataMapContent d
where
k.DataMapID = l.DataMapID and
k.DataMapID = d.DataMapID and
k.DataInstanceNumber = d.DataInstanceNumber and
l.DataInstanceNumber = d.DataInstanceNumber and
k.DataMapID = @DataMapID and
l.ListFieldNumber = @ListFieldNumber and
k.KeyFieldValue = @KeyValue and
k.KeyFieldNumber = 1

/
EXEC sp_procxmode CPLGetDataMapValue, unchained;
DROP PROCEDURE CPLGetKeyDataConfig;
--/
CREATE PROCEDURE CPLGetKeyDataConfig @DataMapID varchar(100)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
if(@DataMapID = null or @DataMapID = '')
begin
	select KeyDataConfig.DataMapID, KeyDataConfig.KeyFieldNumber, KeyDataConfig.KeyFieldName from KeyDataConfig
end
else
begin
	select KeyDataConfig.DataMapID, KeyDataConfig.KeyFieldNumber, KeyDataConfig.KeyFieldName from KeyDataConfig where DataMapID = @DataMapID
end	

/
EXEC sp_procxmode CPLGetKeyDataConfig, unchained;
DROP PROCEDURE CPLGetKeyDataContent;
--/
CREATE PROCEDURE CPLGetKeyDataContent @DataMapID varchar(100)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
if(@DataMapID = null or @DataMapID = '')
begin
	select k.DataMapID, k.DataInstanceNumber, KeyFieldNumber, KeyFieldValue 
	from CDB..KeyDataContent k, CDB..DataMapContent d
	where 
	k.DataMapID = d.DataMapID and
	k.DataInstanceNumber = d.DataInstanceNumber and
	d.DataMapInstanceStatus = 'Active'
end
else
begin
	select k.DataMapID, k.DataInstanceNumber, KeyFieldNumber, KeyFieldValue 
	from CDB..KeyDataContent k, CDB..DataMapContent d
	where 
	k.DataMapID = d.DataMapID and
	k.DataInstanceNumber = d.DataInstanceNumber and
	d.DataMapInstanceStatus = 'Active' and k.DataMapID = @DataMapID
end

/
EXEC sp_procxmode CPLGetKeyDataContent, unchained;
DROP PROCEDURE CPLGetListDataConfig;
--/
CREATE PROCEDURE CPLGetListDataConfig @DataMapID varchar(100)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
if(@DataMapID = null or @DataMapID = '')
begin
	select ListDataConfig.DataMapID, ListDataConfig.ListFieldNumber, ListDataConfig.ListFieldName from ListDataConfig
end
else
begin
	select ListDataConfig.DataMapID, ListDataConfig.ListFieldNumber, ListDataConfig.ListFieldName from ListDataConfig where DataMapID = @DataMapID
end	

/
EXEC sp_procxmode CPLGetListDataConfig, unchained;
DROP PROCEDURE CPLGetListDataContent;
--/
CREATE PROCEDURE CPLGetListDataContent @DataMapID varchar(100)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
if(@DataMapID = null or @DataMapID = '')
begin
	select l.DataMapID, l.DataInstanceNumber, l.ListElementNumber, l.ListFieldNumber, l.ListFieldValue ,
	MaxListElementNumber = Max(ListElementNumber) 
	from CDB..ListDataContent l, CDB..DataMapContent d where
	l.DataMapID = d.DataMapID and
	l.DataInstanceNumber = d.DataInstanceNumber and
	d.DataMapInstanceStatus = 'Active'
	group by l.DataMapID, l.DataInstanceNumber
end
else
begin
	select l.DataMapID, l.DataInstanceNumber, l.ListElementNumber, l.ListFieldNumber, l.ListFieldValue ,
	MaxListElementNumber = Max(ListElementNumber) 
	from CDB..ListDataContent l, CDB..DataMapContent d where
	l.DataMapID = d.DataMapID and
	l.DataInstanceNumber = d.DataInstanceNumber and
	d.DataMapInstanceStatus = 'Active' and l.DataMapID = @DataMapID 
	group by l.DataMapID, l.DataInstanceNumber
end	

/
EXEC sp_procxmode CPLGetListDataContent, unchained;
DROP PROCEDURE CPLGetMaxDataInstanceNumbers;
--/
CREATE PROCEDURE CPLGetMaxDataInstanceNumbers @DataMapID varchar(100)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
if(@DataMapID = null or @DataMapID = '')
begin
	select DataMapID, max(DataInstanceNumber) from CDB..DataMapContent where DataMapInstanceStatus = 'Active' group by DataMapID
end
else
begin
	select DataMapID, max(DataInstanceNumber) from CDB..DataMapContent where DataMapInstanceStatus = 'Active' and DataMapID = @DataMapID group by DataMapID
end
	

/
EXEC sp_procxmode CPLGetMaxDataInstanceNumbers, unchained;
DROP PROCEDURE CPLGetRuleDataByMode;
--/
CREATE PROCEDURE CPLGetRuleDataByMode (@DataMapID varchar(100), @Status varchar(20), @Mode varchar(20), @CurrentUser varchar(100))
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
/*Case 1: SingleElementList*/
    declare 
    @CreateTableSql varchar(1000),
    @UpdateSql varchar(1000),
    @SelectSql varchar(3000),
    @SelectListColString varchar(1000),
    @SelectKeyColString varchar(1000),
    @KeyFieldName varchar(50),
    @ListFieldName varchar(50),
    @KeyFieldCount int,
    @ListFieldCount int,
    @KeyFieldCounter int,
    @ListFieldCounter int,
    @SingleElementList varchar(1),
    @KeyFieldValue varchar(255),
    @ListFieldValue varchar(255),
    @DataInstanceNumber int
    select
    @KeyFieldCount = KeyFieldCount,
    @ListFieldCount = ListFieldCount,
    @SingleElementList = SingleElementList
    from
    CDB..DataMapConfig
    where
    DataMapID = @DataMapID
    create table #DataMapRes
    (
    DataMapSequenceNumber int,
    DataInstanceNumber int,
    UserOperationType varchar(40) null,
    Maker varchar(100) null,
    MakerOperationTimestamp datetime null,
    KeyValue1 varchar(255) null,
    KeyValue2 varchar(255) null,
    KeyValue3 varchar(255) null,
    KeyValue4 varchar(255) null,
    KeyValue5 varchar(255) null,
    KeyValue6 varchar(255) null,
    KeyValue7 varchar(255) null,
    KeyValue8 varchar(255) null,
    KeyValue9 varchar(255) null,
    KeyValue10 varchar(255) null,
    KeyValue11 varchar(255) null,
    KeyValue12 varchar(255) null,
    KeyValue13 varchar(255) null,
    ListValue1 varchar(255) null,
    ListValue2 varchar(255) null,
    ListValue3 varchar(255) null,
    ListValue4 varchar(255) null,
    ListValue5 varchar(255) null,
    ListValue6 varchar(255) null,
    ListValue7 varchar(255) null,
    ListValue8 varchar(255) null,
    ListValue9 varchar(255) null,
    ListValue10 varchar(255) null
    )
	
	
   	if (@Status = 'Active')  
	begin
        insert into #DataMapRes
        (
            DataMapSequenceNumber,
            DataInstanceNumber,
            UserOperationType
        )
        select
            DataMapSequenceNumber,
            DataInstanceNumber,
            UserOperationType
        from
        CDB..DataMapContent a, CDB..UserActivity b
        where
            a.DataMapID = @DataMapID 
            and a.DataMapSequenceNumber = b.ReferenceKey 
            and b.IsLastAuditEntry = 'Y' 
            and DataMapInstanceStatus = 'Active'
	end   
    if @Status = 'Inactive'
    begin
        -- Gets DataInstanceNumber and DataMapSequenceNumber
        insert into #DataMapRes
        (
            DataMapSequenceNumber,
            DataInstanceNumber,
            UserOperationType,
            Maker,
            MakerOperationTimestamp
        )
    
        select
            DataMapSequenceNumber,
            DataInstanceNumber,
            UserOperationType,
            Maker,
            MakerOperationTimestamp
        from
        CDB..DataMapContent a, CDB..UserActivity b
        where
        a.DataMapID = @DataMapID and
        a.DataMapSequenceNumber = b.ReferenceKey and
        b.IsLastAuditEntry = 'Y' and 
        (
            DataMapInstanceStatus = 'Inactive' and 
                    (@Mode = 'Edit'
                 or (@Mode = 'Review' and Maker <> @CurrentUser))
        ) 
    end
 
    select @SelectKeyColString = ''
     
	select @KeyFieldCounter = 1
    while (@KeyFieldCounter <= @KeyFieldCount)
    begin
        set rowcount 1
        select @KeyFieldName = KeyFieldName
        from   CDB..KeyDataConfig
        where  DataMapID = @DataMapID 
               and KeyFieldNumber = @KeyFieldCounter
        set rowcount 0
        
        select @SelectKeyColString = @SelectKeyColString + ',KeyValue' + convert(varchar,@KeyFieldCounter)  + ' ' + '''' + + 'Key-' + @KeyFieldName + '''' 
        
        select @UpdateSql = 'update #DataMapRes set KeyValue' + convert(varchar,@KeyFieldCounter) + ' =  kdc.KeyFieldValue from CDB..KeyDataContent kdc where kdc.DataMapID = @DataMapID and kdc.DataInstanceNumber = #DataMapRes.DataInstanceNumber and kdc.KeyFieldNumber = ' + convert(varchar,@KeyFieldCounter)
        
        exec (@UpdateSql)       
        
        select @KeyFieldCounter = @KeyFieldCounter + 1
    end
    
    
    
    
    select @SelectListColString = ''
    select @ListFieldCounter = 1
    while (@ListFieldCounter <= @ListFieldCount)
    begin
        set rowcount 1
        select @ListFieldName = ListFieldName
        from   CDB..ListDataConfig
        where  DataMapID = @DataMapID 
               and ListFieldNumber = @ListFieldCounter
        set rowcount 0
        
        select @SelectListColString = @SelectListColString  + ',ListValue' + convert(varchar,@ListFieldCounter)  + ' ' + '''' + 'Value-'+ @ListFieldName + '''' 
        
        select @ListFieldCounter = @ListFieldCounter + 1
    end
    create table #DataMap
    (
        DataInstanceNumber int,
        ListValue1 varchar(255) null,
        ListValue2 varchar(255) null,
        ListValue3 varchar(255) null,
        ListValue4 varchar(255) null,
        ListValue5 varchar(255) null,
        ListValue6 varchar(255) null,
        ListValue7 varchar(255) null,
        ListValue8 varchar(255) null,
        ListValue9 varchar(255) null,
        ListValue10 varchar(255) null
    )
    
    
    
    insert into #DataMap(
        DataInstanceNumber,
        ListValue1,
        ListValue2,
        ListValue3,
        ListValue4,
        ListValue5,
        ListValue6,
        ListValue7,
        ListValue8,
        ListValue9,
        ListValue10)
    select 
        ldc.DataInstanceNumber,
        max(case when ldc.ListFieldNumber = 1 then ListFieldValue end),
        max(case when ldc.ListFieldNumber = 2 then ListFieldValue end),
        max(case when ldc.ListFieldNumber = 3 then ListFieldValue end),
        max(case when ldc.ListFieldNumber = 4 then ListFieldValue end),
        max(case when ldc.ListFieldNumber = 5 then ListFieldValue end),
        max(case when ldc.ListFieldNumber = 6 then ListFieldValue end),
        max(case when ldc.ListFieldNumber = 7 then ListFieldValue end),
        max(case when ldc.ListFieldNumber = 8 then ListFieldValue end),
        max(case when ldc.ListFieldNumber = 9 then ListFieldValue end),
        max(case when ldc.ListFieldNumber = 10 then ListFieldValue end)
    from CDB..ListDataContent ldc
    where ldc.DataMapID = @DataMapID
    group by ldc.DataMapID, ldc.DataInstanceNumber   
    update #DataMapRes 
    set  
        ListValue1 = dm.ListValue1,
        ListValue2 = dm.ListValue2,
        ListValue3 = dm.ListValue3,
        ListValue4 = dm.ListValue4,
        ListValue5 = dm.ListValue5,
        ListValue6 = dm.ListValue6,
        ListValue7 = dm.ListValue7,
        ListValue8 = dm.ListValue8,
        ListValue9 = dm.ListValue9,
        ListValue10 = dm.ListValue10
    from #DataMap dm
    where #DataMapRes.DataInstanceNumber = dm.DataInstanceNumber
    
    if (@Status = 'Active')
    begin
        select @SelectSql = 'select distinct DataMapSequenceNumber,UserOperationType'
    end
    else
    begin
        select @SelectSql = 'select distinct DataMapSequenceNumber,UserOperationType,Maker,MakerOperationTimestamp'
    end
    
    select @SelectSql = @SelectSql + @SelectKeyColString + @SelectListColString + ' from #DataMapRes'
    
    exec (@SelectSql)
 


/
EXEC sp_procxmode CPLGetRuleDataByMode, unchained;
DROP PROCEDURE CSATypes;
--/
CREATE PROCEDURE CSATypes
as
SELECT 'CodeType', 'CSATypes', 'Description', NULL, NULL, NULL
SELECT 'CSATypes', ExternalCode, Code, Description, NULL, NULL FROM CDB..Code where Type = 'CSA_TYPE_DESC' order by convert ( int , Code) asc

/
EXEC sp_procxmode CSATypes, unchained;
DROP PROCEDURE CSA_TYPE_DESC;
--/
CREATE PROCEDURE CSA_TYPE_DESC
as
SELECT 'CodeType', 'CSATypes', NULL, NULL, NULL, NULL
SELECT 'CSATypes', ExternalCode, Code, NULL, NULL, NULL FROM CDB..Code where Type = 'CSA_TYPE_DESC' order by convert ( int , Code) asc

/
EXEC sp_procxmode CSA_TYPE_DESC, unchained;
DROP PROCEDURE CWSUsers;
--/
CREATE PROCEDURE CWSUsers
as 
 set compatibility_mode off 
declare @version varchar(255)
select @version = "%W% %G%"
select "CodeType", "CWSUsers", NULL, NULL, NULL, NULL
select distinct "CWSUsers", G.TeamMember, NULL, NULL, NULL, NULL
from CDB..TeamMemberGroupLink G, CDB..TeamMember T
where G.TeamMember = T.TeamMember and
G.TeamMemberGroup in ('CWS-Management-grp', 'CWS-DocGenerator-grp', 
'CWS-DocMatcher-grp', 'CWS-DocReviewer-grp')
order by G.TeamMember


/
EXEC sp_procxmode CWSUsers, unchained;
DROP PROCEDURE Calendar;
--/
CREATE PROCEDURE Calendar
/**********************************************************************
**Procedure : Calendars
** Notes     :
**********************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version  varchar(255)
select @version = "%W% %G%"
Select EnumerationValue,ShortName from CDB..Enumeration
where EnumerationName = 'CalendarType'


/
EXEC sp_procxmode Calendar, unchained;
DROP PROCEDURE CalendarData;
--/
CREATE PROCEDURE CalendarData
/**********************************************************************************
** Procedure : CalendarData
**
** Version   : %W% %G%
**		
** Notes     : This proc produces Calendar and Holiday information.
**             This proc being used for Eculipso group.
**
**********************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare	@Version varchar(255)
select	@Version = "%W% %G%"
select convert(varchar(25),hd.CalendarName) + '|' +
convert(varchar(9),h.Holiday) + '|' +
convert(varchar(62),h.HolidayName) + '|' +
""
from Holiday h, HolidayDefinition hd
where h.Calendar = hd.Calendar
order by convert(varchar(25),hd.CalendarName),convert(varchar(9),h.Holiday)


/
EXEC sp_procxmode CalendarData, unchained;
DROP PROCEDURE CalendarHolidays;
--/
CREATE PROCEDURE CalendarHolidays
/**********************************************************************
** Procedure : CalendarHolidays
** Notes     :
**********************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version  varchar(255)
select @version = "%W% %G%"
select Calendar, Holiday from CDB..Holiday 


/
EXEC sp_procxmode CalendarHolidays, unchained;
DROP PROCEDURE Calendars;
--/
CREATE PROCEDURE Calendars
/**********************************************************************************
**
**
** Procedure : Calendars
**
** Version   :    @(#)Calendars.proc	63.1 08/06/01
**
** Notes     :
**
**********************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select @version = "@(#)Calendars.proc	63.1 08/06/01"
select "CodeType", "Calendars", NULL, NULL, NULL, NULL
select distinct "Calendars", convert(varchar(255),Calendar), NULL, NULL, NULL, NULL
from Holiday
order by Calendar


/
EXEC sp_procxmode Calendars, unchained;
DROP PROCEDURE CcyCollTypeMappingAsCode;
--/
CREATE PROCEDURE CcyCollTypeMappingAsCode
/**********************************************************************************
**
**
** Procedure : CcyCollTypeMappingAsCode
**
** Version   :
**
** Notes     :
**
**********************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
select "CodeType", "CcyCollTypeMapping", NULL, NULL, NULL, NULL
select "CcyCollTypeMapping", c.ExternalCode, convert(varchar(10),a.CollateralTypeID), NULL, NULL, NULL
from MSADB..CollateralTypeCurrency a, MSADB..CollateralDefinition b, CDB..Code c
where a.CollateralTypeID = b.CollateralTypeID and b.TypeOfCollateral='CASH' and  c.Type='Currency' and a.CurrencyCode = c.Code


/
EXEC sp_procxmode CcyCollTypeMappingAsCode, unchained;
DROP PROCEDURE CetipCodeByLegalEntity;
--/
CREATE PROCEDURE CetipCodeByLegalEntity(
/**************************************************************
**
** Procedure:  CetipCodeByLegalEntity
**
** Version:    @(#)CetipCodeByLegalEntity.sp	119.1
**
** Notes:
**
*************************************************************/
        @LegalEntity    varchar(255)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
        declare         @version        varchar(255)
        select @version = " @(#)CetipCodeByLegalEntity.sp	119.1 10/23/05"
        select "CodeType","REGISTRATIONFEED",NULL,NULL,NULL,NULL
        from ADB..LegalEntity 
        where LegalEntityShortName = @LegalEntity
		and CETIPRootCode != NULL 
        select "REGISTRATIONFEED",convert(varchar(4),CETIPRootCode),convert(varchar(1),CETIPNatureCode), convert(varchar(14),LegalVehicleLegalID),NULL,NULL
        from ADB..LegalEntity 
        where LegalEntityShortName = @LegalEntity
		and CETIPRootCode != NULL 
		and CETIPNatureCode != Null
                and LegalVehicleLegalID != Null
STORED_PROC_EXIT:


/
EXEC sp_procxmode CetipCodeByLegalEntity, unchained;
DROP PROCEDURE CitiFirmLegalEntities;
--/
CREATE PROCEDURE CitiFirmLegalEntities
/**********************************************************************************
**
**
** Procedure : CitiFirmLegalEntities
**
** Version   :    @(#)CitiFirmLegalEntities.proc	63.1 08/06/01
**
** Notes     :
**
**********************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select @version = "@(#)CitiFirmLegalEntities.proc	63.1 08/06/01"
select "CodeType", "CitiFirmLegalEntity", NULL, NULL, NULL, NULL
select distinct "CitiFirmLegalEntity", Code, NULL, NULL, NULL, NULL
from Code
where Type = "FirmLegalEntity"
and Description = "Citibank"
order by Code


/
EXEC sp_procxmode CitiFirmLegalEntities, unchained;
DROP PROCEDURE ClassificationCodeDelete;
--/
CREATE PROCEDURE ClassificationCodeDelete (
/**************************************************************************
**
** Procedure:	ClassificationCodeDelete
**
** Version: 	@(#)ClassificationCodeDelete.proc	63.1 08/06/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Class       varchar(40)  ,
	@SchemaName  varchar(40)  ,
	@Code        varchar(255)       
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from ClassificationCode 
where Class = @Class
and    SchemaName = @SchemaName
and    Code = @Code
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from ClassificationCode table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from ClassificationCode table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Class '" + convert(varchar(255), @Class) + "'"
	select @ErrorMessage = @ErrorMessage + ","
	select @ErrorMessage = @ErrorMessage + "SchemaName '" + convert(varchar(255), @SchemaName) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "Code '" + convert(varchar(255), @Code) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode ClassificationCodeDelete, unchained;
DROP PROCEDURE ClassificationCodeInsert;
--/
CREATE PROCEDURE ClassificationCodeInsert (
/**************************************************************************
**
** Procedure:	ClassificationCodeInsert
**
** Version: 	@(#)ClassificationCodeInsert.proc	63.1 08/06/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Class       varchar(40)  ,
	@SchemaName  varchar(40)  ,
	@Code        varchar(255)       ,
	@LongName    varchar(255)        = NULL,
	@Description varchar(255) = NULL
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into ClassificationCode (
	Class,
	SchemaName,
	Code,
	LongName,
	Description )
values (
	@Class,
	@SchemaName,
	@Code,
	@LongName,
	@Description )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into ClassificationCode table for key(s) "
	select @ErrorMessage = @ErrorMessage + "Class '" + convert(varchar(255), @Class) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "SchemaName '" + convert(varchar(255), @SchemaName) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "Code '" + convert(varchar(255), @Code) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode ClassificationCodeInsert, unchained;
DROP PROCEDURE ClassificationCodeUpdate;
--/
CREATE PROCEDURE ClassificationCodeUpdate (
/**************************************************************************
**
** Procedure:	ClassificationCodeUpdate
**
** Version: 	@(#)ClassificationCodeUpdate.proc	63.1 08/06/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Class       varchar(40)  ,
	@SchemaName  varchar(40)  ,
	@Code        varchar(255)       ,
	@LongName    varchar(255)        = "#$%@",
	@Description varchar(255) = "#$%@"
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @longName    varchar(255)       ,
        @description varchar(255)
Select @longName = LongName,
       @description = Description
from ClassificationCode
  where Class = @Class
  and SchemaName = @SchemaName
  and Code = @Code
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from ClassificationCode table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from ClassificationCode table for key(s) "
	goto ERROR_EXIT
end
if @LongName != "#$%@"
	select @longName = @LongName
if @Description != "#$%@"
	select @description = @Description
Update ClassificationCode
set	LongName = @longName,
	Description = @description
  where Class = @Class
  and SchemaName = @SchemaName
  and Code = @Code
if @@error != 0
begin
	select @ErrorMessage = "Could not update ClassificationCode table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Class '" + convert(varchar(255), @Class) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "SchemaName '" + convert(varchar(255), @SchemaName) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "Code '" + convert(varchar(255), @Code) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode ClassificationCodeUpdate, unchained;
DROP PROCEDURE ClassificationSchemaByClass;
--/
CREATE PROCEDURE ClassificationSchemaByClass (
/**********************************************************************************
**
**
** Procedure : ClassificationSchemaByClass
**
** Version   :   @(#)ClassificationSchemaByClass.proc	63.1 08/06/01
**
** Notes     :
**
**********************************************************************************/
	@Class		varchar(255)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
	declare    @version   varchar(255)
        select     @version = "@(#)ClassificationSchemaByClass.proc	63.1 08/06/01"
select "CodeType", @Class, NULL, NULL, NULL, NULL
select Class, SchemaName, NULL, NULL, Description, NULL
from ClassificationSchema where Class=@Class order by Class,SchemaName


/
EXEC sp_procxmode ClassificationSchemaByClass, unchained;
DROP PROCEDURE ClassificationSchemaDelete;
--/
CREATE PROCEDURE ClassificationSchemaDelete (
/**************************************************************************
**
** Procedure:	ClassificationSchemaDelete
**
** Version: 	@(#)ClassificationSchemaDelete.proc	63.1 08/06/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Class                  varchar(40)  ,
	@SchemaName             varchar(40)  
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from ClassificationSchema 
where Class = @Class
and    SchemaName = @SchemaName
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from ClassificationSchema table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from ClassificationSchema table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Class '" + convert(varchar(255), @Class) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "SchemaName '" + convert(varchar(255), @SchemaName) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode ClassificationSchemaDelete, unchained;
DROP PROCEDURE ClassificationSchemaInsert;
--/
CREATE PROCEDURE ClassificationSchemaInsert (
/**************************************************************************
**
** Procedure:	ClassificationSchemaInsert
**
** Version: 	@(#)ClassificationSchemaInsert.proc	63.1 08/06/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Class                  varchar(40)  ,
	@SchemaName             varchar(40)  ,
	@MultipleEntryIndicator int   = NULL,
	@Description            varchar(255) = NULL,
	@CRC                    int         = NULL
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into ClassificationSchema (
	Class,
	SchemaName,
	MultipleEntryIndicator,
	Description,
	CRC )
values (
	@Class,
	@SchemaName,
	@MultipleEntryIndicator,
	@Description,
	@CRC )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into ClassificationSchema table for key(s) "
	select @ErrorMessage = @ErrorMessage + "Class '" + convert(varchar(255), @Class) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "SchemaName '" + convert(varchar(255), @SchemaName) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode ClassificationSchemaInsert, unchained;
DROP PROCEDURE ClassificationSchemaUpdate;
--/
CREATE PROCEDURE ClassificationSchemaUpdate (
/**************************************************************************
**
** Procedure:	ClassificationSchemaUpdate
**
** Version: 	@(#)ClassificationSchemaUpdate.proc	63.1 08/06/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Class                  varchar(40)  ,
	@SchemaName             varchar(40)  ,
	@MultipleEntryIndicator int   = -2147483647,
	@Description            varchar(255) = "#$%@",
	@CRC                    int         = -2147483647
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @multipleEntryIndicator int  ,
        @description            varchar(255),
        @crc                    int        
Select @multipleEntryIndicator = MultipleEntryIndicator,
       @description = Description,
       @crc = CRC
from ClassificationSchema
  where Class = @Class
  and SchemaName = @SchemaName
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from ClassificationSchema table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from ClassificationSchema table for key(s) "
	goto ERROR_EXIT
end
if @MultipleEntryIndicator != -2147483647
	select @multipleEntryIndicator = @MultipleEntryIndicator
if @Description != "#$%@"
	select @description = @Description
if @CRC != -2147483647
	select @crc = @CRC
Update ClassificationSchema
set	MultipleEntryIndicator = @multipleEntryIndicator,
	Description = @description,
	CRC = @crc
  where Class = @Class
  and SchemaName = @SchemaName
if @@error != 0
begin
	select @ErrorMessage = "Could not update ClassificationSchema table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Class '" + convert(varchar(255), @Class) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "SchemaName '" + convert(varchar(255), @SchemaName) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode ClassificationSchemaUpdate, unchained;
DROP PROCEDURE CloseTransaction;
--/
CREATE PROCEDURE CloseTransaction
/*M***************************************************************************
**
** Classes: 	CloseTransaction
**
** Version: 	@(#)CloseTransaction.proc	63.1 08/06/01
**
** Notes:
**
*****************************************************************************/
	(
	@Class			varchar(255),
	@ClassKey			varchar(255),
	@TeamMember		varchar(75),
	@Application 		varchar(255),
	@spid			int
	)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
	declare		@Version  varchar(255)
	select @Version = "@(#)CloseTransaction.proc	63.1 08/06/01"
declare	@NumberRows		int,
 	@HostName		varchar(255),
	@ErrorMessage		varchar(255),
	@ReturnCode		int
select @HostName = host_name()
if (not (@Class != NULL)) begin select @ErrorMessage =  "Class is NULL." raiserror 20003 @ErrorMessage goto ERROR_EXIT end
if (not (@ClassKey != NULL)) begin select @ErrorMessage =  "Key is NULL." raiserror 20003 @ErrorMessage goto ERROR_EXIT end
if (not (@Application != NULL and @Application != "")) begin select @ErrorMessage =  	"Application can not be NULL." raiserror 20003 @ErrorMessage goto ERROR_EXIT end
if (not (@TeamMember != NULL)) begin select @ErrorMessage =  "TeamMember can not be NULL." raiserror 20003 @ErrorMessage goto ERROR_EXIT end
if (not (@spid != NULL)) begin select @ErrorMessage =  "spid can not be NULL." raiserror 20003 @ErrorMessage goto ERROR_EXIT end
delete TransactionLog where Class =  @Class and ClassKey =  @ClassKey and TeamMember =  @TeamMember and HostName =  @HostName if @@error != 0 begin raiserror  20002 "TransactionLog delete failed." goto ERROR_EXIT end
ERROR_EXIT:


/
EXEC sp_procxmode CloseTransaction, unchained;
DROP PROCEDURE CodeDelete;
--/
CREATE PROCEDURE CodeDelete (
/**************************************************************************
**
** Procedure:	CodeDelete
**
** Version: 	@(#)CodeDelete.proc	63.1 08/06/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Type         varchar(255)       ,
	@Code         varchar(255)       ,
	@ExternalCode varchar(255)       
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from Code 
where Type = @Type
and    Code = @Code
and    ExternalCode = @ExternalCode
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from Code table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from Code table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Type '" + convert(varchar(255), @Type) + "'"
	select @ErrorMessage = @ErrorMessage + ","
	select @ErrorMessage = @ErrorMessage + "Code '" + convert(varchar(255), @Code) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "ExternalCode '" + convert(varchar(255), @ExternalCode) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode CodeDelete, unchained;
DROP PROCEDURE CodeGet;
--/
CREATE PROCEDURE CodeGet(
/**********************************************************************************
**
**
** Procedure : CodeGet
**
** Version   :    @(#)CodeGet.proc	63.1 08/06/01
**
** Notes     :
**
**********************************************************************************/
	@Type  varchar(255)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
        declare    @version   varchar(255)
        select     @version = "@(#)CodeGet.proc	63.1 08/06/01"
/* Adaptive Server has expanded all '*' elements in the following statement */ select Code.Type, Code.Code, Code.ExternalCode, Code.LongName, Code.Description, Code.CRC from Code where Type = "CodeType" and Code = @Type
if (@Type != "CodeType") begin
/* Adaptive Server has expanded all '*' elements in the following statement */ select Code.Type, Code.Code, Code.ExternalCode, Code.LongName, Code.Description, Code.CRC from Code where Type = @Type
order by Type,Code
end
else begin
/* Adaptive Server has expanded all '*' elements in the following statement */ select Code.Type, Code.Code, Code.ExternalCode, Code.LongName, Code.Description, Code.CRC from Code where Type = @Type and Code != "CodeType"
order by Type,Code
end


/
EXEC sp_procxmode CodeGet, unchained;
DROP PROCEDURE CodeInsert;
--/
CREATE PROCEDURE CodeInsert (
/**************************************************************************
**
** Procedure:	CodeInsert
**
** Version: 	@(#)CodeInsert.proc	63.1 08/06/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Type         varchar(255)       ,
	@Code         varchar(255)       ,
	@ExternalCode varchar(255)       ,
	@LongName     varchar(255)        = NULL,
	@Description  varchar(255) = NULL,
	@CRC          int         = NULL
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into Code (
	Type,
	Code,
	ExternalCode,
	LongName,
	Description,
	CRC )
values (
	@Type,
	@Code,
	@ExternalCode,
	@LongName,
	@Description,
	@CRC )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into Code table for key(s) "
	select @ErrorMessage = @ErrorMessage + "Type '" + convert(varchar(255), @Type) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "Code '" + convert(varchar(255), @Code) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "ExternalCode '" + convert(varchar(255), @ExternalCode) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode CodeInsert, unchained;
DROP PROCEDURE CodeUpdate;
--/
CREATE PROCEDURE CodeUpdate (
/**************************************************************************
**
** Procedure:	CodeUpdate
**
** Version: 	@(#)CodeUpdate.proc	63.1 08/06/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Type         varchar(255)       ,
	@Code         varchar(255)       ,
	@ExternalCode varchar(255)       ,
	@LongName     varchar(255)        = "#$%@",
	@Description  varchar(255) = "#$%@",
	@CRC          int         = -2147483647
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @longName     varchar(255)       ,
        @description  varchar(255),
        @crc          int        
Select @longName = LongName,
       @description = Description,
       @crc = CRC
from Code
  where Type = @Type
  and Code = @Code
  and ExternalCode = @ExternalCode
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from Code table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from Code table for key(s) "
	goto ERROR_EXIT
end
if @LongName != "#$%@"
	select @longName = @LongName
if @Description != "#$%@"
	select @description = @Description
if @CRC != -2147483647
	select @crc = @CRC
Update Code
set	LongName = @longName,
	Description = @description,
	CRC = @crc
  where Type = @Type
  and Code = @Code
  and ExternalCode = @ExternalCode
if @@error != 0
begin
	select @ErrorMessage = "Could not update Code table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Type '" + convert(varchar(255), @Type) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "Code '" + convert(varchar(255), @Code) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "ExternalCode '" + convert(varchar(255), @ExternalCode) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode CodeUpdate, unchained;
DROP PROCEDURE CollRuleTypeMappingAsCode;
--/
CREATE PROCEDURE CollRuleTypeMappingAsCode
/**********************************************************************************
**
**
** Procedure : CollRuleTypeMappingAsCode
**
** Version   :
**
** Notes     :
**
**********************************************************************************/
as
select "CodeType", "CollRuleTypeMapping", NULL, NULL, NULL, NULL
select "CollRuleTypeMapping", convert(varchar(10), RuleTypeID), RuleCategory, NULL, NULL, NULL
from MSADB..CollateralRuleType


/
EXEC sp_procxmode CollRuleTypeMappingAsCode, unchained;
DROP PROCEDURE CollateralIndexName;
--/
CREATE PROCEDURE CollateralIndexName
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
select 'CodeType', 'CollateralIndexName', 'ExternalCode', NULL, NULL, NULL
select 'CollateralIndexName', Code, ExternalCode, NULL, Description, NULL
from CDB..Code
where Type='CollateralIndexName'
order by Code 


/
EXEC sp_procxmode CollateralIndexName, unchained;
DROP PROCEDURE ConfigurationSegmentDelete;
--/
CREATE PROCEDURE ConfigurationSegmentDelete (
/**************************************************************************
**
** Procedure:	ConfigurationSegmentDelete
**
** Version: 	@(#)ConfigurationSegmentDelete.proc	63.1 08/06/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TeamMember        varchar(75),
	@ConfigurationName varchar(255)          ,
	@SegmentNumber     int   
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from ConfigurationSegment 
where TeamMember = @TeamMember
and    ConfigurationName = @ConfigurationName
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from ConfigurationSegment table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage + ","
	select @ErrorMessage = @ErrorMessage + "ConfigurationName '" + convert(varchar(255), @ConfigurationName) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "SegmentNumber '" + convert(varchar(255), @SegmentNumber) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode ConfigurationSegmentDelete, unchained;
DROP PROCEDURE ConfigurationSegmentInsert;
--/
CREATE PROCEDURE ConfigurationSegmentInsert (
/**************************************************************************
**
** Procedure:	ConfigurationSegmentInsert
**
** Version: 	@(#)ConfigurationSegmentInsert.proc	63.1 08/06/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TeamMember        varchar(75),
	@ConfigurationName varchar(255)          ,
	@SegmentNumber     int   ,
	@Configuration     varchar(255)    = NULL
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into ConfigurationSegment (
	TeamMember,
	ConfigurationName,
	SegmentNumber,
	Configuration )
values (
	@TeamMember,
	@ConfigurationName,
	@SegmentNumber,
	@Configuration )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into ConfigurationSegment table for key(s) "
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "ConfigurationName '" + convert(varchar(255), @ConfigurationName) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "SegmentNumber '" + convert(varchar(255), @SegmentNumber) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode ConfigurationSegmentInsert, unchained;
DROP PROCEDURE ConfigurationSegmentUpdate;
--/
CREATE PROCEDURE ConfigurationSegmentUpdate (
/**************************************************************************
**
** Procedure:	ConfigurationSegmentUpdate
**
** Version: 	@(#)ConfigurationSegmentUpdate.proc	63.1 08/06/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TeamMember        varchar(75),
	@ConfigurationName varchar(255)          ,
	@SegmentNumber     int   ,
	@Configuration     varchar(255)    = "#$%@"
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @configuration     varchar(255)   
Select @configuration = Configuration
from ConfigurationSegment
  where TeamMember = @TeamMember
  and ConfigurationName = @ConfigurationName
  and SegmentNumber = @SegmentNumber
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from ConfigurationSegment table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from ConfigurationSegment table for key(s) "
	goto ERROR_EXIT
end
if @Configuration != "#$%@"
	select @configuration = @Configuration
Update ConfigurationSegment
set	Configuration = @configuration
  where TeamMember = @TeamMember
  and ConfigurationName = @ConfigurationName
  and SegmentNumber = @SegmentNumber
if @@error != 0
begin
	select @ErrorMessage = "Could not update ConfigurationSegment table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "ConfigurationName '" + convert(varchar(255), @ConfigurationName) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "SegmentNumber '" + convert(varchar(255), @SegmentNumber) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode ConfigurationSegmentUpdate, unchained;
DROP PROCEDURE Counterparties;
--/
CREATE PROCEDURE Counterparties 
/*******************************************************************************
***
**
**
** Procedure : Counterparties 
**
** Version   :    
**
** Notes     :
**
********************************************************************************
**/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select AccountNumber,Mnemonic,LongName,LegalEntityCode,FirmLegalEntity,ManagerGroupID,ManagerGroupName,GFCID,GrandParentNumber,GrandParentName,CustAcctLastModified
from ADB..CustomerAccountView 


/
EXEC sp_procxmode Counterparties, unchained;
DROP PROCEDURE CreditOfficer;
--/
CREATE PROCEDURE CreditOfficer
/**********************************************************************
** Procedure : CreditOfficer
** Notes     :
**********************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version  varchar(255)
select @version = "%W% %G%"
select 'CreditOfficer', EmployeeIdentification, SybaseID, TeamMember
from CDB..TeamMember t
where t.Department in
(select Code from CDB..Code where Type = 'CreditDepartment')


/
EXEC sp_procxmode CreditOfficer, unchained;
DROP PROCEDURE CreditOfficers;
--/
CREATE PROCEDURE CreditOfficers
/**********************************************************************************
**
**
** Procedure : CreditOfficers
**
** Version   :    @(#)CreditOfficers.proc	63.1 08/06/01
**
** Notes     :
**
**********************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select @version = "@(#)CreditOfficers.proc	63.1 08/06/01"
select "CodeType", "CreditOfficer", NULL, NULL, NULL, NULL
select "CreditOfficer", TeamMember, NULL, NULL, 
"Telephone:"+Telephone
+convert(char(1), 0x0a)+"EMail:"+EMailAddress, NULL 
from TeamMember 
where TeamMember.Department in
(select Code from Code
where Type = 'CreditDepartment')
order by TeamMember


/
EXEC sp_procxmode CreditOfficers, unchained;
DROP PROCEDURE CustomMessageByKey;
--/
CREATE PROCEDURE CustomMessageByKey(
/**********************************************************************************
**
**
** Procedure : CustomMessageByKey
**
** Version   : %W% %G%
**
** Notes     :
**
**********************************************************************************/
	@MessageID int 
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
        declare  @version  varchar(255)
        select   @version = "%W% %G%"
	select CustomMessage from CDB..CustomMessage where MessageID = @MessageID
	if @@rowcount = 0 goto STORED_PROCEDURE_EXIT
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode CustomMessageByKey, unchained;
DROP PROCEDURE CustomMessageDelete;
--/
CREATE PROCEDURE CustomMessageDelete (
/**************************************************************************
**
** Procedure:	CustomMessageDelete
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@MessageID                 int   
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from CustomMessage 
where MessageID = @MessageID
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from CustomMessage table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from CustomMessage table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "MessageID '" + convert(varchar(255), @MessageID) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode CustomMessageDelete, unchained;
DROP PROCEDURE CustomMessageInsert;
--/
CREATE PROCEDURE CustomMessageInsert (
/**************************************************************************
**
** Procedure:	CustomMessageInsert
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@MessageID                 int   ,
	@ProcessingApplicationName varchar(255)        = NULL,
	@MessagePurpose            varchar(255)        = NULL,
	@CustomMessageSize         int = NULL,
	@ActiveMessage             int   = NULL
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @ErrorMessage	varchar(255)
insert into CustomMessage (
	MessageID,
	ProcessingApplicationName,
	MessagePurpose,
	CustomMessageSize,
	ActiveMessage )
values (
	@MessageID,
	@ProcessingApplicationName,
	@MessagePurpose,
	@CustomMessageSize,
	@ActiveMessage )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into CustomMessage table for key(s) "
	select @ErrorMessage = @ErrorMessage + "MessageID '" + convert(varchar(255), @MessageID) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode CustomMessageInsert, unchained;
DROP PROCEDURE CustomMessageUpdate;
--/
CREATE PROCEDURE CustomMessageUpdate (
/**************************************************************************
**
** Procedure:	CustomMessageUpdate
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@MessageID                 int   ,
	@ProcessingApplicationName varchar(255)        = "#$%@",
	@MessagePurpose            varchar(255)        = "#$%@",
	@CustomMessageSize         int = -2147483647,
	@ActiveMessage             int   = -2147483647
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @processingApplicationName varchar(255)       ,
        @messagePurpose            varchar(255)       ,
        @customMessageSize         int,
        @activeMessage             int  
Select @processingApplicationName = ProcessingApplicationName,
       @messagePurpose = MessagePurpose,
       @customMessageSize = CustomMessageSize,
       @activeMessage = ActiveMessage
from CustomMessage
  where MessageID = @MessageID
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from CustomMessage table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from CustomMessage table for key(s) "
	goto ERROR_EXIT
end
if @ProcessingApplicationName != "#$%@"
	select @processingApplicationName = @ProcessingApplicationName
if @MessagePurpose != "#$%@"
	select @messagePurpose = @MessagePurpose
if @CustomMessageSize != -2147483647
	select @customMessageSize = @CustomMessageSize
if @ActiveMessage != -2147483647
	select @activeMessage = @ActiveMessage
Update CustomMessage
set	ProcessingApplicationName = @processingApplicationName,
	MessagePurpose = @messagePurpose,
	CustomMessageSize = @customMessageSize,
	ActiveMessage = @activeMessage
  where MessageID = @MessageID
if @@error != 0
begin
	select @ErrorMessage = "Could not update CustomMessage table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "MessageID '" + convert(varchar(255), @MessageID) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode CustomMessageUpdate, unchained;
DROP PROCEDURE CustomReportDelete;
--/
CREATE PROCEDURE CustomReportDelete (
/**************************************************************************
**
** Procedure:	CustomReportDelete
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Report     varchar(75)
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from CustomReport 
where Report = @Report
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from CustomReport table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from CustomReport table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Report '" + convert(varchar(255), @Report) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode CustomReportDelete, unchained;
DROP PROCEDURE CustomReportInsert;
--/
CREATE PROCEDURE CustomReportInsert (
/**************************************************************************
**
** Procedure:	CustomReportInsert
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Report     varchar(75),
	@DBName     varchar(40)  = NULL,
	@StoredProc varchar(255)       = NULL
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into CustomReport (
	Report,
	DBName,
	StoredProc )
values (
	@Report,
	@DBName,
	@StoredProc )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into CustomReport table for key(s) "
	select @ErrorMessage = @ErrorMessage + "Report '" + convert(varchar(255), @Report) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode CustomReportInsert, unchained;
DROP PROCEDURE CustomReportUpdate;
--/
CREATE PROCEDURE CustomReportUpdate (
/**************************************************************************
**
** Procedure:	CustomReportUpdate
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Report     varchar(75),
	@DBName     varchar(40)  = "#$%@",
	@StoredProc varchar(255)       = "#$%@"
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @dBName     varchar(40) ,
        @storedProc varchar(255)      
Select @dBName = DBName,
       @storedProc = StoredProc
from CustomReport
  where Report = @Report
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from CustomReport table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from CustomReport table for key(s) "
	goto ERROR_EXIT
end
if @DBName != "#$%@"
	select @dBName = @DBName
if @StoredProc != "#$%@"
	select @storedProc = @StoredProc
Update CustomReport
set	DBName = @dBName,
	StoredProc = @storedProc
  where Report = @Report
if @@error != 0
begin
	select @ErrorMessage = "Could not update CustomReport table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Report '" + convert(varchar(255), @Report) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode CustomReportUpdate, unchained;
DROP PROCEDURE DPSOasysCalendar_sp;
--/
CREATE PROCEDURE DPSOasysCalendar_sp(
/**********************************************************************************
**
**
** Procedure : DPSOasysCalendar_sp
**
** Version   : %W% %G%
**
** Notes     :
**
*******************************************************************************/
			@MinHolidayDate int,
			@MaxHolidayDate int
)
as
SELECT convert(char(30), CalendarName) ClientCalendarName, convert(char(30), CalendarName) CalendarName, 'SATURDAY' Holiday FROM HolidayDefinition where convert(bit,ascii(Weekend) & 128 )=1
UNION ALL SELECT convert(char(30), CalendarName) ClientCalendarName,convert(char(30), CalendarName) CalendarName, 'FRIDAY' Holiday FROM HolidayDefinition where convert(bit,ascii(Weekend) & 64 )=1
UNION ALL SELECT convert(char(30), CalendarName) ClientCalendarName,convert(char(30), CalendarName) CalendarName, 'THURSDAY' Holiday FROM HolidayDefinition where convert(bit,ascii(Weekend) & 32 )=1
UNION ALL SELECT convert(char(30), CalendarName) ClientCalendarName,convert(char(30), CalendarName) CalendarName, 'WEDNESDAY' Holiday FROM HolidayDefinition where convert(bit,ascii(Weekend) & 16 )=1
UNION ALL SELECT convert(char(30), CalendarName) ClientCalendarName,convert(char(30), CalendarName) CalendarName, 'TUESDAY' Holiday FROM HolidayDefinition where convert(bit,ascii(Weekend) & 8 )=1
UNION ALL SELECT convert(char(30), CalendarName) ClientCalendarName,convert(char(30), CalendarName) CalendarName, 'MONDAY' Holiday FROM HolidayDefinition where convert(bit,ascii(Weekend) & 4 )=1
UNION ALL SELECT convert(char(30), CalendarName) ClientCalendarName,convert(char(30), CalendarName) CalendarName, 'SUNDAY' Holiday FROM HolidayDefinition where convert(bit,ascii(Weekend) & 2 )=1
 
UNION ALL  
SELECT convert(char(30), hd.CalendarName) ClientCalendarName, convert(char(30), hd.CalendarName) CalendarName, convert(char(30), h.Holiday) Holiday
FROM Holiday h, HolidayDefinition hd
WHERE h.Calendar = hd.Calendar
AND h.Holiday >= @MinHolidayDate
AND h.Holiday <= @MaxHolidayDate
ORDER BY 1,3


/
EXEC sp_procxmode DPSOasysCalendar_sp, unchained;
DROP PROCEDURE DTCCBusinessRuleIDList;
--/
CREATE PROCEDURE DTCCBusinessRuleIDList
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select 'CodeType', 'DTCCBusinessRuleIDList', NULL, NULL, NULL, NULL 
select 'DTCCBusinessRuleIDList', DataMapID, NULL, NULL, NULL, NULL 
from CDB..DataMapConfig where KeyFieldCount <> 0 and IsUserEditable = 'Y' order by DataMapID 

/
EXEC sp_procxmode DTCCBusinessRuleIDList, unchained;
DROP PROCEDURE DTCCCLSList;
--/
CREATE PROCEDURE DTCCCLSList
/**********************************************************************************
**
**
** Procedure : DTCCCLSList
**
** Version   :    %W% %G%
**
** Notes     :
**
**********************************************************************************/
as
declare         @version  varchar(255)
select @version = "%W% %G%"
select "CodeType", "DTCCCLSList", NULL, NULL, NULL, NULL
select distinct "DTCCCLSList", DTCCCustomerID, CurrencyList, NULL, NULL, NULL
from WFDB..DTCCProductCLSCurrency
order by 1,2,3


/
EXEC sp_procxmode DTCCCLSList, unchained;
DROP PROCEDURE DTCCSuppressionMakers;
--/
CREATE PROCEDURE DTCCSuppressionMakers
/**********************************************************************************
**
**
** Procedure : DTCCSuppressionMakers
**
** Version   :    @(#)DTCCSuppressionMakers.proc	63.1 08/07/01 
**
** Notes     :
**
**********************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select 'CodeType', 'DTCCSuppressionMakers', NULL, NULL, NULL, NULL select 'DTCCSuppressionMakers', TeamMember, NULL, NULL, NULL, NULL from CDB..TeamMemberPrivileges where TeamMemberPrivilege = 'DTCCSuppressConfirm'
order by TeamMember


/
EXEC sp_procxmode DTCCSuppressionMakers, unchained;
DROP PROCEDURE DataServerDelete;
--/
CREATE PROCEDURE DataServerDelete (
/**************************************************************************
**
** Procedure:	DataServerDelete
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@DataServer  varchar(255)
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from DataServer 
where DataServer = @DataServer
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from DataServer table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from DataServer table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "DataServer '" + convert(varchar(255), @DataServer) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode DataServerDelete, unchained;
DROP PROCEDURE DataServerInsert;
--/
CREATE PROCEDURE DataServerInsert (
/**************************************************************************
**
** Procedure:	DataServerInsert
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@DataServer  varchar(255),
	@Type        varchar(255) = NULL,
	@Description varchar(255) = NULL
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into DataServer (
	DataServer,
	Type,
	Description )
values (
	@DataServer,
	@Type,
	@Description )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into DataServer table for key(s) "
	select @ErrorMessage = @ErrorMessage + "DataServer '" + convert(varchar(255), @DataServer) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode DataServerInsert, unchained;
DROP PROCEDURE DataServerUpdate;
--/
CREATE PROCEDURE DataServerUpdate (
/**************************************************************************
**
** Procedure:	DataServerUpdate
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@DataServer  varchar(255),
	@Type        varchar(255) = "#$%@",
	@Description varchar(255) = "#$%@"
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @type        varchar(255),
        @description varchar(255)
Select @type = Type,
       @description = Description
from DataServer
  where DataServer = @DataServer
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from DataServer table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from DataServer table for key(s) "
	goto ERROR_EXIT
end
if @Type != "#$%@"
	select @type = @Type
if @Description != "#$%@"
	select @description = @Description
Update DataServer
set	Type = @type,
	Description = @description
  where DataServer = @DataServer
if @@error != 0
begin
	select @ErrorMessage = "Could not update DataServer table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "DataServer '" + convert(varchar(255), @DataServer) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode DataServerUpdate, unchained;
DROP PROCEDURE DeleteQueriesAndReports;
--/
CREATE PROCEDURE DeleteQueriesAndReports (
/*************************************************************************
**
** Procedure:   DeleteQueriesAndReports
**
** Version:     %W%	%G%
**
** Notes:       
**
**************************************************************************/
	@TeamMember	varchar(75)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
        declare    @version   varchar(255)
        select     @version = "%W%	%G%"
        
delete CDB..Query where QueryID in ( select QueryID from CDB..Report where TeamMember = @TeamMember )
delete CDB..QueryAction where QueryID in ( select QueryID from CDB..Report where TeamMember = @TeamMember )
delete CDB..QueryCondition where QueryID in ( select QueryID from CDB..Report where TeamMember = @TeamMember )
delete CDB..QueryConditionValue where QueryID in ( select QueryID from CDB..Report where TeamMember = @TeamMember )
delete CDB..QueryIndex where QueryID in ( select QueryID from CDB..Report where TeamMember = @TeamMember )
delete CDB..Report where TeamMember = @TeamMember
delete CDB..ReportSegment where TeamMember = @TeamMember
delete CDB..ReportCustomization where TeamMember = @TeamMember


/
EXEC sp_procxmode DeleteQueriesAndReports, unchained;
DROP PROCEDURE DeleteRiskPrivilegesForTeamMem;
--/
CREATE PROCEDURE DeleteRiskPrivilegesForTeamMem
/**************************************************************************
**
** Procedure:	DeleteRiskPrivilegesForTeamMem
**
** Version: 	"%W%"
**
**************************************************************************/
as
declare @ErrorMessage	varchar(255)
declare @version  varchar(255)
select  @version = "%W%"
delete TeamMemberPrivileges
from TeamMember a , TeamMemberPrivileges b
where a.TeamMember = b.TeamMember 
and (a.SybaseID not like "sybdba%" 
and a.SybaseID not like "dpsprod%" 
and a.SybaseID not like "oasystc%"
and a.CostCentre in (select distinct Code from CDB..Code where Type = 'TechnologyPL'))
and 
	(  b.TeamMemberPrivilege like "Create%" 
	or b.TeamMemberPrivilege like "Modify%" 
	or TeamMemberPrivilege like 'Execute%' 
	or TeamMemberPrivilege like 'Adj%'
	or TeamMemberPrivilege in (select distinct Code from Code where Type = 'RiskPrivileges'))
delete TeamMemberPrivileges
from TeamMember a , TeamMemberGroupLink b, TeamMemberPrivileges c
where b.TeamMember *= a.TeamMember
and (a.SybaseID not like "sybdba%"
and a.SybaseID not like "dpsprod%" 
and a.SybaseID not like "oasystc%" 
and a.CostCentre in (select distinct Code from CDB..Code where Type = 'TechnologyPL'))
and b.TeamMemberGroup = c.TeamMember
and
	(  c.TeamMemberPrivilege like "Create%" 
	or c.TeamMemberPrivilege like "Modify%" 
	or c.TeamMemberPrivilege like 'Execute%' 
	or c.TeamMemberPrivilege like 'Adj%'
	or c.TeamMemberPrivilege in (select distinct Code from Code where Type = 'RiskPrivileges')) 
delete TeamMemberDataAccessPrivileges
from TeamMember T, TeamMemberDataAccessPrivileges TP
where T.TeamMember = TP.TeamMember
and TP.AccessPrivilege in (2,3)
and (T.SybaseID not like "sybdba%"
and T.SybaseID not like "dpsprod%" 
and T.SybaseID not like "oasystc%"
and T.CostCentre in (select distinct Code from CDB..Code where Type = 'TechnologyPL'))
	
if @@error != 0
        goto STORED_PROCEDURE_EXIT
goto STORED_PROCEDURE_EXIT
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode DeleteRiskPrivilegesForTeamMem, unchained;
DROP PROCEDURE DerivSpecialistAsCode;
--/
CREATE PROCEDURE DerivSpecialistAsCode
/**********************************************************************************
**
**
** Procedure : DerivSpecialistAsCode
**
** Version   :    @(#)DerivSpecialistAsCode.proc	63.1 08/07/01 
**
** Notes     :
**
**********************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select @version = "@(#)DerivSpecialistAsCode.proc	63.1 01/17/11"
select "CodeType", "DerivStaff", NULL, NULL, NULL, NULL
select "DerivStaff", TeamMember, NULL, NULL, NULL, NULL from CDB..TeamMemberGroupLink
where TeamMemberGroup = 'DerivTradeProSpecialist-grp'
order by TeamMember


/
EXEC sp_procxmode DerivSpecialistAsCode, unchained;
DROP PROCEDURE DoddFrankCtrlRptEmailRecepients;
--/
CREATE PROCEDURE DoddFrankCtrlRptEmailRecepients
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
begin
select Code from CDB..Code where Type = 'DoddFrankReportRecepients'
end


/
EXEC sp_procxmode DoddFrankCtrlRptEmailRecepients, unchained;
DROP PROCEDURE EmployeeDetailsDelete;
--/
CREATE PROCEDURE EmployeeDetailsDelete (
/**************************************************************************
**
** Procedure:	EmployeeDetailsDelete
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TeamMember             varchar(75) 
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from EmployeeDetails 
where TeamMember = @TeamMember
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from EmployeeDetails table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from EmployeeDetails table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode EmployeeDetailsDelete, unchained;
DROP PROCEDURE EmployeeDetailsDeleteRows;
--/
CREATE PROCEDURE EmployeeDetailsDeleteRows
/**************************************************************************
**
** Procedure:	EmployeeDetailsDeleteRows
**
** Version: 	@(#)EmployeeDetailsDeleteRows.sp	125.1 06/21/07
**
** Notes:	Automatically Generated
**
**************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
set rowcount 50000
declare @rowcount       int
while (1=1)
	begin
		delete from EMDB..EmployeeDetails
		if (@@rowcount = 0)
			break
	end
 
while (1=1)
	begin
		delete from CDB..EmployeeDetails
		if (@@rowcount = 0)
			break
	end
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode EmployeeDetailsDeleteRows, unchained;
DROP PROCEDURE EmployeeDetailsInsert;
--/
CREATE PROCEDURE EmployeeDetailsInsert (
/**************************************************************************
**
** Procedure:	EmployeeDetailsInsert
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TeamMember             varchar(75) ,
	@SOEID                  varchar(255) = NULL,
	@EmployeeIdentification int         = NULL,
	@Department             varchar(255)            = NULL,
	@EMailAddress           varchar(255)    = NULL,
	@Telephone              varchar(255) = NULL,
	@Fax                    varchar(255) = NULL,
	@Location               varchar(255)            = NULL,
	@RITSID                 int         = NULL,
	@CostCentre             varchar(40)       = NULL,
	@Title                  varchar(40)       = NULL,
	@LastModifiedTimeStamp  datetime            = NULL,
	@FirstName              varchar(75)  = NULL,
	@LastName               varchar(75)  = NULL,
	@Supervisor             varchar(75)  = NULL,
	@Region                 varchar(75)  = NULL,
	@Country                varchar(75)  = NULL
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into EmployeeDetails (
	TeamMember,
	SOEID,
	EmployeeIdentification,
	Department,
	EMailAddress,
	Telephone,
	Fax,
	Location,
	RITSID,
	CostCentre,
	Title,
	LastModifiedTimeStamp,
	FirstName,
	LastName,
	Supervisor,
	Region,
	Country )
values (
	@TeamMember,
	@SOEID,
	@EmployeeIdentification,
	@Department,
	@EMailAddress,
	@Telephone,
	@Fax,
	@Location,
	@RITSID,
	@CostCentre,
	@Title,
	@LastModifiedTimeStamp,
	@FirstName,
	@LastName,
	@Supervisor,
	@Region,
	@Country )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into EmployeeDetails table for key(s) "
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode EmployeeDetailsInsert, unchained;
DROP PROCEDURE EmployeeDetailsTeamMemberSync;
--/
CREATE PROCEDURE EmployeeDetailsTeamMemberSync
/**************************************************************************
**
** Procedure:	EmployeeDetailsTeamMemberSync
**
** Version: 	@(#)EmployeeDetailsTeamMemberSync.sp	125.1 05/08/07
**
** Notes:	Automatically Generated
**
**************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
update CDB..TeamMember
set tm.EMailAddress = ed.EMailAddress,
  tm.Telephone = ed.Telephone,
    tm.CostCentre = ed.CostCentre,
    tm.FirstName = ed.FirstName,
    tm.LastName = ed.LastName,
    tm.Supervisor = ed.Supervisor,
    tm.Region = ed.Region,
    tm.Country = ed.Country,
    tm.Location = ed.Location
 from    CDB..TeamMember tm, CDB..EmployeeDetails ed
where   (tm.TeamMemberType = 1  or tm.TeamMemberType = 4 ) -- USER = 1, GROUP = 2, FUNCTIONAL = 3, EMERGENCY = 4
        and tm.EmployeeIdentification = ed.EmployeeIdentification
update EMDB..TeamMember
set tm.EmailAddress = ed.EmailAddress,
  tm.Telephone = ed.Telephone,
    tm.CostCentre = ed.CostCentre,
     tm.FirstName = ed.FirstName,
        tm.LastName = ed.LastName,
        tm.Supervisor = ed.Supervisor,
        tm.Region = ed.Region,
        tm.Country = ed.Country,
    tm.Location = ed.Location
from    EMDB..TeamMember tm, EMDB..EmployeeDetails ed
where   (tm.TeamMemberType = 1  or tm.TeamMemberType = 4 ) -- USER = 1, GROUP = 2, FUNCTIONAL = 3, EMERGENCY = 4
        and tm.EmployeeIdentification = ed.EmployeeIdentification
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode EmployeeDetailsTeamMemberSync, unchained;
DROP PROCEDURE EmployeeDetailsUpdate;
--/
CREATE PROCEDURE EmployeeDetailsUpdate (
/**************************************************************************
**
** Procedure:	EmployeeDetailsUpdate
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TeamMember             varchar(75) ,
	@SOEID                  varchar(255) = "#$%@",
	@EmployeeIdentification int         = -2147483647,
	@Department             varchar(255)            = "#$%@",
	@EMailAddress           varchar(255)    = "#$%@",
	@Telephone              varchar(255) = "#$%@",
	@Fax                    varchar(255) = "#$%@",
	@Location               varchar(255)            = "#$%@",
	@RITSID                 int         = -2147483647,
	@CostCentre             varchar(40)       = "#$%@",
	@Title                  varchar(40)       = "#$%@",
	@LastModifiedTimeStamp  datetime            = '99991231',
	@FirstName              varchar(75)  = "#$%@",
	@LastName               varchar(75)  = "#$%@",
	@Supervisor             varchar(75)  = "#$%@",
	@Region                 varchar(75)  = "#$%@",
	@Country                varchar(75)  = "#$%@"
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @soeID                  varchar(255),
        @employeeIdentification int        ,
        @department             varchar(255)           ,
        @eMailAddress           varchar(255)   ,
        @telephone              varchar(255),
        @fax                    varchar(255),
        @location               varchar(255)           ,
        @ritsID                 int        ,
        @costCentre             varchar(40)      ,
        @title                  varchar(40)      ,
        @lastModifiedTimeStamp  datetime           ,
        @firstname              varchar(75) ,
        @lastname               varchar(75) ,
        @supervisor             varchar(75) ,
        @region                 varchar(75) ,
        @country                varchar(75) 
Select @soeID = SOEID,
       @employeeIdentification = EmployeeIdentification,
       @department = Department,
       @eMailAddress = EMailAddress,
       @telephone = Telephone,
       @fax = Fax,
       @location = Location,
       @ritsID = RITSID,
       @costCentre = CostCentre,
       @title = Title,
       @lastModifiedTimeStamp = LastModifiedTimeStamp,
       @firstname = FirstName,
       @lastname = LastName,
       @supervisor = Supervisor,
       @region = Region,
       @country = Country
from EmployeeDetails
  where TeamMember = @TeamMember
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from EmployeeDetails table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from EmployeeDetails table for key(s) "
	goto ERROR_EXIT
end
if @SOEID != "#$%@"
	select @soeID = @SOEID
if @EmployeeIdentification != -2147483647
	select @employeeIdentification = @EmployeeIdentification
if @Department != "#$%@"
	select @department = @Department
if @EMailAddress != "#$%@"
	select @eMailAddress = @EMailAddress
if @Telephone != "#$%@"
	select @telephone = @Telephone
if @Fax != "#$%@"
	select @fax = @Fax
if @Location != "#$%@"
	select @location = @Location
if @RITSID != -2147483647
	select @ritsID = @RITSID
if @CostCentre != "#$%@"
	select @costCentre = @CostCentre
if @Title != "#$%@"
	select @title = @Title
if @LastModifiedTimeStamp != '99991231'
	select @lastModifiedTimeStamp = @LastModifiedTimeStamp
if @FirstName != "#$%@"
	select @firstname = @FirstName
if @LastName != "#$%@"
	select @lastname = @LastName
if @Supervisor != "#$%@"
	select @supervisor = @Supervisor
if @Region != "#$%@"
	select @region = @Region
if @Country != "#$%@"
	select @country = @Country
Update EmployeeDetails
set	SOEID = @soeID,
	EmployeeIdentification = @employeeIdentification,
	Department = @department,
	EMailAddress = @eMailAddress,
	Telephone = @telephone,
	Fax = @fax,
	Location = @location,
	RITSID = @ritsID,
	CostCentre = @costCentre,
	Title = @title,
	LastModifiedTimeStamp = @lastModifiedTimeStamp,
	FirstName = @firstname,
	LastName = @lastname,
	Supervisor = @supervisor,
	Region = @region,
	Country = @country
  where TeamMember = @TeamMember
if @@error != 0
begin
	select @ErrorMessage = "Could not update EmployeeDetails table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode EmployeeDetailsUpdate, unchained;
DROP PROCEDURE EnvConfigByKey;
--/
CREATE PROCEDURE EnvConfigByKey (
/**********************************************************************************
**
**
** Procedure : EnvConfigByKey
**
** Version   : %W% %G%
**
** Notes     :
**
**********************************************************************************/
        @Environment	varchar(25),
        @Machine	varchar(50)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
        declare  @version  varchar(255)
        select   @version = "%W% %G%"
        /* Adaptive Server has expanded all '*' elements in the following statement */ select
		CDB..MarkImportEnvConfig.Environment, CDB..MarkImportEnvConfig.Machine, CDB..MarkImportEnvConfig.DataBaseServer, CDB..MarkImportEnvConfig.ArchiveMarkDir, CDB..MarkImportEnvConfig.BrowserMarkDir, CDB..MarkImportEnvConfig.CollectorMarkDir, CDB..MarkImportEnvConfig.CreditMarkDir, CDB..MarkImportEnvConfig.FinancialMarkDir, CDB..MarkImportEnvConfig.StatusDir, CDB..MarkImportEnvConfig.UploadMarkDir, CDB..MarkImportEnvConfig.CreditMTMKeyDir, CDB..MarkImportEnvConfig.CreditMTMKeyQADir, CDB..MarkImportEnvConfig.OafnServer, CDB..MarkImportEnvConfig.OafnContServer, CDB..MarkImportEnvConfig.FtpID, CDB..MarkImportEnvConfig.FtpPassword, CDB..MarkImportEnvConfig.SwapcoServer, CDB..MarkImportEnvConfig.SwapcoContServer, CDB..MarkImportEnvConfig.SwapcoFtpID, CDB..MarkImportEnvConfig.SwapcoFtpPassword, CDB..MarkImportEnvConfig.OperatorHomeDir, CDB..MarkImportEnvConfig.UsersHomeDir, CDB..MarkImportEnvConfig.FtpHomeDir, CDB..MarkImportEnvConfig.OatcFtpServer, CDB..MarkImportEnvConfig.OatcContFtpServer, CDB..MarkImportEnvConfig.CPMBrowserMarkDir
        from
		CDB..MarkImportEnvConfig
        where
                Environment = @Environment 
	and
                Machine	= @Machine
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode EnvConfigByKey, unchained;
DROP PROCEDURE ExceptionHandlingDelete;
--/
CREATE PROCEDURE ExceptionHandlingDelete (
/**************************************************************************
**
** Procedure:	ExceptionHandlingDelete
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@ExceptionID            int,
	@ExceptionKey           varchar(255)       
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from ExceptionHandling 
where ExceptionID = @ExceptionID
and    ExceptionKey = @ExceptionKey
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from ExceptionHandling table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from ExceptionHandling table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "ExceptionID '" + convert(varchar(255), @ExceptionID) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "ExceptionKey '" + convert(varchar(255), @ExceptionKey) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode ExceptionHandlingDelete, unchained;
DROP PROCEDURE ExceptionHandlingInsert;
--/
CREATE PROCEDURE ExceptionHandlingInsert (
/**************************************************************************
**
** Procedure:	ExceptionHandlingInsert
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@ExceptionID            int,
	@ExceptionKey           varchar(255)       ,
	@ExceptionProcess       int = NULL,
	@ApplicationName        varchar(255)        = NULL,
	@ExceptionTeamMember    varchar(255)        = NULL,
	@ExceptionTime          datetime        = NULL,
	@ExceptionProcessSystem varchar(255)        = NULL,
	@ProcessStatus          int = NULL,
	@ProcessedTime          datetime        = NULL,
	@ReprocessFailureReason varchar(255)        = NULL,
	@BatchTeamMember        varchar(255)        = NULL,
	@Location               varchar(255)        = NULL,
	@Option2                varchar(255)        = NULL,
	@Option3                varchar(255)        = NULL,
	@Option4                varchar(255)        = NULL
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into ExceptionHandling (
	ExceptionID,
	ExceptionKey,
	ExceptionProcess,
	ApplicationName,
	ExceptionTeamMember,
	ExceptionTime,
	ExceptionProcessSystem,
	ProcessStatus,
	ProcessedTime,
	ReprocessFailureReason,
	BatchTeamMember,
	Location,
	Option2,
	Option3,
	Option4 )
values (
	@ExceptionID,
	@ExceptionKey,
	@ExceptionProcess,
	@ApplicationName,
	@ExceptionTeamMember,
	@ExceptionTime,
	@ExceptionProcessSystem,
	@ProcessStatus,
	@ProcessedTime,
	@ReprocessFailureReason,
	@BatchTeamMember,
	@Location,
	@Option2,
	@Option3,
	@Option4 )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into ExceptionHandling table for key(s) "
	select @ErrorMessage = @ErrorMessage + "ExceptionID '" + convert(varchar(255), @ExceptionID) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "ExceptionKey '" + convert(varchar(255), @ExceptionKey) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode ExceptionHandlingInsert, unchained;
DROP PROCEDURE ExceptionHandlingUpdate;
--/
CREATE PROCEDURE ExceptionHandlingUpdate (
/**************************************************************************
**
** Procedure:	ExceptionHandlingUpdate
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@ExceptionID            int,
	@ExceptionKey           varchar(255)       ,
	@ExceptionProcess       int = -2147483647,
	@ApplicationName        varchar(255)        = "#$%@",
	@ExceptionTeamMember    varchar(255)        = "#$%@",
	@ExceptionTime          datetime        = '99991231',
	@ExceptionProcessSystem varchar(255)        = "#$%@",
	@ProcessStatus          int = -2147483647,
	@ProcessedTime          datetime        = '99991231',
	@ReprocessFailureReason varchar(255)        = "#$%@",
	@BatchTeamMember        varchar(255)        = "#$%@",
	@Location               varchar(255)        = "#$%@",
	@Option2                varchar(255)        = "#$%@",
	@Option3                varchar(255)        = "#$%@",
	@Option4                varchar(255)        = "#$%@"
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @exceptionprocess       int,
        @applicationname        varchar(255)       ,
        @exceptionteammember    varchar(255)       ,
        @exceptiontime          datetime       ,
        @exceptionprocesssystem varchar(255)       ,
        @processstatus          int,
        @processedtime          datetime       ,
        @reprocessfailurereason varchar(255)       ,
        @batchteammember        varchar(255)       ,
        @location               varchar(255)       ,
        @option2                varchar(255)       ,
        @option3                varchar(255)       ,
        @option4                varchar(255)       
Select @exceptionprocess = ExceptionProcess,
       @applicationname = ApplicationName,
       @exceptionteammember = ExceptionTeamMember,
       @exceptiontime = ExceptionTime,
       @exceptionprocesssystem = ExceptionProcessSystem,
       @processstatus = ProcessStatus,
       @processedtime = ProcessedTime,
       @reprocessfailurereason = ReprocessFailureReason,
       @batchteammember = BatchTeamMember,
       @location = Location,
       @option2 = Option2,
       @option3 = Option3,
       @option4 = Option4
from ExceptionHandling
  where ExceptionID = @ExceptionID
  and ExceptionKey = @ExceptionKey
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from ExceptionHandling table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from ExceptionHandling table for key(s) "
	goto ERROR_EXIT
end
if @ExceptionProcess != -2147483647
	select @exceptionprocess = @ExceptionProcess
if @ApplicationName != "#$%@"
	select @applicationname = @ApplicationName
if @ExceptionTeamMember != "#$%@"
	select @exceptionteammember = @ExceptionTeamMember
if @ExceptionTime != '99991231'
	select @exceptiontime = @ExceptionTime
if @ExceptionProcessSystem != "#$%@"
	select @exceptionprocesssystem = @ExceptionProcessSystem
if @ProcessStatus != -2147483647
	select @processstatus = @ProcessStatus
if @ProcessedTime != '99991231'
	select @processedtime = @ProcessedTime
if @ReprocessFailureReason != "#$%@"
	select @reprocessfailurereason = @ReprocessFailureReason
if @BatchTeamMember != "#$%@"
	select @batchteammember = @BatchTeamMember
if @Location != "#$%@"
	select @location = @Location
if @Option2 != "#$%@"
	select @option2 = @Option2
if @Option3 != "#$%@"
	select @option3 = @Option3
if @Option4 != "#$%@"
	select @option4 = @Option4
Update ExceptionHandling
set	ExceptionProcess = @exceptionprocess,
	ApplicationName = @applicationname,
	ExceptionTeamMember = @exceptionteammember,
	ExceptionTime = @exceptiontime,
	ExceptionProcessSystem = @exceptionprocesssystem,
	ProcessStatus = @processstatus,
	ProcessedTime = @processedtime,
	ReprocessFailureReason = @reprocessfailurereason,
	BatchTeamMember = @batchteammember,
	Location = @location,
	Option2 = @option2,
	Option3 = @option3,
	Option4 = @option4
  where ExceptionID = @ExceptionID
  and ExceptionKey = @ExceptionKey
if @@error != 0
begin
	select @ErrorMessage = "Could not update ExceptionHandling table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "ExceptionID '" + convert(varchar(255), @ExceptionID) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "ExceptionKey '" + convert(varchar(255), @ExceptionKey) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode ExceptionHandlingUpdate, unchained;
DROP PROCEDURE FIMSecurities;
--/
CREATE PROCEDURE FIMSecurities
/**********************************************************************************
**
**
** Procedure : FIMSecurities
**
** Version   : %W% %G%
**
** Notes     :
**
**********************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "%W%"
select "CodeType", "FIMSecurities", NULL, NULL, NULL, NULL


/
EXEC sp_procxmode FIMSecurities, unchained;
DROP PROCEDURE FIMSecurityCurrency;
--/
CREATE PROCEDURE FIMSecurityCurrency(
/**********************************************************************************
**
**
** Procedure : FIMSecurityCurrency
**
** Version   : %W%
**
** Notes     :
**
**********************************************************************************/
	@FIM_ID varchar(255)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "%W%"
select "USD"


/
EXEC sp_procxmode FIMSecurityCurrency, unchained;
DROP PROCEDURE FeedConfigByMarkFile;
--/
CREATE PROCEDURE FeedConfigByMarkFile (
/**********************************************************************************
**
**
** Procedure : FeedConfigByMarkFile
**
** Version   : %W% %G%
**
** Notes     :
**
**********************************************************************************/
        @MarkFileName	varchar(150)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
        declare  @version  varchar(255)
        select   @version = "%W% %G%"
        /* Adaptive Server has expanded all '*' elements in the following statement */ select
		CDB..MarkImportFeedConfig.MarkFileName, CDB..MarkImportFeedConfig.MarkingSystem, CDB..MarkImportFeedConfig.FeedType, CDB..MarkImportFeedConfig.InputFileDir, CDB..MarkImportFeedConfig.CalculateBrowserMarks, CDB..MarkImportFeedConfig.MakeSwapBufferOnly, CDB..MarkImportFeedConfig.NoMarkAdjustment, CDB..MarkImportFeedConfig.NoMarkAdjPmtOnValueDate, CDB..MarkImportFeedConfig.NoMarkAdjPerStartMisMatch, CDB..MarkImportFeedConfig.NoMarkFeeAdjustment, CDB..MarkImportFeedConfig.PrintSwapBufferOnly, CDB..MarkImportFeedConfig.SaveBrowserMarksToDB, CDB..MarkImportFeedConfig.SaveMarksToDB, CDB..MarkImportFeedConfig.TestSwapBuffer, CDB..MarkImportFeedConfig.TrxMarkAdjustment, CDB..MarkImportFeedConfig.UseActualMTMPolicy, CDB..MarkImportFeedConfig.CollectorMarkOption, CDB..MarkImportFeedConfig.BrowserMarkFlag, CDB..MarkImportFeedConfig.CollectorMarkFlag, CDB..MarkImportFeedConfig.CreditMarkFlag, CDB..MarkImportFeedConfig.FinancialMarkFlag, CDB..MarkImportFeedConfig.JobStatusFlag, CDB..MarkImportFeedConfig.ImportMarkFlag, CDB..MarkImportFeedConfig.MarkFileSplitFlag, CDB..MarkImportFeedConfig.MarkFileSplitSize, CDB..MarkImportFeedConfig.MaxFileSplitNumber, CDB..MarkImportFeedConfig.MaxReprocessNumber, CDB..MarkImportFeedConfig.MarkFileSourceLocation, CDB..MarkImportFeedConfig.OafnLocationCode, CDB..MarkImportFeedConfig.OafnDeskCode, CDB..MarkImportFeedConfig.OafnSwapCode, CDB..MarkImportFeedConfig.Environment, CDB..MarkImportFeedConfig.Machine, CDB..MarkImportFeedConfig.DataBaseServer, CDB..MarkImportFeedConfig.OafnTargetDir, CDB..MarkImportFeedConfig.OafnContTargetDir, CDB..MarkImportFeedConfig.JobStatusTargetServer, CDB..MarkImportFeedConfig.JobStatusTargetDir, CDB..MarkImportFeedConfig.JobStatusFtpID, CDB..MarkImportFeedConfig.JobStatusFtpPassword, CDB..MarkImportFeedConfig.MarkingSystemContact, CDB..MarkImportFeedConfig.MarkingSystemGroupEmail, CDB..MarkImportFeedConfig.MarkingSysPassedFlag, CDB..MarkImportFeedConfig.CheckMarkFileSize, CDB..MarkImportFeedConfig.CPMBrowserMarkFlag, CDB..MarkImportFeedConfig.CPMFinancialMarkFlag, CDB..MarkImportFeedConfig.FinancialSftpFlag, CDB..MarkImportFeedConfig.JobStatusSftpFlag, CDB..MarkImportFeedConfig.SkipPFSFlag, CDB..MarkImportFeedConfig.FinMarkFileGenFirst
        from
		CDB..MarkImportFeedConfig
        where
                MarkFileName = @MarkFileName
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode FeedConfigByMarkFile, unchained;
DROP PROCEDURE FilterDelete;
--/
CREATE PROCEDURE FilterDelete (
/**************************************************************************
**
** Procedure:	FilterDelete
**
** Version: 	@(#)FilterDelete.proc	63.1 08/06/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@ReportType  varchar(40)     ,
	@Report      varchar(75)    ,
	@TeamMember  varchar(75),
	@TableName   varchar(255)          ,
	@TableKey    varchar(255)          ,
	@Column      varchar(255)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from Filter 
where ReportType = @ReportType
and    Report = @Report
and    TeamMember = @TeamMember
and    TableName = @TableName
and    TableKey = @TableKey
and    Column = @Column
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from Filter table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from Filter table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "ReportType '" + convert(varchar(255), @ReportType) + "'"
	select @ErrorMessage = @ErrorMessage + ","
	select @ErrorMessage = @ErrorMessage + "Report '" + convert(varchar(255), @Report) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode FilterDelete, unchained;
DROP PROCEDURE FilterInsert;
--/
CREATE PROCEDURE FilterInsert (
/**************************************************************************
**
** Procedure:	FilterInsert
**
** Version: 	@(#)FilterInsert.proc	63.1 08/06/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@ReportType  varchar(40)     ,
	@Report      varchar(75)    ,
	@TeamMember  varchar(75),
	@Operation   int = NULL,
	@TableName   varchar(255)          ,
	@TableKey    varchar(255)          ,
	@Column      varchar(255)          ,
	@ColumnValue varchar(255)    = NULL
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @ErrorMessage	varchar(255)
insert into Filter (
	ReportType,
	Report,
	TeamMember,
	Operation,
	TableName,
	TableKey,
	Column,
	ColumnValue )
values (
	@ReportType,
	@Report,
	@TeamMember,
	@Operation,
	@TableName,
	@TableKey,
	@Column,
	@ColumnValue )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into Filter table for key(s) "
	select @ErrorMessage = @ErrorMessage + "ReportType '" + convert(varchar(255), @ReportType) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "Report '" + convert(varchar(255), @Report) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "TableName '" + convert(varchar(255), @TableName) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "TableKey '" + convert(varchar(255), @TableKey) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "Column '" + convert(varchar(255), @Column) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode FilterInsert, unchained;
DROP PROCEDURE FilterUpdate;
--/
CREATE PROCEDURE FilterUpdate (
/**************************************************************************
**
** Procedure:	FilterUpdate
**
** Version: 	@(#)FilterUpdate.proc	63.1 08/06/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@ReportType  varchar(40)     ,
	@Report      varchar(75)    ,
	@TeamMember  varchar(75),
	@Operation   int = -2147483647,
	@TableName   varchar(255)          ,
	@TableKey    varchar(255)          ,
	@Column      varchar(255)          ,
	@ColumnValue varchar(255)    = "#$%@"
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @operation   int,
        @columnValue varchar(255)   
Select @operation = Operation,
       @columnValue = ColumnValue
from Filter
  where ReportType = @ReportType
  and Report = @Report
  and TeamMember = @TeamMember
  and TableName = @TableName
  and TableKey = @TableKey
  and Column = @Column
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from Filter table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from Filter table for key(s) "
	goto ERROR_EXIT
end
if @Operation != -2147483647
	select @operation = @Operation
if @ColumnValue != "#$%@"
	select @columnValue = @ColumnValue
Update Filter
set	Operation = @operation,
	ColumnValue = @columnValue
  where ReportType = @ReportType
  and Report = @Report
  and TeamMember = @TeamMember
  and TableName = @TableName
  and TableKey = @TableKey
  and Column = @Column
if @@error != 0
begin
	select @ErrorMessage = "Could not update Filter table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "ReportType '" + convert(varchar(255), @ReportType) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "Report '" + convert(varchar(255), @Report) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "TableName '" + convert(varchar(255), @TableName) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "TableKey '" + convert(varchar(255), @TableKey) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "Column '" + convert(varchar(255), @Column) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode FilterUpdate, unchained;
DROP PROCEDURE FirmAccount;
--/
CREATE PROCEDURE FirmAccount 
/*******************************************************************************
***
**
**
** Procedure : FirmAccount 
**
** Version   :    
**
** Notes     :
**
********************************************************************************
**/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select AccountNumber,Mnemonic,Firm,Desk,Location,Strategy,Substrategy,StrategyCode,SubstrategyCode,Restricted,GFCID,GFCIDLastModified,FirmAcctLastModified
from ADB..FirmAccountView


/
EXEC sp_procxmode FirmAccount, unchained;
DROP PROCEDURE GKBusinessGroups;
--/
CREATE PROCEDURE GKBusinessGroups
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "@(#)GKBusinessGroups.sp	130.1 06/25/09"
select "CodeType", "GKBusinessGroups", "ExternalCode", NULL, NULL, NULL
select "GKBusinessGroups", Code, ExternalCode, NULL, NULL, NULL
from CDB.dbo.Code 
where Type = 'ISDAGKBusinessGroups'


/
EXEC sp_procxmode GKBusinessGroups, unchained;
DROP PROCEDURE GR_ClassificationCode;
--/
CREATE PROCEDURE GR_ClassificationCode
/**************************************************************
** 
** Procedure: GR_ClassificationCode
**
** Version:   @(#)GR_ClassificationCode.proc	63.1  08/06/01
**
** Notes:
**
*************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "@(#)GR_ClassificationCode.proc	63.1  08/06/01"
begin
print ""
print ""
print "Tables: ClassificationCode, ClassificationSchema"
print "************************************************"
select Class, SchemaName
from ClassificationCode
where
	(not exists
	(select * from ClassificationSchema where
		Class=ClassificationCode.Class and
		SchemaName=ClassificationCode.SchemaName))
end


/
EXEC sp_procxmode GR_ClassificationCode, unchained;
DROP PROCEDURE GR_ConfigurationSegment;
--/
CREATE PROCEDURE GR_ConfigurationSegment
/**************************************************************
** 
** Procedure: GR_ConfigurationSegment
**
** Version:   @(#)GR_ConfigurationSegment.proc	63.1  08/06/01
**
** Notes:
**
*************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "@(#)GR_ConfigurationSegment.proc	63.1  08/06/01"
begin
print ""
print ""
print "Tables: ConfigurationSegment, TeamMember"
print "*********************************"
select TeamMember 
from ConfigurationSegment
where
	(not exists
	(select * from TeamMember where
		TeamMember=ConfigurationSegment.TeamMember))
end


/
EXEC sp_procxmode GR_ConfigurationSegment, unchained;
DROP PROCEDURE GR_Filter;
--/
CREATE PROCEDURE GR_Filter
/**************************************************************
** 
** Procedure: GR_Filter
**
** Version:   @(#)GR_Filter.proc	63.1  08/06/01
**
** Notes:
**
*************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "@(#)GR_Filter.proc	63.1  08/06/01"
begin
print ""
print ""
print "Tables: Filter, Report"
print "*****************************"
select ReportType, Report, TeamMember into #KEYS
from Filter
where
	(not exists
	(select * from Report R, Filter where
		R.ReportType=Filter.ReportType and
		R.Report = Filter.Report and
		(R.TeamMember=Filter.TeamMember or
		 (R.TeamMember is NULL))))
/* Adaptive Server has expanded all '*' elements in the following statement */ select #KEYS.ReportType, #KEYS.Report, #KEYS.TeamMember from #KEYS
end


/
EXEC sp_procxmode GR_Filter, unchained;
DROP PROCEDURE GR_ReportCustomization;
--/
CREATE PROCEDURE GR_ReportCustomization
/**************************************************************
** 
** Procedure: GR_ReportCustomization
**
** Version:   @(#)GR_ReportCustomization.proc	63.1  08/06/01
**
** Notes:
**
*************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "@(#)GR_ReportCustomization.proc	63.1  08/06/01"
begin
print ""
print ""
print "Tables: ReportCustomization, Report"
print "*****************************"
select ReportType, Report, TeamMember into #KEYS
from ReportCustomization
where
	(not exists
	(select * from Report R, ReportCustomization where
		R.ReportType=ReportCustomization.ReportType and
		R.Report=ReportCustomization.Report and
		(R.TeamMember=ReportCustomization.TeamMember or
		 R.TeamMember is NULL)))
end


/
EXEC sp_procxmode GR_ReportCustomization, unchained;
DROP PROCEDURE GR_ReportSegment;
--/
CREATE PROCEDURE GR_ReportSegment
/**************************************************************
** 
** Procedure: GR_ReportSegment
**
** Version:   @(#)GR_ReportSegment.proc	63.1  08/06/01
**
** Notes:
**
*************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "@(#)GR_ReportSegment.proc	63.1  08/06/01"
begin
print ""
print ""
print "Tables: ReportSegment, Report"
print "*****************************"
select ReportType, Report, TeamMember 
into #KEYS
from ReportSegment
where
	(not exists
	(select * from Report R, ReportSegment where
		R.ReportType=ReportSegment.ReportType and
		R.Report=ReportSegment.Report	and
		(R.TeamMember=ReportSegment.TeamMember or
		 (R.TeamMember is NULL))))
/* Adaptive Server has expanded all '*' elements in the following statement */ select #KEYS.ReportType, #KEYS.Report, #KEYS.TeamMember from #KEYS
end


/
EXEC sp_procxmode GR_ReportSegment, unchained;
DROP PROCEDURE GR_StructuredNoteSegment;
--/
CREATE PROCEDURE GR_StructuredNoteSegment
/**************************************************************
** 
** Procedure: GR_StructuredNoteSegment
**
** Version:   @(#)GR_StructuredNoteSegment.proc	63.1  08/06/01
**
** Notes:
**
*************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "@(#)GR_StructuredNoteSegment.proc	63.1  08/06/01"
begin
print ""
print ""
print "Tables: StructuredNoteSegment, StructuredNote"
print "**********************************************"
select Class, Type 
from StructuredNoteSegment
where
	(not exists
	(select * from StructuredNote where
		Class=StructuredNoteSegment.Class and
		Type=StructuredNoteSegment.Type))
end


/
EXEC sp_procxmode GR_StructuredNoteSegment, unchained;
DROP PROCEDURE GR_TeamMemberLimits;
--/
CREATE PROCEDURE GR_TeamMemberLimits
/**************************************************************
** 
** Procedure: GR_TeamMemberLimits
**
** Version:   @(#)GR_TeamMemberLimits.proc	63.1  08/06/01
**
** Notes:
**
*************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "@(#)GR_TeamMemberLimits.proc	63.1  08/06/01"
begin
print ""
print ""
print "Tables: TeamMemberLimits, TeamMember"
print "*********************************"
select TeamMember 
from TeamMemberLimits
where
	(not exists
	(select * from TeamMember where
		TeamMember=TeamMemberLimits.TeamMember))
end


/
EXEC sp_procxmode GR_TeamMemberLimits, unchained;
DROP PROCEDURE GR_TeamMemberPrivileges;
--/
CREATE PROCEDURE GR_TeamMemberPrivileges
/**************************************************************
** 
** Procedure: GR_TeamMemberPrivileges
**
** Version:   @(#)GR_TeamMemberPrivileges.proc	63.1  08/06/01
**
** Notes:
**
*************************************************************/
as
declare @version varchar(255)
select @version = "@(#)GR_TeamMemberPrivileges.proc	63.1  08/06/01"
begin
print ""
print ""
print "Tables: TeamMemberPrivileges, TeamMember"
print "*********************************"
select TeamMember 
from TeamMemberPrivileges
where
	(not exists
	(select * from TeamMember where
		TeamMember=TeamMemberPrivileges.TeamMember))
end


/
EXEC sp_procxmode GR_TeamMemberPrivileges, unchained;
DROP PROCEDURE GenerateEERSFile;
--/
CREATE PROCEDURE GenerateEERSFile
/**************************************************************
**
** Procedure:   GenerateEERSFile
**
** Version:     @(#)GenerateEERSFile.sp	134.3 08/04/11
**
** Notes:
**
*************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
/** EERS 'UserRole' file Format **/
-- App ID|Last Name|First Name|Login ID|RITS ID|GEID ID|Function Title Code|Function Title Code Description|SOE ID|Second level entitlement description|External Drill down Code
--drop table #usergroup
--drop table #userpriv
declare @ReadWrite varchar(25)
select @ReadWrite = 'ReadOnly'
select Code, Description
into #tmCodeTbl
from CDB..Code
where Type = 'TeamMemberPrivilege'
create table #groupAccessInd (
TeamMember varchar(75) not null,
ReadWrite   varchar(50) null)
/** Get all Groups in TEMP table and default them to 'ReadOnly' ***/
insert into #groupAccessInd
select DISTINCT tm.TeamMember, @ReadWrite
from CDB..TeamMember tm
where tm.TeamMemberType = 2
/** Merge #groupAccessInd, CDB..TeamMemberPrivileges and EMDB..Privilege
    to update if group contains Privileges with Write access. **/
update #groupAccessInd
set ReadWrite = 'ReadWrite'
from #groupAccessInd g,
    CDB..TeamMemberPrivileges tmp,
    #tmCodeTbl c
where g.TeamMember = tmp.TeamMember
    and tmp.TeamMemberPrivilege = c.Code
    and c.Description LIKE 'ReadWrite%' /** ReadWrite **/
    and g.ReadWrite = 'ReadOnly' /** Update ONLY once ***/
/** Update #groupAccessInd with 'Privilege ReadWrite' prefix if the
	individual entitlement is a Privileged one. ***/
update #groupAccessInd
set ReadWrite = 'Privilege ReadWrite'
from #groupAccessInd g,
    CDB..TeamMemberPrivileges tmp,
	#tmCodeTbl c
where g.TeamMember = tmp.TeamMember
	and c.Code = tmp.TeamMemberPrivilege
	and c.Description like 'Privilege ReadWrite%'
/** Update #groupAccessInd with 'MoneyTransfer Initiator ReadWrite' prefix if the
	individual entitlement is a Privileged one. ***/
update #groupAccessInd
set ReadWrite = 'MoneyTransfer Initiator ReadWrite'
from #groupAccessInd g,
    CDB..TeamMemberPrivileges tmp,
	#tmCodeTbl c
where g.TeamMember = tmp.TeamMember
	and c.Code = tmp.TeamMemberPrivilege
	and c.Description like 'MoneyTransfer Initiator ReadWrite%'
/** Update #groupAccessInd with 'MoneyTransfer Authorizer Privileged ReadWrite' prefix if the
	individual entitlement is a Privileged one. ***/
update #groupAccessInd
set ReadWrite = 'MoneyTransfer Authorizer Privileged ReadWrite'
from #groupAccessInd g,
    CDB..TeamMemberPrivileges tmp,
	#tmCodeTbl c
where g.TeamMember = tmp.TeamMember
	and c.Code = tmp.TeamMemberPrivilege
	and c.Description like 'MoneyTransfer Authorizer Privileged ReadWrite%'
/*** Get the Group details for a Particular USER from 'CDB..TeamMemberGroupLink' ***/
create table #usergroup ( LastName varchar(20) null, FirstName varchar(20) null,
		SybaseID varchar(10) null,
		EmployeeIdentification int null, TeamMemberGroup varchar(70) null)
insert into #usergroup
select 
	case
		when charindex(',', tm.TeamMember) = 0 then '' -- Set 'LastName' to NULL
		else rtrim(substring(tm.TeamMember, 1, charindex(',', tm.TeamMember) -1))
	end LastName,
  	ltrim(substring(tm.TeamMember, charindex(',', tm.TeamMember)+1,
					datalength(tm.TeamMember) - charindex(',', tm.TeamMember)) ) FirstName,
	tm.SybaseID, tm.EmployeeIdentification, tml.TeamMemberGroup
from CDB..TeamMemberGroupLink tml, CDB..TeamMember tm
where tm.TeamMember = tml.TeamMember
-- and (tm.TeamMember = 'Raghunath, Nikhil' or tm.TeamMember = 'Italia, Rustom')
and tm.TeamMemberType = 1 /*** We want ONLY USERS ***/
and tml.TeamMemberGroup not like '%exclude%' -- Exclude Firewall Groups to be sent to EERS.
/******* INDIVIDUAL PRIVILEGES ***************/
/** Since a USER can have Individual Privileges apart from GROUPS,
	we need to query CDB..TeamMemberPrivileges and CDB..Code.
**/
create table #userpriv ( LastName varchar(20) null, FirstName varchar(20) null, SybaseID varchar(10) null,
        EmployeeIdentification int null, TeamMemberPrivilege varchar(70) null)
insert into #userpriv
select
	case
		when charindex(',', tm.TeamMember) = 0 then '' -- Set 'LastName' to NULL
		else substring(tm.TeamMember, 1, charindex(',', tm.TeamMember) -1)
	end LastName,
	ltrim(substring(tm.TeamMember, charindex(',', tm.TeamMember)+1,
				datalength(tm.TeamMember)-charindex(',', tm.TeamMember)) ) FirstName,
	tm.SybaseID, tm.EmployeeIdentification, tmp.TeamMemberPrivilege
from CDB..TeamMemberPrivileges tmp, CDB..TeamMember tm
where tm.TeamMember = tmp.TeamMember
--	and (tm.TeamMember = 'Raghunath, Nikhil' or tm.TeamMember = 'Italia, Rustom')
	and tm.TeamMemberType = 1 /*** We want ONLY USERS ***/
/******* INDIVIDUAL DATA ACCESS PRIVILEGES ***************/
/** Since a USER can apply the privileges only on the LegalEntities entitled to ,
         we need to query CDB..TeamMemberDatAccessPrivileges table.
**/
---Get All Code listings for DAP--------------------
select Code, LongName
into  #tmp
from CDB..Code
where Type = 'FirmLegalEntity'
and ExternalCode <> null
/* Adaptive Server has expanded all '*' elements in the following statement */ select #tmp.Code, #tmp.LongName 
into #LegalEntity
from #tmp
insert into #LegalEntity
select Code,LongName 
from CDB..Code
where Type like 'LegalEntityGFCIDMapping'
and Code not in (select Code from #tmp)
update #LegalEntity set LongName = Code
where LongName = null
/* Adaptive Server has expanded all '*' elements in the following statement */ select  tmp.TeamMember, tmp.AccessObject, tmp.AccessPrivilege, tmp.AccessEntity, tmp.AccessEntityValue, tmp.FilterType, tmp.ApprovedBy, tmp.Approved, tmp.ApprovedTimeZone into #userdapllist
from CDB..TeamMemberDataAccessPrivileges tmp, CDB..TeamMember tm
where tm.TeamMember = tmp.TeamMember
        and tm.TeamMemberType = 1 and AccessEntity in ('LEGAL_ENTITY_LOCATION','FIRM_LEGAL_ENTITY')
select Code into #RestrictedEntity from CDB..Code where Type = 'RestrictedLegalEntity'
insert into #LegalEntity values('ALL','Access to all Legal entities')
update #userdapllist  set t.AccessEntityValue='Restricted:'+t.AccessEntityValue+':'+c1.LongName
from #userdapllist t,#LegalEntity c1,#RestrictedEntity r
where c1.Code=r.Code and t.AccessEntityValue=r.Code and t.AccessEntityValue=c1.Code  --and t.AccessEntity='FIRM_LEGAL_ENTITY'
update #userdapllist  set t.AccessEntityValue=t.AccessEntityValue+':'+c1.LongName
from #userdapllist t,#LegalEntity c1 
where  t.AccessEntityValue=c1.Code
-- Create the table for final extract
create table #userdappriv ( LastName varchar(20) null, FirstName varchar(20) null, SybaseID varchar(10) null,
        EmployeeIdentification int null, DataAccessObject varchar(255) null,Description varchar(255) null,AccessValue varchar(255) null)
--select * from #userdappriv where LastName='Cook'
insert into  #userdappriv
select
        case
                when charindex(',', tm.TeamMember) = 0 then ' ' -- Set 'LastName' to NULL
                else substring(tm.TeamMember, 1, charindex(',', tm.TeamMember) -1)
        end LastName,
        ltrim(substring(tm.TeamMember, charindex(',', tm.TeamMember)+1,
                                datalength(tm.TeamMember)-charindex(',', tm.TeamMember)) ) FirstName,
        tm.SybaseID, tm.EmployeeIdentification, 'LegalEntityAccess' as AccessObject,
'User is authorized to Legal Entity. This entitlement requires to associate with Privileged entitlement to perform action for the entitled Legal Entity. Review "Entitlement" column to see Legal Vehicle IDs.' as Description, 
tmp.AccessEntityValue as AccessValue
from #userdapllist tmp, CDB..TeamMember tm
where tm.TeamMember = tmp.TeamMember 
/** Now for Each GROUP in '#usergroup', get the corresponding 'Description' from 'CDB..TeamMember'
	since 'Group' is also a TEAMMEMBER.
**/
select '000263	' + ltrim(convert(varchar(20), ug.LastName)) + '	' +  rtrim(convert(varchar(20), str_replace(ug.FirstName, '	', ''))) + '	' + 
	convert(varchar(10), ug.SybaseID) + '	' + convert(varchar(20), ed.RITSID) + '	' +
	convert(varchar(20), ed.EmployeeIdentification) + '	' + convert(varchar(70), tm.TeamMember) + '	' +
	convert(varchar(50), g.ReadWrite) +  ':'+
	convert(varchar(490), tm.Description) + '	' + convert(varchar(10), ed.SOEID) + '		summ'
from CDB..TeamMember tm, #usergroup ug, CDB..EmployeeDetails ed, #groupAccessInd g
where tm.TeamMember = ug.TeamMemberGroup
    and ug.EmployeeIdentification = ed.EmployeeIdentification
	and tm.TeamMember = g.TeamMember
order by ug.LastName, ug.FirstName
/** Now for Each INDIVIDUAL PRIVILEGE in '#userpriv', get the corresponding 'Description' from 'CDB..Code'
	NOTE:: DONOT ADD 'summ' in the last field.
**/
/*** Since CDB..Code can have DUPLICATE 'Code' entries, use 'distinct' (E.g. AccessReportManager) ***/
select '000263	' + ltrim(convert(varchar(20), up.LastName)) + '	' + rtrim(convert(varchar(20), str_replace(up.FirstName, '	', ''))) + '	' +
	convert(varchar(10),up.SybaseID) + '	' + convert(varchar(20),ed.RITSID) + '	' +
	convert(varchar(20),ed.EmployeeIdentification) + '	' + convert(varchar(70),up.TeamMemberPrivilege) + '	' +
	convert(varchar(490),c.Description) + '	' + convert(varchar(10),ed.SOEID)
from CDB..Code c, #userpriv up, CDB..EmployeeDetails ed
where c.Type = 'TeamMemberPrivilege'
	and  up.TeamMemberPrivilege = c.Code
	and up.EmployeeIdentification = ed.EmployeeIdentification
order by up.LastName, up.FirstName
/** Now for Each INDIVIDUAL DATA ACCESS PRIVILEGE in #userdappriv get the Employee details and Print
**/
select '000263	' + ltrim(convert(varchar(20), up.LastName)) + '	' + rtrim(convert(varchar(20), str_replace(up.FirstName, '	', ''))) + '	' +
        convert(varchar(10),up.SybaseID) + '	' + convert(varchar(20),ed.RITSID) + '	' +
        convert(varchar(20),ed.EmployeeIdentification) + '	' + convert(varchar(70),up.DataAccessObject) + '	' +
        rtrim(convert(varchar(255), str_replace(up.Description, '	', ''))) + '	' + convert(varchar(10),ed.SOEID)+'	' + 
        convert(varchar(255),up.AccessValue)
from  #userdappriv up, EMDB..EmployeeDetails ed
where  up.EmployeeIdentification = ed.EmployeeIdentification
--UPPER(up.SybaseID) = UPPER(ed.SOEID)
order by up.LastName, up.FirstName
STORED_PROC_EXIT:


/
EXEC sp_procxmode GenerateEERSFile, unchained;
DROP PROCEDURE GenerateEERSGlossaryFile;
--/
CREATE PROCEDURE GenerateEERSGlossaryFile
/**************************************************************
**
** Procedure:   GenerateEERSFile
**
** Version:     %W% %G%
**
** Notes:
**
*************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
-- THIS SQL GENERATES THE GLOSSARY FILE: "glossary000263"
--declare @group varchar(75), @privilege varchar(75), @privileges varchar(1900), @rowcount int
select '"000263","FunctionCode","' + convert(varchar(70), Code) + '","' + convert(varchar(490), Description)  + '"'
from CDB..Code
where Type = 'TeamMemberPrivilege'
order by Code
STORED_PROC_EXIT:


/
EXEC sp_procxmode GenerateEERSGlossaryFile, unchained;
DROP PROCEDURE GenerateEERSPolicyFile;
--/
CREATE PROCEDURE GenerateEERSPolicyFile
/**************************************************************
**
** Procedure:   GenerateEERSFile
**
** Version:     %W% %G%
**
** Notes:
**
*************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
-- THIS SQL GENERATES THE Policy File: "SUM_000263_policies"
--drop table #groups
--drop table #grouppriv
--drop table #TeamMemberPrivilege
select TeamMember, TeamMemberPrivilege = convert(varchar(1900), TeamMemberPrivilege)
  into #grouppriv from CDB..TeamMemberPrivileges where 1=2
select DISTINCT tm.TeamMember
into #groups
from CDB..TeamMember tm
where tm.TeamMemberType = 2
select TeamMemberPrivilege
into #TeamMemberPrivilege from  CDB..TeamMemberPrivileges    
 where 1=2
set rowcount 1
while 1=1
  begin
    loopback:
    
declare @group varchar(75), @privilege varchar(75), @privileges varchar(1800), @rowcount int
    select @group = TeamMember from #groups
--    select  TeamMember from #groups
    
    if @@rowcount = 0
      break
      
    set rowcount 0  
	insert into #TeamMemberPrivilege
		select TeamMemberPrivilege
			from  CDB..TeamMemberPrivileges    
		    where TeamMember = @group
    set rowcount 1
    
    select @privileges = ''
    while 1 = 1 
      begin
      
        select @privilege = TeamMemberPrivilege  FROM #TeamMemberPrivilege 
          
--		if @privileges == ''
--			select @privileges = @privilege + ','
--		else
        	select @privileges = @privileges + @privilege + ','
        
        delete #TeamMemberPrivilege
        if @@rowcount = 0
        begin
--   drop table #TeamMemberPrivilege
         break
        end
      end
      
    insert #grouppriv
    select @group, substring(@privileges, 1, char_length(@privileges)-1)
    
    delete #groups
  end  
set rowcount 0
select '"000263","000263' + convert(varchar(70), TeamMember) + '","","' + '' + ltrim(convert(varchar(2000),TeamMemberPrivilege)) + '","000263' + TeamMember + '"'
 from #grouppriv
STORED_PROC_EXIT:


/
EXEC sp_procxmode GenerateEERSPolicyFile, unchained;
DROP PROCEDURE GenerateEERSRoleFile;
--/
CREATE PROCEDURE GenerateEERSRoleFile
/**************************************************************
**
** Procedure:   GenerateEERSFile
**
** Version:     @(#)GenerateEERSRoleFile.sp	134.3 08/04/11
**
** Notes:
**
*************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
-- THIS SQL GENERATES THE Role File: "role000263"
set nocount on
declare @ReadWrite varchar(25)
select @ReadWrite = "ReadOnly"
create table #groupAccessInd (
TeamMember varchar(75) not null,
ReadWrite	varchar(50) null)
select Code, Description
into #tmCodeTbl
from CDB..Code
where Type = 'TeamMemberPrivilege'
/** Get all Groups in TEMP table and default them to "ReadOnly" ***/
insert into #groupAccessInd
select DISTINCT tm.TeamMember, @ReadWrite
from CDB..TeamMember tm
where tm.TeamMemberType = 2
/** Merge #groupAccessInd, CDB..TeamMemberPrivileges and EMDB..Privilege
	to update if group contains Privileges with Write access. **/
update #groupAccessInd
set ReadWrite = "ReadWrite"
from #groupAccessInd g,
	CDB..TeamMemberPrivileges tmp,
	EMDB..Privilege p
where g.TeamMember = tmp.TeamMember
	and tmp.TeamMemberPrivilege = p.PrivilegeName
	and p.PrivilegesType = 2 /** ReadWrite **/
	and g.ReadWrite = "ReadOnly" /** Update ONLY once ***/
/** Update #groupAccessInd with "Privilege ReadWrite" prefix if the
    individual entitlement is a Privileged one. ***/
update #groupAccessInd
set ReadWrite = "Privilege ReadWrite"
from #groupAccessInd g,
    CDB..TeamMemberPrivileges tmp,
    #tmCodeTbl c
where g.TeamMember = tmp.TeamMember
    and c.Code = tmp.TeamMemberPrivilege
    and c.Description like 'Privilege ReadWrite%'
update #groupAccessInd
set ReadWrite = "Privilege ReadWrite"
from #groupAccessInd g,
    CDB..TeamMemberPrivileges tmp,
    #tmCodeTbl c
where g.TeamMember = tmp.TeamMember
    and c.Code = tmp.TeamMemberPrivilege
    and c.Description like 'Privileged ReadWrite%'
update #groupAccessInd
set ReadWrite = "MoneyTransfer Initiator ReadWrite"
from #groupAccessInd g,
    CDB..TeamMemberPrivileges tmp,
    #tmCodeTbl c
where g.TeamMember = tmp.TeamMember
    and c.Code = tmp.TeamMemberPrivilege
    and c.Description like 'MoneyTransfer Initiator ReadWrite%'
update #groupAccessInd
set ReadWrite = "MoneyTransfer Authorizer Privileged ReadWrite"
from #groupAccessInd g,
    CDB..TeamMemberPrivileges tmp,
    #tmCodeTbl c
where g.TeamMember = tmp.TeamMember
    and c.Code = tmp.TeamMemberPrivilege
    and c.Description like 'MoneyTransfer Authorizer Privileged ReadWrite%'
select '"000263' + convert(varchar(70), tm.TeamMember) + '","' + convert(varchar(50), g.ReadWrite) + ":" + convert(varchar(490), tm.Description) + '","' + convert(varchar(70), ed.SOEID) + '"'
from CDB..TeamMember tm, CDB..EmployeeDetails ed, #groupAccessInd g
where TeamMemberType = 2
and tm.Owner *= ed.TeamMember
and tm.TeamMember *= g.TeamMember
STORED_PROC_EXIT:


/
EXEC sp_procxmode GenerateEERSRoleFile, unchained;
DROP PROCEDURE GenerationSpecialist;
--/
CREATE PROCEDURE GenerationSpecialist
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "%W% %G%"
select "CodeType", "GenerationSpecialist", NULL, NULL, NULL, NULL
select "GenerationSpecialist", TeamMember, NULL, NULL, NULL, NULL
from CDB.dbo.TeamMemberGroupLink
where TeamMemberGroup like 'CWS-DocGenerator-grp'


/
EXEC sp_procxmode GenerationSpecialist, unchained;
DROP PROCEDURE GetAllDevelopersGroup;
--/
CREATE PROCEDURE GetAllDevelopersGroup
/**************************************************************************
**
** Procedure:    GetAllDevelopersGroup 
**
** Version:     GetAllDevelopersGroup 133.1 22/11/2010
**
** Notes:      Manualy Generated
**
**************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current/* Adaptive Server has expanded all '*' elements in the following statement */   
select distinct TeamMember.TeamMember, TeamMember.Department, TeamMember.SybaseID, TeamMember.EmployeeIdentification, TeamMember.EMailAddress, TeamMember.Telephone, TeamMember.CRC, TeamMember.CostCentre, TeamMember.PWD, TeamMember.OldPWD, TeamMember.PreExpired, TeamMember.Disabled, TeamMember.LoginAttempts, TeamMember.EntryDate, TeamMember.ExpiryDate, TeamMember.TeamMemberType, TeamMember.SiteminderAuthentication, TeamMember.FunctionalAccount, TeamMember.Owner, TeamMember.Description, TeamMember.FirstName, TeamMember.LastName, TeamMember.Supervisor, TeamMember.Region, TeamMember.Country, TeamMember.Location, TeamMember.BusinessAreaID, TeamMember.ApprovedBy, TeamMember.Approved, TeamMember.ApprovedTimeZone, TeamMember.CreatedBy, TeamMember.Created, TeamMember.CreatedTimeZone, TeamMember.BusinessLine, TeamMember.LastModifyBy, TeamMember.LastModify, TeamMember.LastModifyTimeZone                                from 
            CDB..TeamMember TeamMember, 
            CDB..TeamMemberPrivileges TeamMemberPrivileges, 
            CDB..TeamMemberGroupLink TeamMemberGroupLink, 
            CDB..Code Code 
    where TeamMember.Department in (select Code from Code where Type='TeamMemberDepartmentin')
        and TeamMember.TeamMemberType = 1
        and TeamMember.FunctionalAccount = null
        and TeamMember.SybaseID not like '%DELETED%'
        and TeamMemberGroupLink.TeamMember = TeamMember.TeamMember
        and TeamMemberPrivileges.TeamMember = TeamMemberGroupLink.TeamMemberGroup
        and Code.Code = TeamMemberPrivileges.TeamMemberPrivilege 
        and Code.Type = 'TeamMemberPrivilege' 
        and Code.Description like '%Read%Write%' 


/
EXEC sp_procxmode GetAllDevelopersGroup, unchained;
DROP PROCEDURE GetAllDevelopersTeamMember;
--/
CREATE PROCEDURE GetAllDevelopersTeamMember
/**************************************************************************
**
** Procedure:    GetAllDevelopersTeamMember 
**
** Version:     GetAllDevelopersTeamMember 133.1 22/11/2010
**
** Notes:      Manualy Generated
**
**************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current/* Adaptive Server has expanded all '*' elements in the following statement */   
select Distinct TeamMember.TeamMember, TeamMember.Department, TeamMember.SybaseID, TeamMember.EmployeeIdentification, TeamMember.EMailAddress, TeamMember.Telephone, TeamMember.CRC, TeamMember.CostCentre, TeamMember.PWD, TeamMember.OldPWD, TeamMember.PreExpired, TeamMember.Disabled, TeamMember.LoginAttempts, TeamMember.EntryDate, TeamMember.ExpiryDate, TeamMember.TeamMemberType, TeamMember.SiteminderAuthentication, TeamMember.FunctionalAccount, TeamMember.Owner, TeamMember.Description, TeamMember.FirstName, TeamMember.LastName, TeamMember.Supervisor, TeamMember.Region, TeamMember.Country, TeamMember.Location, TeamMember.BusinessAreaID, TeamMember.ApprovedBy, TeamMember.Approved, TeamMember.ApprovedTimeZone, TeamMember.CreatedBy, TeamMember.Created, TeamMember.CreatedTimeZone, TeamMember.BusinessLine, TeamMember.LastModifyBy, TeamMember.LastModify, TeamMember.LastModifyTimeZone                                from 
            CDB..TeamMember TeamMember, 
            CDB..TeamMemberPrivileges TeamMemberPrivileges, 
            CDB..Code Code 
    where TeamMember.Department in (select Code from Code where Type='TeamMemberDepartmentin' )   
        and TeamMember.TeamMemberType = 1
        and TeamMember.FunctionalAccount = null
        and TeamMember.SybaseID  not like '%DELETED%'
        and TeamMemberPrivileges.TeamMember = TeamMember.TeamMember
        and Code.Code = TeamMemberPrivileges.TeamMemberPrivilege
        and Code.Type = 'TeamMemberPrivilege' 
        and Code.Description like '%Read%Write%' 


/
EXEC sp_procxmode GetAllDevelopersTeamMember, unchained;
DROP PROCEDURE GetAllWords;
--/
CREATE PROCEDURE GetAllWords
/**************************************************************************
**
** Procedure:	GetAllWords
**
** Version: 	@(#)GetAllWords.proc	63.1 08/06/01
**
** Notes:	
**
**************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @ErrorMessage	varchar(255)
declare @version  varchar(255)
select  @version = "@(#)GetAllWords.proc	63.1 08/06/01"
/* Adaptive Server has expanded all '*' elements in the following statement */ select Word.Word from Word
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode GetAllWords, unchained;
DROP PROCEDURE GetCADElgGFCIDAccountMaster;
--/
CREATE PROCEDURE GetCADElgGFCIDAccountMaster 
/*******************************************************************************
***
**
**
** Procedure : GetCADElgGFCIDAccountMaster 
**
** Version   :    
**
** Notes     :
**
********************************************************************************
**/
as
select distinct GFCID into tempdb_dev..tempGFCID from ADB..CustomerAccount
insert into tempdb_dev..tempGFCID select distinct GFCID from ADB..FirmAccount
Create index idx_GFCID on tempdb_dev..tempGFCID(GFCID)
select distinct
g.GFCID,
CanadianReportingRequired,
CanadianDerivativeDealer,
MainCanadianAffiliate,
MainCanadianPerson ,
CanadaFedCanadianPerson,
CanadaFedCanadianAffiliate,
AlbertaCanadianPerson,
AlbertaCanadianAffiliate,
BritishColCanadianPerson,
BritishColCanadianAffiliate,
ManitobaCanadianPerson,
ManitobaCanadianAffiliate,
NewBrunsCanadianPerson ,
NewBrunsCanadianAffiliate ,
NewfoundlaCanadianPerson ,
NewfoundlaCanadianAffiliate ,
NovaScotiaCanadianPerson ,
NovaScotiaCanadianAffiliate ,
NorthwestCanadianPerson ,
NorthwestCanadianAffiliate ,
NunavutCanadianPerson ,
NunavutCanadianAffiliate ,
OntarioCanadianPerson ,
OntarioCanadianAffiliate ,
PrinceEdCanadianPerson ,
PrinceEdCanadianAffiliate ,
QuebecCanadianPerson ,
QuebecCanadianAffiliate ,
SaskatchCanadianPerson ,
SaskatchCanadianAffiliate ,
YukonCanadianPerson ,
YukonCanadianAffiliate,
LastModified
from 
ADB..GFCIDAccountMaster g,tempdb_dev..tempGFCID t
where g.GFCID = t.GFCID and (CanadianDerivativeDealer = 2 or CanadianReportingRequired = 2 or MainCanadianAffiliate = 2 or MainCanadianPerson  = 2)
drop table tempdb_dev..tempGFCID


/
EXEC sp_procxmode GetCADElgGFCIDAccountMaster, unchained;
DROP PROCEDURE GetCADElgGFCIDAccountMasterINC;
--/
CREATE PROCEDURE GetCADElgGFCIDAccountMasterINC
(
@lastModified datetime
)
/*******************************************************************************
***
**
**
** Procedure : GetCADElgGFCIDAccountMasterINC
**
** Version   :
**
** Notes     :
**
********************************************************************************
**/
as
select distinct GFCID into tempdb_dev..tempGFCID from ADB..CustomerAccount
insert into tempdb_dev..tempGFCID  select distinct GFCID from ADB..FirmAccount
Create index idx_GFCID on tempdb_dev..tempGFCID(GFCID)
select distinct
g.GFCID,
CanadianReportingRequired,
CanadianDerivativeDealer,
MainCanadianAffiliate,
MainCanadianPerson ,
CanadaFedCanadianPerson,
CanadaFedCanadianAffiliate,
AlbertaCanadianPerson,
AlbertaCanadianAffiliate,
BritishColCanadianPerson,
BritishColCanadianAffiliate,
ManitobaCanadianPerson,
ManitobaCanadianAffiliate,
NewBrunsCanadianPerson ,
NewBrunsCanadianAffiliate ,
NewfoundlaCanadianPerson ,
NewfoundlaCanadianAffiliate ,
NovaScotiaCanadianPerson ,
NovaScotiaCanadianAffiliate ,
NorthwestCanadianPerson ,
NorthwestCanadianAffiliate ,
NunavutCanadianPerson ,
NunavutCanadianAffiliate ,
OntarioCanadianPerson ,
OntarioCanadianAffiliate ,
PrinceEdCanadianPerson ,
PrinceEdCanadianAffiliate ,
QuebecCanadianPerson ,
QuebecCanadianAffiliate ,
SaskatchCanadianPerson ,
SaskatchCanadianAffiliate ,
YukonCanadianPerson ,
YukonCanadianAffiliate,
LastModified 
from ADB..GFCIDAccountMaster g, tempdb_dev..tempGFCID t
where g.GFCID = t.GFCID and (CanadianDerivativeDealer = 2 or CanadianReportingRequired = 2 or MainCanadianAffiliate = 2 or MainCanadianPerson  = 2)
and LastModified > @lastModified
drop table tempdb_dev..tempGFCID


/
EXEC sp_procxmode GetCADElgGFCIDAccountMasterINC, unchained;
DROP PROCEDURE GetClassificationByClass;
--/
CREATE PROCEDURE GetClassificationByClass (
/**************************************************************************
**
** Procedure:   GetClassificationByClass
**
** Version:     @(#)GetClassificationByClass.proc	63.1 08/06/01	
**
** Notes:       
**
**************************************************************************/
	@Class		varchar(255)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
        declare  @version  varchar(255)
        select     @version = "@(#)GetClassificationByClass.proc	63.1 08/06/01"
declare @ErrorMessage	varchar(255)
	/* Adaptive Server has expanded all '*' elements in the following statement */ select ClassificationSchema.Class, ClassificationSchema.SchemaName, ClassificationSchema.MultipleEntryIndicator, ClassificationSchema.Description, ClassificationSchema.CRC from ClassificationSchema where Class = @Class if @@rowcount = 0 goto STORED_PROCEDURE_EXIT /* Adaptive Server has expanded all '*' elements in the following statement */ select ClassificationCode.Class, ClassificationCode.SchemaName, ClassificationCode.Code, ClassificationCode.LongName, ClassificationCode.Description from ClassificationCode where Class = @Class
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode GetClassificationByClass, unchained;
DROP PROCEDURE GetClassificationByKey;
--/
CREATE PROCEDURE GetClassificationByKey (
/**************************************************************************
**
** Procedure:   GetClassificationByKey
**
** Version:     @(#)GetClassificationByKey.proc	63.1 08/06/01	
**
** Notes:       
**
**************************************************************************/
	@Class		varchar(255),
	@SchemaName	varchar(255)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
        declare  @version  varchar(255)
        select     @version = "@(#)GetClassificationByKey.proc	63.1 08/06/01"
declare @ErrorMessage	varchar(255)
	/* Adaptive Server has expanded all '*' elements in the following statement */ select ClassificationSchema.Class, ClassificationSchema.SchemaName, ClassificationSchema.MultipleEntryIndicator, ClassificationSchema.Description, ClassificationSchema.CRC from ClassificationSchema where Class = @Class and SchemaName = @SchemaName if @@rowcount = 0 goto STORED_PROCEDURE_EXIT /* Adaptive Server has expanded all '*' elements in the following statement */ select ClassificationCode.Class, ClassificationCode.SchemaName, ClassificationCode.Code, ClassificationCode.LongName, ClassificationCode.Description from ClassificationCode where Class = @Class and SchemaName = @SchemaName
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode GetClassificationByKey, unchained;
DROP PROCEDURE GetConfirmationHeaderByDocType;
--/
CREATE PROCEDURE GetConfirmationHeaderByDocType (
/**************************************************************************
**
** Procedure:   GetConfirmationHeaderByType
**
** Version:     @(#)GetConfirmationHeaderByDocType.proc	63.1 08/06/01
**
** Notes:       
**
*************************************************************************/
	@DocumentationType		varchar(40)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
        declare    @version   varchar(255)
        select     @version = "@(#)GetConfirmationHeaderByDocType.proc	63.1 08/06/01"
/* Adaptive Server has expanded all '*' elements in the following statement */ select ConfirmationHeader.DocumentationType, ConfirmationHeader.LegalEntity, ConfirmationHeader.CompanyName, ConfirmationHeader.Addr1, ConfirmationHeader.Addr2, ConfirmationHeader.Addr3, ConfirmationHeader.Addr4, ConfirmationHeader.LmTeleNumber, ConfirmationHeader.TeleNumber1, ConfirmationHeader.TeleNumber2, ConfirmationHeader.OperationsCenter, ConfirmationHeader.Addr5, ConfirmationHeader.TeleNumber3, ConfirmationHeader.TeleLabel1, ConfirmationHeader.TeleLabel2, ConfirmationHeader.TeleLabel3 from ConfirmationHeader where DocumentationType = @DocumentationType


/
EXEC sp_procxmode GetConfirmationHeaderByDocType, unchained;
DROP PROCEDURE GetConfirmationHeaderByKey;
--/
CREATE PROCEDURE GetConfirmationHeaderByKey (
/**************************************************************************
**
** Procedure:   GetConfirmationHeaderByType
**
** Version:     @(#)GetConfirmationHeaderByKey.proc	63.1 08/06/01
**
** Notes:       
**
*************************************************************************/
	@DocumentationType		varchar(40),
	@LegalEntity			varchar(255)
)
as 
 set compatibility_mode off 
        declare    @version   varchar(255)
        select     @version = "@(#)GetConfirmationHeaderByKey.proc	63.1 08/06/01"
/* Adaptive Server has expanded all '*' elements in the following statement */ select ConfirmationHeader.DocumentationType, ConfirmationHeader.LegalEntity, ConfirmationHeader.CompanyName, ConfirmationHeader.Addr1, ConfirmationHeader.Addr2, ConfirmationHeader.Addr3, ConfirmationHeader.Addr4, ConfirmationHeader.LmTeleNumber, ConfirmationHeader.TeleNumber1, ConfirmationHeader.TeleNumber2, ConfirmationHeader.OperationsCenter, ConfirmationHeader.Addr5, ConfirmationHeader.TeleNumber3, ConfirmationHeader.TeleLabel1, ConfirmationHeader.TeleLabel2, ConfirmationHeader.TeleLabel3 
from ConfirmationHeader 
where DocumentationType = @DocumentationType
and LegalEntity=@LegalEntity


/
EXEC sp_procxmode GetConfirmationHeaderByKey, unchained;
DROP PROCEDURE GetCorpusMappings;
--/
CREATE PROCEDURE GetCorpusMappings 
/**************************************************************************
**
** Procedure:	GetCorpusMappings
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @ErrorMessage	varchar(255)
/* Adaptive Server has expanded all '*' elements in the following statement */ select CorpusMap.ParentClassID, CorpusMap.ChildClassID, CorpusMap.SinglePayRecDir, CorpusMap.ShortCorpus, CorpusMap.LongCorpus, CorpusMap.TotalCorpus, CorpusMap.IsAutoAdded, CorpusMap.UndefinedCorpus from CorpusMap
goto STORED_PROCEDURE_EXIT
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode GetCorpusMappings, unchained;
DROP PROCEDURE GetCustomMsgByAppName;
--/
CREATE PROCEDURE GetCustomMsgByAppName(
/**********************************************************************************
**
**
** Procedure : GetCustomMsgByAppName
**
** Version   : %W% %G%
**
** Notes     :
**
**********************************************************************************/
        @processingApplicationName varchar(255),
        @messagePurpose            varchar(255),
        @activeMessage             int        
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
        declare  @version  varchar(255)
        select   @version = "%W% %G%"
        /* Adaptive Server has expanded all '*' elements in the following statement */ select CDB..CustomMessage.MessageID, CDB..CustomMessage.ProcessingApplicationName, CDB..CustomMessage.MessagePurpose, CDB..CustomMessage.CustomMessage, CDB..CustomMessage.CustomMessageSize, CDB..CustomMessage.ActiveMessage from CDB..CustomMessage 
         where ProcessingApplicationName = @processingApplicationName 
           and MessagePurpose = @messagePurpose 
           and ActiveMessage = @activeMessage
        if @@rowcount = 0 goto STORED_PROCEDURE_EXIT
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode GetCustomMsgByAppName, unchained;
DROP PROCEDURE GetCustomizeTeamMemberDAP;
--/
CREATE PROCEDURE GetCustomizeTeamMemberDAP(
/**************************************************************************
**
** Procedure:   GetCustomizeTeammemberDAP
**
** Version:   	%W% %G% 
**
** Notes:       Automatically Generated
**
**************************************************************************/
 @TeamMember varchar(75)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current/* Adaptive Server has expanded all '*' elements in the following statement */   
select distinct c.TeamMember, c.AccessObject, c.AccessPrivilege, c.AccessEntity, c.AccessEntityValue, c.FilterType, c.ApprovedBy, c.Approved, c.ApprovedTimeZone                      
into #DAP1
from CDB..TeamMember a,
     CDB..TeamMemberGroupLink b,
     CDB..TeamMemberDataAccessPrivileges c
where a.TeamMember = b.TeamMember
and   b.TeamMemberGroup = c.TeamMember
and   c.AccessEntity in ('LEGAL_ENTITY_LOCATION','FIRM_LEGAL_ENTITY')
and   a.TeamMember = @TeamMember
update #DAP1 set TeamMember = @TeamMember
/* Adaptive Server has expanded all '*' elements in the following statement */ insert into #DAP1
select distinct b.TeamMember, b.AccessObject, b.AccessPrivilege, b.AccessEntity, b.AccessEntityValue, b.FilterType, b.ApprovedBy, b.Approved, b.ApprovedTimeZone
from CDB..TeamMember a,
     CDB..TeamMemberDataAccessPrivileges b
where a.TeamMember = b.TeamMember
and   b.AccessEntity in ('LEGAL_ENTITY_LOCATION','FIRM_LEGAL_ENTITY')
and   a.TeamMember = @TeamMember
/* Adaptive Server has expanded all '*' elements in the following statement */ select distinct #DAP1.TeamMember, #DAP1.AccessObject, #DAP1.AccessPrivilege, #DAP1.AccessEntity, #DAP1.AccessEntityValue, #DAP1.FilterType, #DAP1.ApprovedBy, #DAP1.Approved, #DAP1.ApprovedTimeZone
into #DAP
from #DAP1
--select all records where AccessObject is not ALL
 select AccessObject, 
        AccessEntity,
        AccessEntityValue into #TeamMember
 from  #DAP 
 where TeamMember = @TeamMember 
 and AccessObject !='ALL'
insert into #TeamMember
--select all records where AccessObject is ALL but AccessEntity is not LEGAL_ENTITY_LOCATION
select code.Code,
      TMDAP.AccessEntity,
      TMDAP.AccessEntityValue 
 from CDB..Code code,
  #DAP TMDAP 
 where TMDAP.TeamMember = @TeamMember 
  and TMDAP.AccessObject ='ALL' 
  and TMDAP.AccessEntity !='LEGAL_ENTITY_LOCATION'
  and code.Type='AccessObject' 
  and code.Code !='ALL' 
insert into #TeamMember
--select all records where AccessObject is ALL but AccessEntity is LEGAL_ENTITY_LOCATION
--and AccessEntityValue is not ALL and convert them into FIRM_LEGAL_ENTITY
select code.Code,
    code1.ExternalCode,
    code2.ExternalCode 
 from CDB..Code code,
    CDB..Code code1,
    CDB..Code code2, 
     #DAP TMDAP 
 where TMDAP.TeamMember = @TeamMember 
    and TMDAP.AccessObject ='ALL'
    and TMDAP.AccessEntity = 'LEGAL_ENTITY_LOCATION' 
    and TMDAP.AccessEntityValue <> 'ALL'
    and code.Code !='ALL' 
    and code.Type='AccessObject'
    and code1.Type = 'AccessEntity' 
    and code1.Code = 'LEGAL_ENTITY_LOCATION'
    and code2.Type = 'LegalEntityLocation' 
    and code2.Code = TMDAP.AccessEntityValue
insert into #TeamMember
--select all records where AccessObject is ALL but AccessEntity is LEGAL_ENTITY_LOCATION
--and AccessEntityValue is ALL and convert them into FIRM_LEGAL_ENTITY
select code.Code,
        code1.ExternalCode,
        'ALL'
    from CDB..Code code,
    CDB..Code code1, 
    #DAP TMDAP
 where TMDAP.TeamMember = @TeamMember 
    and TMDAP.AccessObject ='ALL'
    and TMDAP.AccessEntity = 'LEGAL_ENTITY_LOCATION' 
    and TMDAP.AccessEntityValue = 'ALL'
    and code.Code !='ALL' 
    and code.Type='AccessObject'
    and code1.Type = 'AccessEntity' 
    and code1.Code = 'LEGAL_ENTITY_LOCATION'
 /* Adaptive Server has expanded all '*' elements in the following statement */ select distinct #TeamMember.AccessObject, #TeamMember.AccessEntity, #TeamMember.AccessEntityValue
 into #TeamMember2
 from #TeamMember
 /* Adaptive Server has expanded all '*' elements in the following statement */ select #TeamMember2.AccessObject, #TeamMember2.AccessEntity, #TeamMember2.AccessEntityValue from #TeamMember2 order by AccessObject
 drop table #TeamMember2
 drop table #TeamMember
 drop table #DAP
 drop table #DAP1


/
EXEC sp_procxmode GetCustomizeTeamMemberDAP, unchained;
DROP PROCEDURE GetDARestrictedPrivileges;
--/
CREATE PROCEDURE GetDARestrictedPrivileges
/**************************************************************************
**
** Procedure:   RestrictedDAEDelete
**
** Version:     %W% %G%
**
** Notes:       Automatically Generated
**
**************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
select RDE.AccessObject, RDE.AccessEntity,RDE.AccessEntityValue 
 from CDB..RestrictedDataAccesEntity RDE where RDE.AccessObject !='ALL'
union
select code.Code,TMDAE.AccessEntity,TMDAE.AccessEntityValue 
 from CDB..Code code,CDB..RestrictedDataAccesEntity TMDAE 
 where code.Type='AccessObject'
 and TMDAE.AccessObject ='ALL' and code.Code !='ALL'


/
EXEC sp_procxmode GetDARestrictedPrivileges, unchained;
DROP PROCEDURE GetDerivElgGFCIDAccountMaster;
--/
CREATE PROCEDURE GetDerivElgGFCIDAccountMaster 
/*******************************************************************************
***
**
**
** Procedure : GetDerivElgGFCIDAccountMaster 
**
** Version   :    
**
** Notes     :
**
********************************************************************************
**/
as
select distinct GFCID into #tmp from ADB..CustomerAccount
insert into #tmp select distinct GFCID from ADB..FirmAccount
select distinct 
g.GFCID,
USPersonFlag,
LegalEntityIdentifier,
BenOwnerGFCID,
SECRegSwapDealer,
SECRegMajorSwapParticipant,
CFTCRegSwapDealer,
CFTCRegMajorSwapParticipant,
GFPID,
ParentGFCID,
TypeOfGFCID,
FinancialRiskLevel, 
SpecialEntityFlag,
LegalVehicleID,
ISDAAmendmentCompliant,
LDSDCommodities,
LDSDCredits,
LDSDRates,
LDSDEquities,
LDSDFX,
ReportingPartyOverride,
EMIRClassification,
EUPersonFlag,
EEAPersonFlag,
UTICreator,
DirectLinkToCAORTreasuryFinancingInd,
EMIRDealerFlag,
EMIRReportingConsent,
TradingCapacity,
PortfolioReconSpecifiedTerms,
PortfolioReconThirdPartySProvider,
ISDANFCAdherenceStatus,
ISDAPortfolioReconAndDisclosureStatus,
JurisdictionZone,
EmergingMarketExemption,
ForeignBranchOfUSBank,
GuaranteedAffiliate,
ConduitAffiliate,
ISDAProtocol1,
CBNAProtocol1,
CBNAProtocol2,
CEIProtocol1,
CEIProtocol2,
CGMIProtocol1,
CGMIProtocol2,
CGMLProtocol1,
CGMLProtocol2,
CGMLGuaranteed,
LastModified,
AIFMDClassification,
USCoverageCGML,
HireActProtocol
from 
ADB..GFCIDAccountMaster g, #tmp t
where g.GFCID = t.GFCID


/
EXEC sp_procxmode GetDerivElgGFCIDAccountMaster, unchained;
DROP PROCEDURE GetDisabledSybaseIDs;
--/
CREATE PROCEDURE GetDisabledSybaseIDs(
/**************************************************************************
**
** Procedure:   GetDisabledSybaseIDs
**
** Version:    @(#)GetDisabledSybaseIDs.sp	116.1 04/29/04
**
** Notes:
**
**************************************************************************/
	@FromDate       int,
	@ToDate     	int
) as
set compatibility_mode off  
set plan optgoal allrows_oltp 
set plan optlevel ase_current
select distinct vl.SybaseID
from 
	ViolationLog vl
where 
	convert(int,convert(char(8),vl.ViolationTimeGMT,112)) >= @FromDate
and convert(int,convert(char(8),vl.ViolationTimeGMT,112)) <= @ToDate
and vl.ViolationType = 'DisabledID'
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode GetDisabledSybaseIDs, unchained;
DROP PROCEDURE GetEmployeeDetailsByEmployeeID;
--/
CREATE PROCEDURE GetEmployeeDetailsByEmployeeID (
/*************************************************************************
**
** Procedure:   GetEmployeeDetailsByEmployeeID
**
** Version:     @(#)GetEmployeeDetailsByEmployeeID.proc	63.1 08/06/01	
**
** Notes:       
**
**************************************************************************/
	@EmployeeIdentification	int
)
as
        declare    @version   varchar(255)
        select     @version = "@(#)GetEmployeeDetailsByEmployeeID.proc	63.1 08/06/01"
declare @ErrorMessage	varchar(255)
/* Adaptive Server has expanded all '*' elements in the following statement */ select CDB..EmployeeDetails.TeamMember, CDB..EmployeeDetails.SOEID, CDB..EmployeeDetails.EmployeeIdentification, CDB..EmployeeDetails.Department, CDB..EmployeeDetails.EMailAddress, CDB..EmployeeDetails.Telephone, CDB..EmployeeDetails.Fax, CDB..EmployeeDetails.Location, CDB..EmployeeDetails.RITSID, CDB..EmployeeDetails.CostCentre, CDB..EmployeeDetails.Title, CDB..EmployeeDetails.LastModifiedTimeStamp, CDB..EmployeeDetails.FirstName, CDB..EmployeeDetails.LastName, CDB..EmployeeDetails.Supervisor, CDB..EmployeeDetails.Region, CDB..EmployeeDetails.Country from CDB..EmployeeDetails where EmployeeIdentification = @EmployeeIdentification
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode GetEmployeeDetailsByEmployeeID, unchained;
DROP PROCEDURE GetEmployeeDetailsByGEID;
--/
CREATE PROCEDURE GetEmployeeDetailsByGEID (
/*************************************************************************
**
** Procedure:   GetEmployeeDetailsByGEID
**
** Version:     @(#)GetEmployeeDetailsByGEID.proc	63.1 08/06/01	
**
** Notes:       
**
**************************************************************************/
	@EmployeeIdentification	int
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
        declare    @version   varchar(255)
        select     @version = "@(#)GetEmployeeDetailsByGEID.proc	63.1 08/06/01"
declare @ErrorMessage	varchar(255)
/* Adaptive Server has expanded all '*' elements in the following statement */ select CDB..EmployeeDetails.TeamMember, CDB..EmployeeDetails.SOEID, CDB..EmployeeDetails.EmployeeIdentification, CDB..EmployeeDetails.Department, CDB..EmployeeDetails.EMailAddress, CDB..EmployeeDetails.Telephone, CDB..EmployeeDetails.Fax, CDB..EmployeeDetails.Location, CDB..EmployeeDetails.RITSID, CDB..EmployeeDetails.CostCentre, CDB..EmployeeDetails.Title, CDB..EmployeeDetails.LastModifiedTimeStamp, CDB..EmployeeDetails.FirstName, CDB..EmployeeDetails.LastName, CDB..EmployeeDetails.Supervisor, CDB..EmployeeDetails.Region, CDB..EmployeeDetails.Country from CDB..EmployeeDetails where EmployeeIdentification = @EmployeeIdentification
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode GetEmployeeDetailsByGEID, unchained;
DROP PROCEDURE GetEmployeeDetailsByName;
--/
CREATE PROCEDURE GetEmployeeDetailsByName (
/*************************************************************************
**
** Procedure:   GetEmployeeDetailsByName
**
** Version:     @(#)GetEmployeeDetailsByName.proc	63.1 08/06/01	
**
** Notes:       
**
**************************************************************************/
	@TeamMember	varchar(75)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
        declare    @version   varchar(255)
        select     @version = "@(#)GetEmployeeDetailsByName.proc	63.1 08/06/01"
declare @ErrorMessage	varchar(255)
/* Adaptive Server has expanded all '*' elements in the following statement */ select CDB..EmployeeDetails.TeamMember, CDB..EmployeeDetails.SOEID, CDB..EmployeeDetails.EmployeeIdentification, CDB..EmployeeDetails.Department, CDB..EmployeeDetails.EMailAddress, CDB..EmployeeDetails.Telephone, CDB..EmployeeDetails.Fax, CDB..EmployeeDetails.Location, CDB..EmployeeDetails.RITSID, CDB..EmployeeDetails.CostCentre, CDB..EmployeeDetails.Title, CDB..EmployeeDetails.LastModifiedTimeStamp, CDB..EmployeeDetails.FirstName, CDB..EmployeeDetails.LastName, CDB..EmployeeDetails.Supervisor, CDB..EmployeeDetails.Region, CDB..EmployeeDetails.Country from CDB..EmployeeDetails where TeamMember = @TeamMember
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode GetEmployeeDetailsByName, unchained;
DROP PROCEDURE GetEmployeeDetailsBySOEID;
--/
CREATE PROCEDURE GetEmployeeDetailsBySOEID (
	@SOEID varchar(100)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
select TeamMember, SOEID, EmployeeIdentification, 
       Department, EMailAddress, Telephone, 
       Fax, Location, RITSID, CostCentre, 
       Title, LastModifiedTimeStamp, FirstName, 
       LastName, Supervisor, Region, 
       Country 
from CDB..EmployeeDetails ed
where ed.SOEID = lower(@SOEID)
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode GetEmployeeDetailsBySOEID, unchained;
DROP PROCEDURE GetEnumerationValues;
--/
CREATE PROCEDURE GetEnumerationValues(
/**********************************************************************************
**
**
** Procedure : GetEnumerations
**
** Version   :    @(#)GetEnumerations.sp	123.1 10/06/06
**
** Notes     :
**
**********************************************************************************/
	@Type  varchar(255)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
        declare    @version   varchar(255)
        select     @version = "@(#)CodeGet.proc	63.1 08/06/01"
/* Adaptive Server has expanded all '*' elements in the following statement */ select Enumeration.EnumerationName, Enumeration.EnumerationValue, Enumeration.ShortName, Enumeration.Description, Enumeration.LongName, Enumeration.Identifier from Enumeration where EnumerationName = @Type
order by EnumerationValue


/
EXEC sp_procxmode GetEnumerationValues, unchained;
DROP PROCEDURE GetExceptionRecords;
--/
CREATE PROCEDURE GetExceptionRecords (@epps int) AS
set compatibility_mode off  
set plan optgoal allrows_oltp 
set plan optlevel ase_current
SELECT ExceptionID, ExceptionKey,ExceptionProcess, ApplicationName, ExceptionTeamMember, ExceptionTime, 
ExceptionProcessSystem, ProcessStatus, ProcessedTime, ReprocessFailureReason, BatchTeamMember, Location, Option2, Option3, Option4
FROM CDB..ExceptionHandling 
WHERE ProcessStatus = @epps 


/
EXEC sp_procxmode GetExceptionRecords, unchained;
DROP PROCEDURE GetFirmLegalEntity;
--/
CREATE PROCEDURE GetFirmLegalEntity
/**********************************************************************************
**
**
** Procedure : GetFirmLegalEntity
**
** Version   :    %W% %G%
**
** Notes     :
**
**********************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select @version = "%W% %G%"
declare @ErrorMessage   varchar(255)
select Code, LongName, Description 
from CDB..Code 
where Type = 'FirmLegalEntity'


/
EXEC sp_procxmode GetFirmLegalEntity, unchained;
DROP PROCEDURE GetGroupByPrefix;
--/
CREATE PROCEDURE GetGroupByPrefix(
/**********************************************************************************
**
** Procedure : GetGroupByPrefix
** Version   : @(#)GetGroupByPrefix.sp	119.1 06/14/05
** Notes     : Returns groups from TeamMember Table where the Group prefix matches
**		given string. If the input string is null/empty, all groups 
		will be returned
**
**********************************************************************************/
	@BeginsWithStr     varchar(255)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "@(#)GetGroupByPrefix.sp	119.1 06/14/05"
declare @str varchar(255)
if(@BeginsWithStr = "")
	select @str = "CWS_RES_GROUPS"
else
	select @str = @BeginsWithStr + "_RES_GROUPS"
select "CodeType", "GetGroupByPrefix", NULL, NULL, NULL, NULL
select distinct "GetGroupByPrefix", Code, NULL, NULL, NULL, NULL
from CDB.dbo.Code
where Type = @str


/
EXEC sp_procxmode GetGroupByPrefix, unchained;
DROP PROCEDURE GetHolidayByCalendar;
--/
CREATE PROCEDURE GetHolidayByCalendar (
/**************************************************************************
**
** Procedure:   GetHolidayByCalendar
**
** Version:     @(#)GetHolidayByCalendar.proc	63.1 08/06/01	
**
** Notes:       
**
**************************************************************************/
	@Calendar	int
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
        declare  @version  varchar(255)
        select     @version = "@(#)GetHolidayByCalendar.proc	63.1 08/06/01"
declare @ErrorMessage	varchar(255)
	/* Adaptive Server has expanded all '*' elements in the following statement */ select Holiday.Calendar, Holiday.Holiday, Holiday.HolidayName, Holiday.CRC from Holiday where Calendar = @Calendar /* Adaptive Server has expanded all '*' elements in the following statement */ select HolidayDefinition.Calendar, HolidayDefinition.Weekend, HolidayDefinition.CalendarName from HolidayDefinition where Calendar = @Calendar
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode GetHolidayByCalendar, unchained;
DROP PROCEDURE GetLegalEnityByRegion;
--/
CREATE PROCEDURE GetLegalEnityByRegion
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
        select 'CodeType','LegalEntityRegion',null,null,null,null
        select 
                'LegalEntityRegion',
                LegalEntityShortName,
                case
                        when Region = 'NAM' then 'NY'
                        when Region = 'EMEA' then 'LN'
                        when Region = 'ASPAC' then 'TK'
                        when Region = 'LATAM' then 'NY'
                end as Region,null,null,null  
        from ADB..LegalEntity


/
EXEC sp_procxmode GetLegalEnityByRegion, unchained;
DROP PROCEDURE GetMetaDataByTableName;
--/
CREATE PROCEDURE GetMetaDataByTableName
/**********************************************************************************
**
**
** Procedure : 	GetMetaDataByTableName
**
** Version   :  "@(#)GetMetaDataByTableName.sp	123.1 09/07/06" 
**
** Notes     :
**
**********************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare  @version varchar(255)
select @version = "%W 09/07/06"
/* Adaptive Server has expanded all '*' elements in the following statement */ select TableMetaData.TableName, TableMetaData.ColumnNumber, TableMetaData.ColumnName, TableMetaData.DataType, TableMetaData.ApplicableForConfirms from TableMetaData


/
EXEC sp_procxmode GetMetaDataByTableName, unchained;
DROP PROCEDURE GetOasysActiveIds;
--/
CREATE PROCEDURE GetOasysActiveIds(
     @ExternalSystem         varchar(40),
     @ExternalTradeNumber    varchar(25)
)
as 
 set compatibility_mode off 
declare         @version  varchar(255)
select @version = "%W% %G%"
declare @ErrorMessage   varchar(255)
select e.Deal, e.TransactionID, e.ProductCorpus, e.ExternalTradeNumber
into #tt
from ODB..ExternalTransactionCorrelation e where 2=1
create index Idx on #tt (Deal, TransactionID, ProductCorpus, ExternalTradeNumber)
insert into #tt  
select t.Deal, t.TransactionID, e1.ProductCorpus, e1.ExternalTradeNumber
from
ODB..ExternalTransactionCorrelation e,
ODB..ExternalTransactionCorrelation e1,
ODB..TransactionTable t
where e.ExternalSystem = @ExternalSystem
and e.ExternalTradeNumber = @ExternalTradeNumber
and e.Deal = t.Deal
and e1.Deal = t.Deal
and e1.TransactionID = t.TransactionID
and e1.ExternalSystem = e.ExternalSystem
and t.TradeStatus = 2 
and t.EarlyTerminationDate is null
union 
select t.Deal, t.TransactionID, e1.ProductCorpus, e1.ExternalTradeNumber
from
ODB..ExternalTransactionCorrelation e,
ODB..ExternalTransactionCorrelation e1,
ODB..TransactionTable t
where e.ExternalSystem = @ExternalSystem
and e.ExternalTradeNumber = @ExternalTradeNumber
and e.Deal = t.Deal
and e1.Deal = t.Deal
and e1.TransactionID = t.TransactionID
and e1.ExternalSystem=e.ExternalSystem
and t.TradeTerminationReason in (2, 3, 4)
union
select t.Deal, t.TransactionID, e.ProductCorpus, e.ExternalTradeNumber
from
ODB..ExternalTransactionCorrelation e,
ODB..TransactionTable t
where e.ExternalSystem = @ExternalSystem
and e.ExternalTradeNumber = @ExternalTradeNumber
and e.Deal = t.Deal
and e.Deal = t.Deal
and e.TransactionID = t.TransactionID
and t.ProductClass = 40
and t.TradeStatus = 2
and t.EarlyTerminationDate is null
union
select t.Deal, t.TransactionID, e.ProductCorpus, e.ExternalTradeNumber
from
ODB..ExternalTransactionCorrelation e,
ODB..TransactionTable t
where e.ExternalSystem=@ExternalSystem
and e.ExternalTradeNumber = @ExternalTradeNumber
and e.Deal = t.Deal
and e.Deal = t.Deal
and e.TransactionID = t.TransactionID
and t.ProductClass = 40
and t.TradeTerminationReason in (1, 2, 3, 4)
select Deal, TransactionID, ProductCorpus, ExternalTradeNumber
from #tt
truncate table #tt
drop table #tt


/
EXEC sp_procxmode GetOasysActiveIds, unchained;
DROP PROCEDURE GetOasysFeeTxnIds;
--/
CREATE PROCEDURE GetOasysFeeTxnIds(
/**********************************************************************************
**
**
** Procedure : GetOasysFeeTxnIds
**
** Version   :    %W% %G%
**
** Notes     :
**
**********************************************************************************/
     @ExternalSystem         varchar(40),
     @ExternalTradeNumber    varchar(25)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select @version = "%W% %G%"
declare @ErrorMessage   varchar(255)
select distinct t.Deal, t.TransactionID, e1.ProductCorpus, e1.ExternalTradeNumber
from 
ODB..ExternalTransactionCorrelation e, 
ODB..ExternalTransactionCorrelation e1, 
ODB..TransactionTable t
where e.ExternalSystem=@ExternalSystem
and e.ExternalTradeNumber = @ExternalTradeNumber
and e.Deal = t.Deal 
and e1.Deal = t.Deal 
and e1.TransactionID = t.TransactionID 
and t.ProductClass = 16
and e1.ExternalSystem=e.ExternalSystem
and ( (t.TradeStatus = 2 and t.EarlyTerminationDate is null)
		or
      (t.TradeTerminationReason in (1, 2, 3, 4, 15, 22) ) )


/
EXEC sp_procxmode GetOasysFeeTxnIds, unchained;
DROP PROCEDURE GetOasysIds;
--/
CREATE PROCEDURE GetOasysIds(
/**********************************************************************************
**
**
** Procedure : GetOasysIds
**
** Version   :    %W% %G%
**
** Notes     :
**
**********************************************************************************/
     @ExternalSystem         varchar(40),
     @ExternalTradeNumber    varchar(25)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select @version = "%W% %G%"
declare @ErrorMessage   varchar(255)
select distinct t.Deal, t.TransactionID, e1.ProductCorpus, e1.ExternalTradeNumber
from 
ODB..ExternalTransactionCorrelation e, 
ODB..ExternalTransactionCorrelation e1, 
ODB..TransactionTable t
where e.ExternalSystem=@ExternalSystem
and e.ExternalTradeNumber = @ExternalTradeNumber
and e.Deal = t.Deal 
and e1.Deal = t.Deal 
and e1.TransactionID = t.TransactionID 
and t.ProductClass != 16
and e1.ExternalSystem=e.ExternalSystem
and ( (t.TradeStatus = 2 and t.EarlyTerminationDate is null)
		or
      (t.TradeTerminationReason in (1, 2, 3, 4, 6, 15, 22) ) )


/
EXEC sp_procxmode GetOasysIds, unchained;
DROP PROCEDURE GetPIndexObsByQuoteDate;
--/
CREATE PROCEDURE GetPIndexObsByQuoteDate (
/**************************************************************
** 
** Procedure: 	GetPIndexObsByQuoteDate
**
** Version:    	%W% %G%
**
** Notes:
**
*************************************************************/
	@QuoteDate int,
	@Name varchar(255),
	@NullRewRates int = NULL
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "%W% %G%"
select "CodeType", "PaymentIndices", NULL, NULL, NULL, NULL
if(@NullRewRates = 1 )
begin
        select distinct "PaymentIndices",IndexName,NULL,NULL,NULL,NULL
        from PDB..PaymentIndexObservation P,MDDB..MarketDataDefinition M,
	ODB..CashFlowCorpus C, ODB..TransactionTable T, ODB..Deal D
        where IndexQuoteDate=@QuoteDate
        and M.MarketDataObjectName = P.IndexName
        and M.Class = 6
	and P.Deal = C.Deal
	and P.TransactionID = C.TransactionID
	and P.ProductCorpus = C.ProductCorpus
	and (C.RateIndexAccessOperability != 1 or C.RateIndexAccessOperability is null)
	and P.Deal = T.Deal
	and P.TransactionID = T.TransactionID
	and ( T.TerminationDate  is null or T.TerminationDate > convert(int,convert(varchar(30),getdate(),112)) )
	and ( T.EarlyTerminationDate is null or T.EarlyTerminationDate > convert(int,convert(varchar(30),getdate(),112)) )
	and T.TradeStatus = 2
	and P.Deal = D.Deal
	and D.Type = 1
	and C.ProductCorpusClass = 22
end
else
begin
        select distinct MarketDataObjectID,IndexName
	into #tmp
        from PDB..PaymentIndexObservation P,MDDB..MarketDataDefinition M,
	ODB..CashFlowCorpus C, ODB..TransactionTable T, ODB..Deal D
        where IndexQuoteDate=@QuoteDate
        and M.MarketDataObjectName = P.IndexName
        and M.Class = 6
	and P.Deal = C.Deal
	and P.TransactionID = C.TransactionID
	and P.ProductCorpus = C.ProductCorpus
	and (C.RateIndexAccessOperability != 1 or C.RateIndexAccessOperability is NULL)
	and P.Deal = T.Deal
	and P.TransactionID = T.TransactionID
	and ( T.TerminationDate  is null or T.TerminationDate > convert(int,convert(varchar(30),getdate(),112)) )
	and ( T.EarlyTerminationDate is null or T.EarlyTerminationDate > convert(int,convert(varchar(30),getdate(),112)) )
	and T.TradeStatus = 2
	and P.Deal = D.Deal
	and D.Type = 1
	and C.ProductCorpusClass = 22
        select distinct "PaymentIndices",IndexName,NULL,NULL,NULL,NULL
        from #tmp T,MDDB..IndexObservation I
        where
        T.MarketDataObjectID = I.MarketDataObjectID
        and QuoteDate =  @QuoteDate  and SignedBy is NULL
        select distinct "PaymentIndices",IndexName,NULL,NULL,NULL,NULL
        from #tmp
        where MarketDataObjectID not in
        (select I.MarketDataObjectID from MDDB..IndexObservation I ,#tmp T where T.MarketDataObjectID = I.MarketDataObjectID and QuoteDate = @QuoteDate )
	
end
STORED_PROC_EXIT:


/
EXEC sp_procxmode GetPIndexObsByQuoteDate, unchained;
DROP PROCEDURE GetPIndexObsByQuoteDateNew;
--/
CREATE PROCEDURE GetPIndexObsByQuoteDateNew (
/**************************************************************
** 
** Procedure: 	GetPIndexObsByQuoteDate
**
** Version:    	%W% %G%
**
** Notes:
**
*************************************************************/
	@QuoteDate int,
	@NullRewRates int = NULL
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "%W% %G%"
if( @NullRewRates = 0 )
begin
        select distinct IndexName
        from PDB..PaymentIndexObservation P,MDDB..MarketDataDefinition M,
	ODB..CashFlowCorpus C, ODB..TransactionTable T
        where IndexQuoteDate=@QuoteDate
        and M.MarketDataObjectName = P.IndexName
        and M.Class = 6
	and P.Deal = C.Deal
	and P.TransactionID = C.TransactionID
	and P.ProductCorpus = C.ProductCorpus
	and (C.RateIndexAccessOperability != 1 or C.RateIndexAccessOperability is null)
	and P.Deal = T.Deal
	and P.TransactionID = T.TransactionID
	and ( T.TerminationDate  is null or T.TerminationDate > convert(int,convert(varchar(30),getdate(),112)) )
	and ( T.EarlyTerminationDate is null or T.EarlyTerminationDate > convert(int,convert(varchar(30),getdate(),112)) )
	and T.TradeStatus = 2
	and C.ProductCorpusClass = 22
end
else
begin
        select MarketDataObjectID,IndexName
	into #tmp
        from PDB..PaymentIndexObservation P,MDDB..MarketDataDefinition M,
	ODB..CashFlowCorpus C, ODB..TransactionTable T
        where IndexQuoteDate=@QuoteDate
        and M.MarketDataObjectName = P.IndexName
        and M.Class = 6
	and P.Deal = C.Deal
	and P.TransactionID = C.TransactionID
	and P.ProductCorpus = C.ProductCorpus
	and (C.RateIndexAccessOperability != 1 or C.RateIndexAccessOperability is NULL)
	and P.Deal = T.Deal
	and P.TransactionID = T.TransactionID
	and ( T.TerminationDate  is null or T.TerminationDate > convert(int,convert(varchar(30),getdate(),112)) )
	and ( T.EarlyTerminationDate is null or T.EarlyTerminationDate > convert(int,convert(varchar(30),getdate(),112)) )
	and T.TradeStatus = 2
	and C.ProductCorpusClass = 22
        select distinct IndexName
        from #tmp T,MDDB..IndexObservation I
        where T.MarketDataObjectID = I.MarketDataObjectID
        and QuoteDate =  @QuoteDate  and SignedBy is NULL
	UNION
        select distinct IndexName
        from #tmp
        where MarketDataObjectID not in
        (select I.MarketDataObjectID from MDDB..IndexObservation I ,#tmp T 
	where T.MarketDataObjectID = I.MarketDataObjectID and QuoteDate = @QuoteDate )
	
end
STORED_PROC_EXIT:


/
EXEC sp_procxmode GetPIndexObsByQuoteDateNew, unchained;
DROP PROCEDURE GetPasswordViolations;
--/
CREATE PROCEDURE GetPasswordViolations(
/**************************************************************************
**
** Procedure:   GetPasswordViolations
**
** Version:    @(#)GetPasswordViolations.sp	116.1 04/29/04
**
** Notes:
**
**************************************************************************/
    @FromDate       int,
    @ToDate         int,
	@SybaseID       varchar(255)
) as
set compatibility_mode off  
set plan optgoal allrows_oltp 
set plan optlevel ase_current/* Adaptive Server has expanded all '*' elements in the following statement */ 
select vl.SybaseID, vl.ViolationTimeGMT, vl.ViolationType, vl.TeamMember, vl.CostCentre, vl.PrivilegeName, vl.LoginAttempts, vl.HostName, vl.HostTimeStamp, vl.HostTimeZone, vl.Description             
from 
	ViolationLog vl
where 
	vl.SybaseID = @SybaseID
and	vl.ViolationType in ('IncorrectPassword', 'DisabledID')
and vl.ViolationTimeGMT <= (select max(vl1.ViolationTimeGMT)
                           from ViolationLog vl1
                           where vl1.SybaseID = @SybaseID
                           and convert(int,convert(char(8),vl1.ViolationTimeGMT,112)) >= @FromDate
                           and convert(int,convert(char(8),vl1.ViolationTimeGMT,112)) <= @ToDate
                           and vl1.ViolationType = 'DisabledID')
order by vl.ViolationTimeGMT desc
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode GetPasswordViolations, unchained;
DROP PROCEDURE GetPrivilegeViolations;
--/
CREATE PROCEDURE GetPrivilegeViolations(
/**************************************************************************
**
** Procedure:   GetPrivilegeViolations
**
** Version:    @(#)GetPrivilegeViolations.sp	116.1 04/29/04
**
** Notes:
**
**************************************************************************/
    @FromDate       int,
    @ToDate         int,
	@MaxViolations  int
) as
set compatibility_mode off  
set plan optgoal allrows_oltp 
set plan optlevel ase_current
select distinct SybaseID, PrivilegeName
into #tmp1
from
    ViolationLog
where
    convert(int,convert(char(8),ViolationTimeGMT,112)) >= @FromDate
and convert(int,convert(char(8),ViolationTimeGMT,112)) <= @ToDate
group by SybaseID, PrivilegeName
having count(PrivilegeName) >= @MaxViolations
/* Adaptive Server has expanded all '*' elements in the following statement */ select v.SybaseID, v.ViolationTimeGMT, v.ViolationType, v.TeamMember, v.CostCentre, v.PrivilegeName, v.LoginAttempts, v.HostName, v.HostTimeStamp, v.HostTimeZone, v.Description           
from
    ViolationLog v, #tmp1 t
where
	v.SybaseID = t.SybaseID
and v.PrivilegeName = t.PrivilegeName
and convert(int,convert(char(8),ViolationTimeGMT,112)) >= @FromDate
and convert(int,convert(char(8),ViolationTimeGMT,112)) <= @ToDate
order by v.SybaseID, v.PrivilegeName, ViolationTimeGMT desc
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode GetPrivilegeViolations, unchained;
DROP PROCEDURE GetReportByKey;
--/
CREATE PROCEDURE GetReportByKey (
/**************************************************************************
**
** Procedure:   GetReportByKey
**
** Version:     @(#)GetReportByKey.proc	63.1 08/06/01	
**
** Notes:       
**
**************************************************************************/
	@TeamMember	varchar(75),
	@ReportType	varchar(255),
	@Report		varchar(255)		
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
	declare  @version  varchar(255)
        select     @version = "@(#)GetReportByKey.proc	63.1 08/06/01"
declare @RC		int,
	@ErrorMessage	varchar(255)
	select @RC  = 0
	
/* Adaptive Server has expanded all '*' elements in the following statement */ select Report.ReportType, Report.Report, Report.TeamMember, Report.DynamicSQLIndicator, Report.OverRideDynamicQueryLimit, Report.FilterType, Report.CustomResultsColumnName, Report.CRC, Report.QueryID, Report.AccessType, Report.HistoryAllowed, Report.ParentReport, Report.IsDefault, Report.Description, Report.CreatedBy, Report.CreatedTimestamp, Report.ModifiedBy, Report.ModifiedTimestamp from Report where  TeamMember = @TeamMember and  		  ReportType = @ReportType and 		  Report     = @Report  if @@rowcount = 0 goto STORED_PROCEDURE_EXIT /* Adaptive Server has expanded all '*' elements in the following statement */ select ReportCustomization.ReportType, ReportCustomization.Report, ReportCustomization.TeamMember, ReportCustomization.ViewIndicator, ReportCustomization.SortIndicator, ReportCustomization.Attribute, ReportCustomization.Header, ReportCustomization.CustomizationOrder, ReportCustomization.Format, ReportCustomization.NullRepresentation, ReportCustomization.Total, ReportCustomization.SubTotalLevel, ReportCustomization.TableName, ReportCustomization.DisplayWidth from ReportCustomization where  TeamMember = @TeamMember and  		  ReportType = @ReportType and 		  Report     = @Report  /* Adaptive Server has expanded all '*' elements in the following statement */ select ReportSegment.ReportType, ReportSegment.Report, ReportSegment.TeamMember, ReportSegment.Type, ReportSegment.SegmentNumber, ReportSegment.Segment from ReportSegment where  TeamMember = @TeamMember and  		  ReportType = @ReportType and 		  Report     = @Report  order by SegmentNumber /* Adaptive Server has expanded all '*' elements in the following statement */ select Filter.ReportType, Filter.Report, Filter.TeamMember, Filter.Operation, Filter.TableName, Filter.TableKey, Filter.Column, Filter.ColumnValue from Filter where  TeamMember = @TeamMember and  		  ReportType = @ReportType and 		  Report     = @Report 
	goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
STORED_PROCEDURE_EXIT:
return @RC


/
EXEC sp_procxmode GetReportByKey, unchained;
DROP PROCEDURE GetReportingDelegation;
--/
CREATE PROCEDURE GetReportingDelegation (
/**************************************************************************
**
** Procedure:	GetReportingDelegation
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
@LastModified datetime = null)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
begin
if(@LastModified != null)
begin
        select distinct GFCID,GFCIDLastModified into #tmp from ADB..CustomerAccountView where GFCIDLastModified > @LastModified
        select  t.GFCID,rd.DelegatedGFCID,rd.TradingRepository,rd.Commodities,rd.Credit,rd.Equities,rd.ETD,
		rd.FX,rd.Rates,rd.Other,rd.DelegatedReportingJurisdiction,t.GFCIDLastModified
        from
        ADB..ReportingDelegation rd, #tmp t
        where t.GFCID = rd.GFCID
end
else
begin
        
  select distinct GFCID,GFCIDLastModified into #tmp1 from ADB..CustomerAccountView
        select t.GFCID,rd.DelegatedGFCID,rd.TradingRepository,rd.Commodities,rd.Credit,rd.Equities,rd.ETD,
		rd.FX,rd.Rates,rd.Other,rd.DelegatedReportingJurisdiction,t.GFCIDLastModified
        from
        ADB..ReportingDelegation rd, #tmp1 t
        where t.GFCID = rd.GFCID
end
end


/
EXEC sp_procxmode GetReportingDelegation, unchained;
DROP PROCEDURE GetReportsByTeamMember;
--/
CREATE PROCEDURE GetReportsByTeamMember (
/**************************************************************************
**
** Procedure:   GetReportsByTeamMember
**
** Version:     @(#)GetReportsByTeamMember.proc	63.1 08/06/01
**
** Notes:       
**
**************************************************************************/
	@TeamMember	varchar(75)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
	select @version = "@(#)GetReportsByTeamMember.proc	63.1 08/06/01"
	/* Adaptive Server has expanded all '*' elements in the following statement */ select Report.ReportType, Report.Report, Report.TeamMember, Report.DynamicSQLIndicator, Report.OverRideDynamicQueryLimit, Report.FilterType, Report.CustomResultsColumnName, Report.CRC, Report.QueryID, Report.AccessType, Report.HistoryAllowed, Report.ParentReport, Report.IsDefault, Report.Description, Report.CreatedBy, Report.CreatedTimestamp, Report.ModifiedBy, Report.ModifiedTimestamp from Report where  TeamMember = @TeamMember if @@rowcount = 0 goto STORED_PROCEDURE_EXIT /* Adaptive Server has expanded all '*' elements in the following statement */ select ReportCustomization.ReportType, ReportCustomization.Report, ReportCustomization.TeamMember, ReportCustomization.ViewIndicator, ReportCustomization.SortIndicator, ReportCustomization.Attribute, ReportCustomization.Header, ReportCustomization.CustomizationOrder, ReportCustomization.Format, ReportCustomization.NullRepresentation, ReportCustomization.Total, ReportCustomization.SubTotalLevel, ReportCustomization.TableName, ReportCustomization.DisplayWidth from ReportCustomization where  TeamMember = @TeamMember /* Adaptive Server has expanded all '*' elements in the following statement */ select ReportSegment.ReportType, ReportSegment.Report, ReportSegment.TeamMember, ReportSegment.Type, ReportSegment.SegmentNumber, ReportSegment.Segment from ReportSegment where  TeamMember = @TeamMember order by SegmentNumber /* Adaptive Server has expanded all '*' elements in the following statement */ select Filter.ReportType, Filter.Report, Filter.TeamMember, Filter.Operation, Filter.TableName, Filter.TableKey, Filter.Column, Filter.ColumnValue from Filter where  TeamMember = @TeamMember 
	goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode GetReportsByTeamMember, unchained;
DROP PROCEDURE GetStructuredNoteByKey;
--/
CREATE PROCEDURE GetStructuredNoteByKey (
/**************************************************************************
**
** Procedure:   GetStructuredNoteByKey
**
** Version:     @(#)GetStructuredNoteByKey.proc	63.1 08/06/01	
**
** Notes:       
**
*************************************************************************/
	@Class		varchar(255),
	@Type		varchar(255)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
        declare    @version   varchar(255)
        select     @version = "@(#)GetStructuredNoteByKey.proc	63.1 08/06/01"
declare @RC		int,
	@ErrorMessage	varchar(255)
select @RC = 0
	
/* Adaptive Server has expanded all '*' elements in the following statement */ select StructuredNote.Class, StructuredNote.Type, StructuredNote.LongName, StructuredNote.Description, StructuredNote.CRC from StructuredNote where  Class = @Class and 		  Type  = @Type  if @@rowcount = 0 goto STORED_PROCEDURE_EXIT /* Adaptive Server has expanded all '*' elements in the following statement */ select StructuredNoteSegment.Class, StructuredNoteSegment.Type, StructuredNoteSegment.NoteSegmentNumber, StructuredNoteSegment.NoteSegment from StructuredNoteSegment where  Class = @Class and 		  Type  = @Type  order by NoteSegmentNumber
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
STORED_PROCEDURE_EXIT:
return @RC


/
EXEC sp_procxmode GetStructuredNoteByKey, unchained;
DROP PROCEDURE GetSybaseGroupBySybaseID;
--/
CREATE PROCEDURE GetSybaseGroupBySybaseID (
/**************************************************************************
**
** Procedure:	GetSybaseGroupByTeamMember
**
** Version: 	@(#)GetSybaseGroupBySybaseID.proc	63.1 08/06/01
**
** Notes:	
**
**************************************************************************/
	@SybaseID             varchar(255) 
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare		@version varchar(255)
select @version = "@(#)GetSybaseGroupBySybaseID.proc	63.1 08/06/01"
declare @ErrorMessage	varchar(255),
	@TeamMember	varchar(75)
select @TeamMember=TeamMember from TeamMember where SybaseID = @SybaseID
select Configuration from ConfigurationSegment
where TeamMember = @TeamMember
and ConfigurationName = "SybaseGroup"
and SegmentNumber = 1
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not select SybaseGroup Configuration for "
	select @ErrorMessage = @ErrorMessage + "SybaseID '" + convert(varchar(255), @SybaseID) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode GetSybaseGroupBySybaseID, unchained;
DROP PROCEDURE GetSybaseGroupByTeamMember;
--/
CREATE PROCEDURE GetSybaseGroupByTeamMember (
/**************************************************************************
**
** Procedure:	GetSybaseGroupByTeamMember
**
** Version: 	@(#)GetSybaseGroupByTeamMember.proc	63.1 08/06/01
**
** Notes:	
**
**************************************************************************/
	@TeamMember             varchar(75) 
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
        declare    @version   varchar(255)
        select     @version = "@(#)GetSybaseGroupByTeamMember.proc	63.1 08/06/01"
declare @ErrorMessage	varchar(255)
select Configuration from ConfigurationSegment
where TeamMember = @TeamMember
and ConfigurationName = "SybaseGroup"
and SegmentNumber = 1
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not select SybaseGroup Configuration for "
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode GetSybaseGroupByTeamMember, unchained;
DROP PROCEDURE GetTaxEventByKey;
--/
CREATE PROCEDURE GetTaxEventByKey (
/**************************************************************************
**
** Procedure:	GetTaxEventByKey
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@EventType   int ,
	@Location varchar(255)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @ErrorMessage	varchar(255),
        @rowcount		int
  /* Adaptive Server has expanded all '*' elements in the following statement */ select T.TaxCenterID, T.EventType, T.EventSubType 
  from TaxEvent T,TaxCenter TC
  where T.TaxCenterID = TC.TaxCenterID and TaxCenterName = @Location and EventType = @EventType
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode GetTaxEventByKey, unchained;
DROP PROCEDURE GetTaxProductMappingByKey;
--/
CREATE PROCEDURE GetTaxProductMappingByKey (
/**************************************************************************
**
** Procedure:	GetTaxProductMappingByKey
**
** Version: 	%W% %G%
**
** Notes:	
**
**************************************************************************/
	@TaxCenterID             int = NULL,
	@Location             varchar(255) = NULL
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare		@version varchar(255)
select @version = "%W% %G%"
declare @ErrorMessage   varchar(255)
if @TaxCenterID is NULL and @Location is NULL
  goto ERROR_EXIT
if @TaxCenterID is not NULL
begin
/* Adaptive Server has expanded all '*' elements in the following statement */ select TaxProductMapping.TaxCenterID, TaxProductMapping.ProductClass, TaxProductMapping.TaxedType, TaxProductMapping.Taxable, TaxProductMapping.TaxRetentionCode from TaxProductMapping
where TaxCenterID = @TaxCenterID
end
else
if @Location is not NULL
begin
/* Adaptive Server has expanded all '*' elements in the following statement */ select T.TaxCenterID, T.ProductClass, T.TaxedType, T.Taxable, T.TaxRetentionCode from TaxProductMapping T,TaxCenter TC
where T.TaxCenterID = TC.TaxCenterID 
and TaxCenterName = @Location
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
  select @ErrorMessage = "Location and TaxCenterID can't be NULL at same time."
  raiserror 20002 @ErrorMessage
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode GetTaxProductMappingByKey, unchained;
DROP PROCEDURE GetTaxRateByKey;
--/
CREATE PROCEDURE GetTaxRateByKey (
/**************************************************************************
**
** Procedure:	GetTaxRateByKey
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
** if( @TypeOfAccount = 2)  FIRM
** if( @TypeOfAccount = 1)  CUSTOMER
**
**************************************************************************/
	@TaxCenterID   int = NULL,
	@Location varchar(255)=NULL,
	@AccountNumber  int,
        @TypeOfAccount  int
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @TaxID int,
	@legalEntityID  int
if @TaxCenterID is NULL and @Location is NULL
  goto ERROR_EXIT
if @TaxCenterID is not NULL
begin
	select @TaxID = @TaxCenterID
end
else if @Location is not NULL
begin
  select  @TaxID = TaxCenterID
  from TaxCenter
  where TaxCenterName = @Location
end
if( @TypeOfAccount = 4) 
begin
  select @legalEntityID = LegalEntityID
        from ADB..LegalEntity L, ADB..FirmAccount F
        where F.AccountNumber = @AccountNumber and L.LegalEntityShortName = F.Firm
        and L.LastReviewedBy is not null
  /* Adaptive Server has expanded all '*' elements in the following statement */ select distinct TX.TaxCenterID, TX.TaxedType, TX.CustomerType, TX.CustomerBranch, TX.Domicile, TX.EffectiveStart, TX.EffectiveEnd, TX.TenorStart, TX.TenorEnd, TX.TaxRate, TX.LastModified, TX.LastModifiedTimeZone, TX.LastModifiedBy, TX.LastSigned, TX.LastSignedTimeZone, TX.LastSignedBy, TX.ProductClass from TaxRate TX, ADB..TaxLink TL, ADB..Tax T
	where  
	TaxCenterID = @TaxID and
        TypeOfAccount = @TypeOfAccount and
	AccountNumber = @legalEntityID and
 	T.TaxID = TL.TaxID and	
	TX.CustomerType = T.TaxClassification
end
else if( @TypeOfAccount = 1)
begin
  /* Adaptive Server has expanded all '*' elements in the following statement */ select distinct TX.TaxCenterID, TX.TaxedType, TX.CustomerType, TX.CustomerBranch, TX.Domicile, TX.EffectiveStart, TX.EffectiveEnd, TX.TenorStart, TX.TenorEnd, TX.TaxRate, TX.LastModified, TX.LastModifiedTimeZone, TX.LastModifiedBy, TX.LastSigned, TX.LastSignedTimeZone, TX.LastSignedBy, TX.ProductClass from TaxRate TX,ADB..Tax T,ADB..TaxLink TL
	where
	TaxCenterID = @TaxID and
	T.TaxID = TL.TaxID and
        TypeOfAccount = @TypeOfAccount and
        AccountNumber = @AccountNumber and
	TX.CustomerType = T.TaxClassification
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
  select @ErrorMessage = "Location and TaxCenterID can't be NULL at same time."
  raiserror 20002 @ErrorMessage
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode GetTaxRateByKey, unchained;
DROP PROCEDURE GetTeamMemberByEmployeeID;
--/
CREATE PROCEDURE GetTeamMemberByEmployeeID (
/**************************************************************************
**
** Procedure:   GetTeamMemberByEmployeeID
**
** Version:     @(#)GetTeamMemberByEmployeeID.proc	63.1 08/06/01
**
** Notes:       
**
**************************************************************************/
	@EmployeeIdentification	int,
	@TeamMemberType	int = NULL
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select @version = "@(#)GetTeamMemberByEmployeeID.proc	63.1 08/06/01"
declare @ErrorMessage	varchar(255),
	@TeamMember     varchar(75)
	select @TeamMember=TeamMember from TeamMember
		where EmployeeIdentification = @EmployeeIdentification
				and TeamMemberType = @TeamMemberType
	
	/* Adaptive Server has expanded all '*' elements in the following statement */ select TeamMember.TeamMember, TeamMember.Department, TeamMember.SybaseID, TeamMember.EmployeeIdentification, TeamMember.EMailAddress, TeamMember.Telephone, TeamMember.CRC, TeamMember.CostCentre, TeamMember.PWD, TeamMember.OldPWD, TeamMember.PreExpired, TeamMember.Disabled, TeamMember.LoginAttempts, TeamMember.EntryDate, TeamMember.ExpiryDate, TeamMember.TeamMemberType, TeamMember.SiteminderAuthentication, TeamMember.FunctionalAccount, TeamMember.Owner, TeamMember.Description, TeamMember.FirstName, TeamMember.LastName, TeamMember.Supervisor, TeamMember.Region, TeamMember.Country, TeamMember.Location, TeamMember.BusinessAreaID, TeamMember.ApprovedBy, TeamMember.Approved, TeamMember.ApprovedTimeZone, TeamMember.CreatedBy, TeamMember.Created, TeamMember.CreatedTimeZone, TeamMember.BusinessLine, TeamMember.LastModifyBy, TeamMember.LastModify, TeamMember.LastModifyTimeZone from TeamMember where  TeamMember = @TeamMember  if @@rowcount = 0 goto STORED_PROCEDURE_EXIT /* Adaptive Server has expanded all '*' elements in the following statement */ select TeamMemberPrivileges.TeamMember, TeamMemberPrivileges.TeamMemberPrivilege, TeamMemberPrivileges.ApprovedBy, TeamMemberPrivileges.Approved, TeamMemberPrivileges.ApprovedTimeZone from TeamMemberPrivileges where  TeamMember = @TeamMember  /* Adaptive Server has expanded all '*' elements in the following statement */ select TeamMemberLimits.TeamMember, TeamMemberLimits.Type, TeamMemberLimits.Limit, TeamMemberLimits.ApprovedBy, TeamMemberLimits.Approved, TeamMemberLimits.ApprovedTimeZone from TeamMemberLimits where  TeamMember = @TeamMember  /* Adaptive Server has expanded all '*' elements in the following statement */ select ConfigurationSegment.TeamMember, ConfigurationSegment.ConfigurationName, ConfigurationSegment.SegmentNumber, ConfigurationSegment.Configuration from ConfigurationSegment where  TeamMember = @TeamMember  order by SegmentNumber /* Adaptive Server has expanded all '*' elements in the following statement */ select TeamMemberDataAccessPrivileges.TeamMember, TeamMemberDataAccessPrivileges.AccessObject, TeamMemberDataAccessPrivileges.AccessPrivilege, TeamMemberDataAccessPrivileges.AccessEntity, TeamMemberDataAccessPrivileges.AccessEntityValue, TeamMemberDataAccessPrivileges.FilterType, TeamMemberDataAccessPrivileges.ApprovedBy, TeamMemberDataAccessPrivileges.Approved, TeamMemberDataAccessPrivileges.ApprovedTimeZone from TeamMemberDataAccessPrivileges where  TeamMember = @TeamMember  /* Adaptive Server has expanded all '*' elements in the following statement */ select TeamMemberGroupLink.TeamMember, TeamMemberGroupLink.TeamMemberGroup, TeamMemberGroupLink.ApprovedBy, TeamMemberGroupLink.Approved, TeamMemberGroupLink.ApprovedTimeZone from TeamMemberGroupLink where  TeamMember = @TeamMember 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode GetTeamMemberByEmployeeID, unchained;
DROP PROCEDURE GetTeamMemberByName;
--/
CREATE PROCEDURE GetTeamMemberByName (
/*************************************************************************
**
** Procedure:   GetTeamMemberByName
**
** Version:     @(#)GetTeamMemberByName.proc	63.1 08/06/01	
**
** Notes:       
**
**************************************************************************/
	@TeamMember	varchar(75)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
        declare    @version   varchar(255)
        select     @version = "@(#)GetTeamMemberByName.proc	63.1 08/06/01"
declare @ErrorMessage	varchar(255)
	/* Adaptive Server has expanded all '*' elements in the following statement */ select TeamMember.TeamMember, TeamMember.Department, TeamMember.SybaseID, TeamMember.EmployeeIdentification, TeamMember.EMailAddress, TeamMember.Telephone, TeamMember.CRC, TeamMember.CostCentre, TeamMember.PWD, TeamMember.OldPWD, TeamMember.PreExpired, TeamMember.Disabled, TeamMember.LoginAttempts, TeamMember.EntryDate, TeamMember.ExpiryDate, TeamMember.TeamMemberType, TeamMember.SiteminderAuthentication, TeamMember.FunctionalAccount, TeamMember.Owner, TeamMember.Description, TeamMember.FirstName, TeamMember.LastName, TeamMember.Supervisor, TeamMember.Region, TeamMember.Country, TeamMember.Location, TeamMember.BusinessAreaID, TeamMember.ApprovedBy, TeamMember.Approved, TeamMember.ApprovedTimeZone, TeamMember.CreatedBy, TeamMember.Created, TeamMember.CreatedTimeZone, TeamMember.BusinessLine, TeamMember.LastModifyBy, TeamMember.LastModify, TeamMember.LastModifyTimeZone from TeamMember where  TeamMember = @TeamMember  if @@rowcount = 0 goto STORED_PROCEDURE_EXIT /* Adaptive Server has expanded all '*' elements in the following statement */ select TeamMemberPrivileges.TeamMember, TeamMemberPrivileges.TeamMemberPrivilege, TeamMemberPrivileges.ApprovedBy, TeamMemberPrivileges.Approved, TeamMemberPrivileges.ApprovedTimeZone from TeamMemberPrivileges where  TeamMember = @TeamMember  /* Adaptive Server has expanded all '*' elements in the following statement */ select TeamMemberLimits.TeamMember, TeamMemberLimits.Type, TeamMemberLimits.Limit, TeamMemberLimits.ApprovedBy, TeamMemberLimits.Approved, TeamMemberLimits.ApprovedTimeZone from TeamMemberLimits where  TeamMember = @TeamMember  /* Adaptive Server has expanded all '*' elements in the following statement */ select ConfigurationSegment.TeamMember, ConfigurationSegment.ConfigurationName, ConfigurationSegment.SegmentNumber, ConfigurationSegment.Configuration from ConfigurationSegment where  TeamMember = @TeamMember  order by SegmentNumber /* Adaptive Server has expanded all '*' elements in the following statement */ select TeamMemberDataAccessPrivileges.TeamMember, TeamMemberDataAccessPrivileges.AccessObject, TeamMemberDataAccessPrivileges.AccessPrivilege, TeamMemberDataAccessPrivileges.AccessEntity, TeamMemberDataAccessPrivileges.AccessEntityValue, TeamMemberDataAccessPrivileges.FilterType, TeamMemberDataAccessPrivileges.ApprovedBy, TeamMemberDataAccessPrivileges.Approved, TeamMemberDataAccessPrivileges.ApprovedTimeZone from TeamMemberDataAccessPrivileges where  TeamMember = @TeamMember  /* Adaptive Server has expanded all '*' elements in the following statement */ select TeamMemberGroupLink.TeamMember, TeamMemberGroupLink.TeamMemberGroup, TeamMemberGroupLink.ApprovedBy, TeamMemberGroupLink.Approved, TeamMemberGroupLink.ApprovedTimeZone from TeamMemberGroupLink where  TeamMember = @TeamMember 
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode GetTeamMemberByName, unchained;
DROP PROCEDURE GetTeamMemberBySybaseID;
--/
CREATE PROCEDURE GetTeamMemberBySybaseID (
/**************************************************************************
**
** Procedure:   GetTeamMemberBySybaseID
**
** Version:     @(#)GetTeamMemberBySybaseID.proc	63.1 08/06/01
**
** Notes:       
**
**************************************************************************/
	@SybaseID	varchar(255)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select @version = "@(#)GetTeamMemberBySybaseID.proc	63.1 08/06/01"
declare @ErrorMessage	varchar(255),
	@TeamMember     varchar(75)
	select @TeamMember=TeamMember from TeamMember where SybaseID = @SybaseID
	
	/* Adaptive Server has expanded all '*' elements in the following statement */ select TeamMember.TeamMember, TeamMember.Department, TeamMember.SybaseID, TeamMember.EmployeeIdentification, TeamMember.EMailAddress, TeamMember.Telephone, TeamMember.CRC, TeamMember.CostCentre, TeamMember.PWD, TeamMember.OldPWD, TeamMember.PreExpired, TeamMember.Disabled, TeamMember.LoginAttempts, TeamMember.EntryDate, TeamMember.ExpiryDate, TeamMember.TeamMemberType, TeamMember.SiteminderAuthentication, TeamMember.FunctionalAccount, TeamMember.Owner, TeamMember.Description, TeamMember.FirstName, TeamMember.LastName, TeamMember.Supervisor, TeamMember.Region, TeamMember.Country, TeamMember.Location, TeamMember.BusinessAreaID, TeamMember.ApprovedBy, TeamMember.Approved, TeamMember.ApprovedTimeZone, TeamMember.CreatedBy, TeamMember.Created, TeamMember.CreatedTimeZone, TeamMember.BusinessLine, TeamMember.LastModifyBy, TeamMember.LastModify, TeamMember.LastModifyTimeZone from TeamMember where  TeamMember = @TeamMember  if @@rowcount = 0 goto STORED_PROCEDURE_EXIT /* Adaptive Server has expanded all '*' elements in the following statement */ select TeamMemberPrivileges.TeamMember, TeamMemberPrivileges.TeamMemberPrivilege, TeamMemberPrivileges.ApprovedBy, TeamMemberPrivileges.Approved, TeamMemberPrivileges.ApprovedTimeZone from TeamMemberPrivileges where  TeamMember = @TeamMember  /* Adaptive Server has expanded all '*' elements in the following statement */ select TeamMemberLimits.TeamMember, TeamMemberLimits.Type, TeamMemberLimits.Limit, TeamMemberLimits.ApprovedBy, TeamMemberLimits.Approved, TeamMemberLimits.ApprovedTimeZone from TeamMemberLimits where  TeamMember = @TeamMember  /* Adaptive Server has expanded all '*' elements in the following statement */ select ConfigurationSegment.TeamMember, ConfigurationSegment.ConfigurationName, ConfigurationSegment.SegmentNumber, ConfigurationSegment.Configuration from ConfigurationSegment where  TeamMember = @TeamMember  order by SegmentNumber /* Adaptive Server has expanded all '*' elements in the following statement */ select TeamMemberDataAccessPrivileges.TeamMember, TeamMemberDataAccessPrivileges.AccessObject, TeamMemberDataAccessPrivileges.AccessPrivilege, TeamMemberDataAccessPrivileges.AccessEntity, TeamMemberDataAccessPrivileges.AccessEntityValue, TeamMemberDataAccessPrivileges.FilterType, TeamMemberDataAccessPrivileges.ApprovedBy, TeamMemberDataAccessPrivileges.Approved, TeamMemberDataAccessPrivileges.ApprovedTimeZone from TeamMemberDataAccessPrivileges where  TeamMember = @TeamMember  /* Adaptive Server has expanded all '*' elements in the following statement */ select TeamMemberGroupLink.TeamMember, TeamMemberGroupLink.TeamMemberGroup, TeamMemberGroupLink.ApprovedBy, TeamMemberGroupLink.Approved, TeamMemberGroupLink.ApprovedTimeZone from TeamMemberGroupLink where  TeamMember = @TeamMember 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode GetTeamMemberBySybaseID, unchained;
DROP PROCEDURE GetTeamMemberRmRWGrpBySybaseID;
--/
CREATE PROCEDURE GetTeamMemberRmRWGrpBySybaseID (
/**************************************************************************
**
** Procedure:   GetTeamMemberBySybaseID
**
** Version:     @(#)GetTeamMemberBySybaseID.proc	63.1 08/06/01
**
** Notes:       
**
********* 
*****************************************************************/
	@SybaseID	varchar(255)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select  @version = "@(#)GetTeamMemberBySybaseID.proc	63.1 08/06/01"
declare @ErrorMessage	varchar(255),
        @TeamMember varchar(75)
select  @TeamMember=TeamMember from TeamMember where SybaseID = @SybaseID 
	
select 
TeamMember.TeamMember, 
TeamMember.Department, 
TeamMember.SybaseID, 
TeamMember.EmployeeIdentification, 
TeamMember.EMailAddress, 
TeamMember.Telephone, 
TeamMember.CRC, 
TeamMember.CostCentre, 
TeamMember.PWD, 
TeamMember.OldPWD, 
TeamMember.PreExpired, 
TeamMember.Disabled, 
TeamMember.LoginAttempts, 
TeamMember.EntryDate, 
TeamMember.ExpiryDate, 
TeamMember.TeamMemberType, 
TeamMember.SiteminderAuthentication, 
TeamMember.FunctionalAccount, 
TeamMember.Owner, 
TeamMember.Description, 
TeamMember.FirstName, 
TeamMember.LastName, 
TeamMember.Supervisor, 
TeamMember.Region, 
TeamMember.Country, 
TeamMember.Location, 
TeamMember.BusinessAreaID, 
TeamMember.ApprovedBy, 
TeamMember.Approved, 
TeamMember.ApprovedTimeZone, 
TeamMember.CreatedBy, 
TeamMember.Created, 
TeamMember.CreatedTimeZone, 
TeamMember.BusinessLine, 
TeamMember.LastModifyBy, 
TeamMember.LastModify, 
TeamMember.LastModifyTimeZone 
from TeamMember 
where  
TeamMember = @TeamMember  
if @@rowcount = 0 goto STORED_PROCEDURE_EXIT
select TeamMemberPrivileges.TeamMember, 
TeamMemberPrivileges.TeamMemberPrivilege, 
TeamMemberPrivileges.ApprovedBy, 
TeamMemberPrivileges.Approved, 
TeamMemberPrivileges.ApprovedTimeZone 
from 
TeamMemberPrivileges where  TeamMember = @TeamMember
select 
TeamMemberLimits.TeamMember, 
TeamMemberLimits.Type, 
TeamMemberLimits.Limit, 
TeamMemberLimits.ApprovedBy, 
TeamMemberLimits.Approved, 
TeamMemberLimits.ApprovedTimeZone 
from 
TeamMemberLimits 
where  
TeamMember = @TeamMember  
select ConfigurationSegment.TeamMember, 
ConfigurationSegment.ConfigurationName, 
ConfigurationSegment.SegmentNumber, 
ConfigurationSegment.Configuration 
from 
ConfigurationSegment 
where  TeamMember = @TeamMember  order by SegmentNumber
select TeamMemberDataAccessPrivileges.TeamMember, 
TeamMemberDataAccessPrivileges.AccessObject, 
TeamMemberDataAccessPrivileges.AccessPrivilege, 
TeamMemberDataAccessPrivileges.AccessEntity, 
TeamMemberDataAccessPrivileges.AccessEntityValue, 
TeamMemberDataAccessPrivileges.FilterType, 
TeamMemberDataAccessPrivileges.ApprovedBy, 
TeamMemberDataAccessPrivileges.Approved, 
TeamMemberDataAccessPrivileges.ApprovedTimeZone 
from 
TeamMemberDataAccessPrivileges 
where  
TeamMember = @TeamMember  
/* Adaptive Server has expanded all '*' elements in the following statement */ select distinct TeamMemberGroupLink.TeamMember, TeamMemberGroupLink.TeamMemberGroup, TeamMemberGroupLink.ApprovedBy, TeamMemberGroupLink.Approved, TeamMemberGroupLink.ApprovedTimeZone                                      into #tempGroup from
            CDB..TeamMember TeamMember,
            CDB..TeamMemberPrivileges TeamMemberPrivileges,
            CDB..TeamMemberGroupLink TeamMemberGroupLink,
            CDB..Code Code
    where TeamMember.Department in (select Code from Code where Type='TeamMemberDepartmentin')
        and TeamMember.TeamMemberType = 1
        and TeamMember.FunctionalAccount = null
        and TeamMember.SybaseID not like '%DELETED%'
        and TeamMemberGroupLink.TeamMember = TeamMember.TeamMember
        and TeamMemberPrivileges.TeamMember = TeamMemberGroupLink.TeamMemberGroup
        and Code.Code = TeamMemberPrivileges.TeamMemberPrivilege
        and TeamMemberGroupLink.TeamMember = @TeamMember
        and Code.Type = 'TeamMemberPrivilege'
        and Code.Description like '%Read%Write%'
/* Adaptive Server has expanded all '*' elements in the following statement */ select distinct  TeamMemberGroupLink.TeamMember, TeamMemberGroupLink.TeamMemberGroup, TeamMemberGroupLink.ApprovedBy, TeamMemberGroupLink.Approved, TeamMemberGroupLink.ApprovedTimeZone from TeamMemberGroupLink, #tempGroup Team
where TeamMemberGroupLink.TeamMember = Team.TeamMember
and TeamMemberGroupLink.TeamMemberGroup not in(select TeamMemberGroup from #tempGroup)
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode GetTeamMemberRmRWGrpBySybaseID, unchained;
DROP PROCEDURE GetTeamMemberRmRWPriBySybaseID;
--/
CREATE PROCEDURE GetTeamMemberRmRWPriBySybaseID (
/**************************************************************************
**
** Procedure:   GetTeamMemberBySybaseID
**
** Version:     @(#)GetTeamMemberBySybaseID.proc	63.1 08/06/01
**
** Notes:       
**
********* 
*****************************************************************/
	@SybaseID	varchar(255)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select  @version = "@(#)GetTeamMemberBySybaseID.proc	63.1 08/06/01"
declare @ErrorMessage	varchar(255),
        @TeamMember varchar(75)
select  @TeamMember=TeamMember from TeamMember where SybaseID =@SybaseID 
	
select 
TeamMember.TeamMember, 
TeamMember.Department, 
TeamMember.SybaseID, 
TeamMember.EmployeeIdentification, 
TeamMember.EMailAddress, 
TeamMember.Telephone, 
TeamMember.CRC, 
TeamMember.CostCentre, 
TeamMember.PWD, 
TeamMember.OldPWD, 
TeamMember.PreExpired, 
TeamMember.Disabled, 
TeamMember.LoginAttempts, 
TeamMember.EntryDate, 
TeamMember.ExpiryDate, 
TeamMember.TeamMemberType, 
TeamMember.SiteminderAuthentication, 
TeamMember.FunctionalAccount, 
TeamMember.Owner, 
TeamMember.Description, 
TeamMember.FirstName, 
TeamMember.LastName, 
TeamMember.Supervisor, 
TeamMember.Region, 
TeamMember.Country, 
TeamMember.Location, 
TeamMember.BusinessAreaID, 
TeamMember.ApprovedBy, 
TeamMember.Approved, 
TeamMember.ApprovedTimeZone, 
TeamMember.CreatedBy, 
TeamMember.Created, 
TeamMember.CreatedTimeZone, 
TeamMember.BusinessLine, 
TeamMember.LastModifyBy, 
TeamMember.LastModify, 
TeamMember.LastModifyTimeZone 
from TeamMember 
where  
TeamMember = @TeamMember  
if @@rowcount = 0 goto STORED_PROCEDURE_EXIT
/* Adaptive Server has expanded all '*' elements in the following statement */ select distinct TeamMemberPrivileges. TeamMember, TeamMemberPrivileges.TeamMemberPrivilege, TeamMemberPrivileges.ApprovedBy, TeamMemberPrivileges.Approved, TeamMemberPrivileges.ApprovedTimeZone                                        from 
CDB..TeamMember TeamMember, 
CDB..TeamMemberPrivileges TeamMemberPrivileges, 
CDB..Code Code 
where TeamMember.Department  in (select Code from Code where Type='TeamMemberDepartmentin')
and TeamMember.TeamMemberType = 1
and TeamMember.FunctionalAccount = null
and TeamMember.SybaseID not like '%DELETED%'
and TeamMemberPrivileges.TeamMember = @TeamMember
and Code.Code = TeamMemberPrivileges.TeamMemberPrivilege
and Code.Type = 'TeamMemberPrivilege' 
and TeamMemberPrivileges.TeamMember = TeamMember.TeamMember
and Code.Description not like '%Read%Write%' 
select 
TeamMemberLimits.TeamMember, 
TeamMemberLimits.Type, 
TeamMemberLimits.Limit, 
TeamMemberLimits.ApprovedBy, 
TeamMemberLimits.Approved, 
TeamMemberLimits.ApprovedTimeZone 
from 
TeamMemberLimits 
where  
TeamMember = @TeamMember  
select ConfigurationSegment.TeamMember, 
ConfigurationSegment.ConfigurationName, 
ConfigurationSegment.SegmentNumber, 
ConfigurationSegment.Configuration 
from 
ConfigurationSegment 
where  TeamMember = @TeamMember  order by SegmentNumber
select TeamMemberDataAccessPrivileges.TeamMember, 
TeamMemberDataAccessPrivileges.AccessObject, 
TeamMemberDataAccessPrivileges.AccessPrivilege, 
TeamMemberDataAccessPrivileges.AccessEntity, 
TeamMemberDataAccessPrivileges.AccessEntityValue, 
TeamMemberDataAccessPrivileges.FilterType, 
TeamMemberDataAccessPrivileges.ApprovedBy, 
TeamMemberDataAccessPrivileges.Approved, 
TeamMemberDataAccessPrivileges.ApprovedTimeZone 
from 
TeamMemberDataAccessPrivileges 
where  
TeamMember = @TeamMember  
select TeamMemberGroupLink.TeamMember, 
TeamMemberGroupLink.TeamMemberGroup, 
TeamMemberGroupLink.ApprovedBy, 
TeamMemberGroupLink.Approved, 
TeamMemberGroupLink.ApprovedTimeZone 
from 
TeamMemberGroupLink 
where  TeamMember = @TeamMember 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode GetTeamMemberRmRWPriBySybaseID, unchained;
DROP PROCEDURE GetUserIdsForCostCentre;
--/
CREATE PROCEDURE GetUserIdsForCostCentre(
/**************************************************************************
**
** Procedure:   GetUserIdsForCostCentre
**
** Version:    %W %G 
**
** Notes:
**
**************************************************************************/
	@CostCentre varchar(255)
) as
set compatibility_mode off  
set plan optgoal allrows_oltp 
set plan optlevel ase_current
        declare @Version varchar(255)
        select @Version = "%W% %G%"
	/* Adaptive Server has expanded all '*' elements in the following statement */ select TeamMember.TeamMember, TeamMember.Department, TeamMember.SybaseID, TeamMember.EmployeeIdentification, TeamMember.EMailAddress, TeamMember.Telephone, TeamMember.CRC, TeamMember.CostCentre, TeamMember.PWD, TeamMember.OldPWD, TeamMember.PreExpired, TeamMember.Disabled, TeamMember.LoginAttempts, TeamMember.EntryDate, TeamMember.ExpiryDate, TeamMember.TeamMemberType, TeamMember.SiteminderAuthentication, TeamMember.FunctionalAccount, TeamMember.Owner, TeamMember.Description, TeamMember.FirstName, TeamMember.LastName, TeamMember.Supervisor, TeamMember.Region, TeamMember.Country, TeamMember.Location, TeamMember.BusinessAreaID, TeamMember.ApprovedBy, TeamMember.Approved, TeamMember.ApprovedTimeZone, TeamMember.CreatedBy, TeamMember.Created, TeamMember.CreatedTimeZone, TeamMember.BusinessLine, TeamMember.LastModifyBy, TeamMember.LastModify, TeamMember.LastModifyTimeZone                                        
	from TeamMember                        
	where CostCentre = @CostCentre
                                               	 
	if @@rowcount = 0 goto STORED_PROCEDURE_EXIT    
                                                
	/* Adaptive Server has expanded all '*' elements in the following statement */ select T.TeamMember, T.TeamMemberPrivilege, T.ApprovedBy, T.Approved, T.ApprovedTimeZone
	from TeamMemberPrivileges T,
     	TeamMember TM
	where TM.CostCentre = @CostCentre
	and TM.TeamMember = T.TeamMember
	/* Adaptive Server has expanded all '*' elements in the following statement */ select T.TeamMember, T.Type, T.Limit, T.ApprovedBy, T.Approved, T.ApprovedTimeZone
	from TeamMemberLimits T,
	     TeamMember TM
	where TM.CostCentre = @CostCentre
	and TM.TeamMember = T.TeamMember
	/* Adaptive Server has expanded all '*' elements in the following statement */ select T.TeamMember, T.ConfigurationName, T.SegmentNumber, T.Configuration
	from ConfigurationSegment T,
	     TeamMember TM
	where TM.CostCentre = @CostCentre
	and TM.TeamMember = T.TeamMember
	/* Adaptive Server has expanded all '*' elements in the following statement */ select T.TeamMember, T.AccessObject, T.AccessPrivilege, T.AccessEntity, T.AccessEntityValue, T.FilterType, T.ApprovedBy, T.Approved, T.ApprovedTimeZone
	from TeamMemberDataAccessPrivileges T,
	     TeamMember TM
	where TM.CostCentre = @CostCentre
	and TM.TeamMember = T.TeamMember
	/* Adaptive Server has expanded all '*' elements in the following statement */ select T.TeamMember, T.TeamMemberGroup, T.ApprovedBy, T.Approved, T.ApprovedTimeZone
	from TeamMemberGroupLink T,
	     TeamMember TM
	where TM.CostCentre = @CostCentre
	and TM.TeamMember = T.TeamMember
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode GetUserIdsForCostCentre, unchained;
DROP PROCEDURE GetViolationLogByKey;
--/
CREATE PROCEDURE GetViolationLogByKey (
/*************************************************************************
**
** Procedure:   GetViolationLogByKey
**
** Version:     %W% %G% 
**
** Notes:       
**
**************************************************************************/
	@SybaseID	varchar(255),
	@ViolationTimeGMT datetime,
	@ViolationType varchar(255)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
    declare    @version   varchar(255)
    select     @version = "%W% %G%"
	declare @ErrorMessage	varchar(255)
	/* Adaptive Server has expanded all '*' elements in the following statement */ select ViolationLog.SybaseID, ViolationLog.ViolationTimeGMT, ViolationLog.ViolationType, ViolationLog.TeamMember, ViolationLog.CostCentre, ViolationLog.PrivilegeName, ViolationLog.LoginAttempts, ViolationLog.HostName, ViolationLog.HostTimeStamp, ViolationLog.HostTimeZone, ViolationLog.Description
    from 
		ViolationLog
    where 
		SybaseID = @SybaseID and
		ViolationTimeGMT = @ViolationTimeGMT and
		ViolationType = @ViolationType
    if @@rowcount = 0 goto STORED_PROCEDURE_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode GetViolationLogByKey, unchained;
DROP PROCEDURE GetWordByName;
--/
CREATE PROCEDURE GetWordByName (
/**************************************************************************
**
** Procedure:	GetWordByName
**
** Version: 	@(#)GetWordByName.proc	63.1 08/06/01
**
** Notes:	
**
**************************************************************************/
	@Word varchar(255)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @ErrorMessage	varchar(255)
declare @version  varchar(255)
select  @version = "@(#)GetWordByName.proc	63.1 08/06/01"
/* Adaptive Server has expanded all '*' elements in the following statement */ select Word.Word from Word
where Word = @Word
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode GetWordByName, unchained;
DROP PROCEDURE GroupOwnerList;
--/
CREATE PROCEDURE GroupOwnerList
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "%W% %G%"
select "CodeType", "GroupOwnerList", "ExternalCode", NULL, NULL, NULL
select "GroupOwnerList", Code, ExternalCode, NULL, NULL, NULL
from CDB.dbo.Code 
where Type = 'ISDAIndustryType'
ORDER BY Code


/
EXEC sp_procxmode GroupOwnerList, unchained;
DROP PROCEDURE HolidayDefinitionDelete;
--/
CREATE PROCEDURE HolidayDefinitionDelete (
/**************************************************************************
**
** Procedure:	HolidayDefinitionDelete
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Calendar     int
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from HolidayDefinition 
where Calendar = @Calendar
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from HolidayDefinition table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from HolidayDefinition table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Calendar '" + convert(varchar(255), @Calendar) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode HolidayDefinitionDelete, unchained;
DROP PROCEDURE HolidayDefinitionInsert;
--/
CREATE PROCEDURE HolidayDefinitionInsert (
/**************************************************************************
**
** Procedure:	HolidayDefinitionInsert
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Calendar     int,
	@Weekend      binary(1)  = NULL,
	@CalendarName varchar(255)     = NULL
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into HolidayDefinition (
	Calendar,
	Weekend,
	CalendarName )
values (
	@Calendar,
	@Weekend,
	@CalendarName )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into HolidayDefinition table for key(s) "
	select @ErrorMessage = @ErrorMessage + "Calendar '" + convert(varchar(255), @Calendar) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode HolidayDefinitionInsert, unchained;
DROP PROCEDURE HolidayDefinitionUpdate;
--/
CREATE PROCEDURE HolidayDefinitionUpdate (
/**************************************************************************
**
** Procedure:	HolidayDefinitionUpdate
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Calendar     int,
	@Weekend      binary(1)  = 0x00,
	@CalendarName varchar(255)     = "#$%@"
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @weekend      binary(1) ,
        @calendarName varchar(255)    
select @weekend = Weekend,
       @calendarName = CalendarName
from HolidayDefinition
  where Calendar = @Calendar
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from HolidayDefinition table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from HolidayDefinition table for key(s) "
	goto ERROR_EXIT
end
if @Weekend != 0x00
	select @weekend = @Weekend
if @CalendarName != "#$%@"
	select @calendarName = @CalendarName
update HolidayDefinition
set	Weekend = @weekend,
	CalendarName = @calendarName
  where Calendar = @Calendar
if @@error != 0
begin
	select @ErrorMessage = "Could not update HolidayDefinition table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Calendar '" + convert(varchar(255), @Calendar) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode HolidayDefinitionUpdate, unchained;
DROP PROCEDURE HolidayDelete;
--/
CREATE PROCEDURE HolidayDelete (
/**************************************************************************
**
** Procedure:	HolidayDelete
**
** Version: 	@(#)HolidayDelete.proc	63.1 08/06/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Calendar    int,
	@Holiday     int        
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from Holiday 
where Calendar = @Calendar
and    Holiday = @Holiday
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from Holiday table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from Holiday table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Calendar '" + convert(varchar(255), @Calendar) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "Holiday '" + convert(varchar(255), @Holiday) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode HolidayDelete, unchained;
DROP PROCEDURE HolidayInsert;
--/
CREATE PROCEDURE HolidayInsert (
/**************************************************************************
**
** Procedure:	HolidayInsert
**
** Version: 	@(#)HolidayInsert.proc	63.1 08/06/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Calendar    int,
	@Holiday     int        ,
	@HolidayName varchar(255)     = NULL,
	@CRC         int      = NULL
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into Holiday (
	Calendar,
	Holiday,
	HolidayName,
	CRC )
values (
	@Calendar,
	@Holiday,
	@HolidayName,
	@CRC )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into Holiday table for key(s) "
	select @ErrorMessage = @ErrorMessage + "Calendar '" + convert(varchar(255), @Calendar) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "Holiday '" + convert(varchar(255), @Holiday) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode HolidayInsert, unchained;
DROP PROCEDURE HolidayUpdate;
--/
CREATE PROCEDURE HolidayUpdate (
/**************************************************************************
**
** Procedure:	HolidayUpdate
**
** Version: 	@(#)HolidayUpdate.proc	63.1 08/06/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Calendar    int,
	@Holiday     int        ,
	@HolidayName varchar(255)     = "#$%@",
	@CRC         int      = -2147483647
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @holidayName varchar(255)    ,
        @crc         int     
Select @holidayName = HolidayName,
       @crc = CRC
from Holiday
  where Calendar = @Calendar
  and Holiday = @Holiday
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from Holiday table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from Holiday table for key(s) "
	goto ERROR_EXIT
end
if @HolidayName != "#$%@"
	select @holidayName = @HolidayName
if @CRC != -2147483647
	select @crc = @CRC
Update Holiday
set	HolidayName = @holidayName,
	CRC = @crc
  where Calendar = @Calendar
  and Holiday = @Holiday
if @@error != 0
begin
	select @ErrorMessage = "Could not update Holiday table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Calendar '" + convert(varchar(255), @Calendar) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "Holiday '" + convert(varchar(255), @Holiday) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode HolidayUpdate, unchained;
DROP PROCEDURE IndigoGenerateEERSFile;
--/
CREATE PROCEDURE IndigoGenerateEERSFile
/**************************************************************
**
** Procedure:   IndigoGenerateEERSFile
**
** Version:     @(#)IndigoGenerateEERSFile.sp	132.1 04/27/10
**
** Notes:
**
*************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
/** EERS "UserRole" file Format **/
-- App ID|Last Name|First Name|Login ID|RITS ID|GEID ID|Function Title Code|Function Title Code Description|SOE ID|Second level entitlement description|External Drill down Code
--drop table #usergroup
--drop table #userpriv
/*** Get the Group details for a Particular USER from "CDB..TeamMemberGroupLink" ***/
create table #usergroup ( LastName varchar(20) null, FirstName varchar(20) null, SybaseID varchar(10) null,
		EmployeeIdentification int null, TeamMemberGroup varchar(70) null)
insert into #usergroup
select 
	case
		when charindex(",", tm.TeamMember) = 0 then "" -- Set "LastName" to NULL
		else rtrim(substring(tm.TeamMember, 1, charindex(",", tm.TeamMember) -1))
	end LastName,
  	ltrim(substring(tm.TeamMember, charindex(",", tm.TeamMember)+1,
					datalength(tm.TeamMember) - charindex(",", tm.TeamMember)) ) FirstName,
	tm.SybaseID, tm.EmployeeIdentification, tml.TeamMemberGroup
from CDB..TeamMemberGroupLink tml, CDB..TeamMember tm
where tm.TeamMember = tml.TeamMember
-- and (tm.TeamMember = 'Raghunath, Nikhil' or tm.TeamMember = 'Italia, Rustom')
and tm.TeamMemberType = 1 /*** We want ONLY USERS ***/
and tml.TeamMemberGroup not like '%exclude%' -- Exclude Firewall Groups to be sent to EERS.
/******* INDIVIDUAL PRIVILEGES ***************/
/** Since a USER can have Individual Privileges apart from GROUPS,
	we need to query CDB..TeamMemberPrivileges and CDB..Code.
**/
create table #userpriv ( LastName varchar(20) null, FirstName varchar(20) null, SybaseID varchar(10) null,
        EmployeeIdentification int null, TeamMemberPrivilege varchar(70) null)
insert into #userpriv
select
	case
		when charindex(",", tm.TeamMember) = 0 then "" -- Set "LastName" to NULL
		else substring(tm.TeamMember, 1, charindex(",", tm.TeamMember) -1)
	end LastName,
	ltrim(substring(tm.TeamMember, charindex(",", tm.TeamMember)+1,
				datalength(tm.TeamMember)-charindex(",", tm.TeamMember)) ) FirstName,
	tm.SybaseID, tm.EmployeeIdentification, tmp.TeamMemberPrivilege
from CDB..TeamMemberPrivileges tmp, CDB..TeamMember tm
where tm.TeamMember = tmp.TeamMember
--	and (tm.TeamMember = 'Raghunath, Nikhil' or tm.TeamMember = 'Italia, Rustom')
	and tm.TeamMemberType = 1 /*** We want ONLY USERS ***/
/** Now for Each GROUP in "#usergroup", get the corresponding "Description" from "CDB..TeamMember"
	since "Group" is also a TEAMMEMBER.
**/
select '161797	' + ltrim(convert(varchar(20), ug.LastName)) + '	' +  convert(varchar(20), ug.FirstName) + '	' + 
	convert(varchar(10), ug.SybaseID) + '	' + convert(varchar(20), ed.RITSID) + '	' +
	convert(varchar(20), ed.EmployeeIdentification) + '	' + convert(varchar(70), tm.TeamMember) + '	' +
	convert(varchar(255), tm.Description) + '	' + convert(varchar(10), ed.SOEID) + '		summ'
from CDB..TeamMember tm, #usergroup ug, CDB..EmployeeDetails ed
where tm.TeamMember = ug.TeamMemberGroup
    and ug.EmployeeIdentification = ed.EmployeeIdentification
    and ed.Title not in ('Client User','Client Security Manager')
order by ug.LastName, ug.FirstName
/** Now for Each INDIVIDUAL PRIVILEGE in "#userpriv", get the corresponding "Description" from "CDB..Code"
	NOTE:: DONOT ADD "summ" in the last field.
**/
/*** Since CDB..Code can have DUPLICATE "Code" entries, use "distinct" (E.g. AccessReportManager) ***/
select '161797	' + ltrim(convert(varchar(20), up.LastName)) + '	' + convert(varchar(20), up.FirstName) + '	' +
	convert(varchar(10),up.SybaseID) + '	' + convert(varchar(20),ed.RITSID) + '	' +
	convert(varchar(20),ed.EmployeeIdentification) + '	' + convert(varchar(70),up.TeamMemberPrivilege) + '	' +
	convert(varchar(255),c.Description) + '	' + convert(varchar(10),ed.SOEID)
from CDB..Code c, #userpriv up, CDB..EmployeeDetails ed
where c.Type = 'TeamMemberPrivilege'
	and  up.TeamMemberPrivilege = c.Code
	and up.EmployeeIdentification = ed.EmployeeIdentification
        and ed.Title not in ('Client User','Client Security Manager')
order by up.LastName, up.FirstName
STORED_PROC_EXIT:


/
EXEC sp_procxmode IndigoGenerateEERSFile, unchained;
DROP PROCEDURE IndigoGenerateEERSGlossaryFile;
--/
CREATE PROCEDURE IndigoGenerateEERSGlossaryFile
/**************************************************************
**
** Procedure:   IndigoGenerateEERSGlossaryFile
**
** Version:     @(#)IndigoGenerateEERSGlossaryFile.sp	132.1 04/27/10
**
** Notes:
**
*************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
-- THIS SQL GENERATES THE GLOSSARY FILE: "glossary161797"
--declare @group varchar(75), @privilege varchar(75), @privileges varchar(1900), @rowcount int
select '"161797","FunctionCode","' + convert(varchar(70), Code) + '","' + convert(varchar(255), Description)  + '"'
from CDB..Code
where Type = 'TeamMemberPrivilege'
order by Code
STORED_PROC_EXIT:


/
EXEC sp_procxmode IndigoGenerateEERSGlossaryFile, unchained;
DROP PROCEDURE IndigoGenerateEERSPolicyFile;
--/
CREATE PROCEDURE IndigoGenerateEERSPolicyFile
/**************************************************************
**
** Procedure:   IndigoGenerateEERSPolicyFile
**
** Version:     @(#)IndigoGenerateEERSPolicyFile.sp	132.1 04/27/10
**
** Notes:
**
*************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
-- THIS SQL GENERATES THE Policy File: "SUM_161797_policies"
--drop table #groups
--drop table #grouppriv
--drop table #TeamMemberPrivilege
select TeamMember, TeamMemberPrivilege = convert(varchar(1900), TeamMemberPrivilege)
  into #grouppriv from CDB..TeamMemberPrivileges where 1=2
select DISTINCT tm.TeamMember
into #groups
from CDB..TeamMember tm
where tm.TeamMemberType = 2
	and tm.TeamMember not like '%exclude%' -- Exclude Firewall groups from feeding to EERS.
    and (UPPER(Description) not like '%DELTED%')
    and (UPPER(Description) not like '%DELETE%')
    and (UPPER(Description) not like '%PROFILE%')
select TeamMemberPrivilege
into #TeamMemberPrivilege from  CDB..TeamMemberPrivileges    
 where 1=2
set rowcount 1
while 1=1
  begin
    loopback:
    
declare @group varchar(75), @privilege varchar(75), @privileges varchar(1800), @rowcount int
    select @group = TeamMember from #groups
--    select  TeamMember from #groups
    
    if @@rowcount = 0
      break
      
    set rowcount 0  
	insert into #TeamMemberPrivilege
		select TeamMemberPrivilege
			from  CDB..TeamMemberPrivileges    
		    where TeamMember = @group
    set rowcount 1
    
    select @privileges = ''
    while 1 = 1 
      begin
      
        select @privilege = TeamMemberPrivilege  FROM #TeamMemberPrivilege 
          
--		if @privileges == ''
--			select @privileges = @privilege + ','
--		else
        	select @privileges = @privileges + @privilege + ','
        
        delete #TeamMemberPrivilege
        if @@rowcount = 0
        begin
--   drop table #TeamMemberPrivilege
         break
        end
      end
      
    insert #grouppriv
    select @group, substring(@privileges, 1, char_length(@privileges)-1)
    
    delete #groups
  end  
set rowcount 0
select '"161797","161797' + convert(varchar(70), TeamMember) + '","","' + '' + ltrim(convert(varchar(2000),TeamMemberPrivilege)) + '","161797' + TeamMember + '"'
 from #grouppriv
STORED_PROC_EXIT:


/
EXEC sp_procxmode IndigoGenerateEERSPolicyFile, unchained;
DROP PROCEDURE IndigoGenerateEERSRoleFile;
--/
CREATE PROCEDURE IndigoGenerateEERSRoleFile
/**************************************************************
**
** Procedure:   IndigoGenerateEERSRoleFile
**
** Version:     @(#)IndigoGenerateEERSRoleFile.sp	132.1 04/27/10
**
** Notes:
**
*************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
-- THIS SQL GENERATES THE Role File: "role161797"
set nocount on
select '"161797' + convert(varchar(70), tm.TeamMember) + '","' + convert(varchar(255), tm.TeamMember) + '","' + convert(varchar(70), ed.SOEID) + '"'
from CDB..TeamMember tm, CDB..EmployeeDetails ed
where TeamMemberType = 2
and tm.Owner *= ed.TeamMember
STORED_PROC_EXIT:


/
EXEC sp_procxmode IndigoGenerateEERSRoleFile, unchained;
DROP PROCEDURE IndustryType;
--/
CREATE PROCEDURE IndustryType
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "%W% %G%"
select "CodeType", "IndustryType", "ExternalCode", NULL, NULL, NULL
select "IndustryType", Code, ExternalCode, NULL, NULL, NULL
from CDB.dbo.Code 
where Type = 'ISDAIndustryType'
ORDER BY Code


/
EXEC sp_procxmode IndustryType, unchained;
DROP PROCEDURE InterestServiceRepAsCode;
--/
CREATE PROCEDURE InterestServiceRepAsCode
/**********************************************************************************
**
**
** Procedure : InterestServiceRepAsCode
**
** Version   :    @(#)InterestServiceRepAsCode.proc	1.0 28/04/11 
**
** Notes     : 
**
**********************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select @version = "@(#)InterestServiceRepAsCode.proc	1.0 28/04/11"
select "CodeType", "InterestServiceRep", NULL, NULL, NULL, NULL
select "InterestServiceRep", ServiceRep, NULL, NULL, NULL, NULL from CMDB..ServiceRepProfile where Type in (null,'ISR')
 order by ServiceRep


/
EXEC sp_procxmode InterestServiceRepAsCode, unchained;
DROP PROCEDURE LeadStructurer;
--/
CREATE PROCEDURE LeadStructurer
/**********************************************************************
** Procedure : LeadStructurer
** Notes     :
**********************************************************************/
as 
set compatibility_mode off  
set plan optgoal allrows_oltp 
set plan optlevel ase_current
declare @version  varchar(255)
select @version = "%W% %G%"
select c.Type, c.Code, c.LongName, t.SybaseID
from CDB..Code c, CDB..TeamMember t
where Type = 'LeadStructurer'
and c.Code *= t.TeamMember


/
EXEC sp_procxmode LeadStructurer, unchained;
DROP PROCEDURE LegalEntityLogoDelete;
--/
CREATE PROCEDURE LegalEntityLogoDelete (
/**************************************************************************
**
** Procedure:	LegalEntityLogoDelete
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@LogoName varchar(40)
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from LegalEntityLogo 
where LogoName = @LogoName
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from LegalEntityLogo table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from LegalEntityLogo table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "LogoName '" + convert(varchar(255), @LogoName) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode LegalEntityLogoDelete, unchained;
DROP PROCEDURE MCA_ControlReport;
--/
CREATE PROCEDURE MCA_ControlReport (@report_id int)
as
    declare 
    @DataMapID varchar(100),
    @CreateTableSql varchar(1000),
    @UpdateSql varchar(1000),
    @SelectSql varchar(3000),
    @KeyFieldName varchar(50),
    @ListFieldName varchar(50),
    @KeyFieldCount int,
    --@ListFieldCount int,
	--@IsKeyColumnVisible varchar(1),
    @KeyFieldCounter int,
    @ListFieldCounter int,
    --@SingleElementList varchar(1),
    @KeyFieldValue varchar(255),
    @ListFieldValue varchar(1000),
    @DataInstanceNumber int,
	@ListElementNumber int
	
	select @DataMapID ='MnemonicMCAMapping'
    select
        @KeyFieldCount = KeyFieldCount
        --@ListFieldCount = ListFieldCount,
        --@SingleElementList = SingleElementList,
        --@IsKeyColumnVisible = IsKeyColumnVisible
    from
        CDB..DataMapConfig
    where
        DataMapID = @DataMapID
	
    create table #DataMapRes
    (
        DataMapSequenceNumber int,
        DataInstanceNumber int,
        LongName varchar(255) null,
        UserOperationType varchar(40) null,
        Maker varchar(100) null,
        MakerOperationTimestamp datetime null,
        Checker varchar(100) null,
        CheckerOperationTimestamp datetime null,
        DTCCID varchar(40) null,
        ExceptionString varchar(40) null,
        KeyValue1 varchar(255) null,
        KeyValue2 varchar(255) null,
        KeyValue3 varchar(255) null,
        KeyValue4 varchar(255) null,
        KeyValue5 varchar(255) null,
        KeyValue6 varchar(255) null,
        KeyValue7 varchar(255) null,
        KeyValue8 varchar(255) null,
        KeyValue9 varchar(255) null,
        KeyValue10 varchar(255) null,
        KeyValue11 varchar(255) null,
        KeyValue12 varchar(255) null,
        KeyValue13 varchar(255) null,
        ListValue1 varchar(255) null,
        ListValue2 varchar(255) null,
        ListValue3 varchar(255) null,
        ListValue4 varchar(255) null,
        ListValue5 varchar(255) null,
        ListValue6 varchar(255) null,
        ListValue7 varchar(255) null,
        ListValue8 varchar(255) null,
        ListValue9 varchar(255) null,
        ListValue10 varchar(255) null
    )
	
	 
	begin
    insert into #DataMapRes
    (
        DataMapSequenceNumber,
        DataInstanceNumber,
        UserOperationType,
        Checker,
        CheckerOperationTimestamp,
        Maker,
        MakerOperationTimestamp
        
    )
    select DataMapSequenceNumber,
             DataInstanceNumber,
             UserOperationType,
             Checker,
             CheckerOperationTimestamp,
             Maker,
             MakerOperationTimestamp
    from
    CDB..DataMapContent a, CDB..UserActivity b
    where
        a.DataMapID = @DataMapID 
        and a.DataMapSequenceNumber = b.ReferenceKey 
        and b.IsLastAuditEntry = 'Y' 
        and DataMapInstanceStatus = 'Active'
	end   
    create table #DataMap
    (
        DataInstanceNumber int,
        ListValue1 varchar(255) null,
        ListValue2 varchar(255) null,
        ListValue3 varchar(255) null,
        ListValue4 varchar(255) null,
        ListValue5 varchar(255) null,
        ListValue6 varchar(255) null,
        ListValue7 varchar(255) null,
        ListValue8 varchar(255) null,
        ListValue9 varchar(255) null,
        ListValue10 varchar(255) null
    )
    
    
    
    --if @SingleElementList = 'Y' 
    BEGIN
    
        insert into #DataMap(
            DataInstanceNumber,
            ListValue1,
            ListValue2,
            ListValue3,
            ListValue4,
            ListValue5,
            ListValue6,
            ListValue7,
            ListValue8,
            ListValue9,
            ListValue10)
        select 
            ldc.DataInstanceNumber,
            max(case when ldc.ListFieldNumber = 1 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 2 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 3 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 4 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 5 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 6 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 7 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 8 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 9 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 10 then ListFieldValue end)
        from CDB..ListDataContent ldc
        where ldc.DataMapID = @DataMapID
        group by ldc.DataMapID, ldc.DataInstanceNumber   
    END
    
    select @KeyFieldCounter = 0
    while (@KeyFieldCounter < @KeyFieldCount)
    begin 
        select @UpdateSql = 'update #DataMapRes set KeyValue' + convert(varchar,@KeyFieldCounter+1) + ' =  kdc.KeyFieldValue from CDB..KeyDataContent kdc where kdc.DataMapID = @DataMapID and kdc.DataInstanceNumber = #DataMapRes.DataInstanceNumber and kdc.KeyFieldNumber = ' + convert(varchar,@KeyFieldCounter+1)
        
        exec (@UpdateSql)
        
        select @KeyFieldCounter = @KeyFieldCounter + 1
    end
    
    update #DataMapRes 
    set  
        ListValue1 = dm.ListValue1,
        ListValue2 = dm.ListValue2,
        ListValue3 = dm.ListValue3,
        ListValue4 = dm.ListValue4,
        ListValue5 = dm.ListValue5,
        ListValue6 = dm.ListValue6,
        ListValue7 = dm.ListValue7,
        ListValue8 = dm.ListValue8,
        ListValue9 = dm.ListValue9,
        ListValue10 = dm.ListValue10
    from #DataMap dm
    where #DataMapRes.DataInstanceNumber = dm.DataInstanceNumber
    
   update #DataMapRes
      set LongName = ca.LongName
   from ADB..CustomerAccount ca, #DataMapRes dmr
   where ca.Mnemonic = dmr.KeyValue1   
 
   update  #DataMapRes
      set DTCCID = da.DTCCCustomerID
   from WFDB..DTCCCustAccLink da, #DataMapRes dmr
   where da.CustomerMnemonic = dmr.KeyValue1
   update  #DataMapRes
      set ExceptionString = ''
      
   select @SelectSql = 'select distinct KeyValue1 as "pc-mnemonic", LongName, KeyValue2 as "product",KeyValue3 as "region",KeyValue4 as "citiEntity",ListValue4 as "CounterpartyType",ListValue2 as "SignedDate",            ListValue5 as "Party",KeyValue5 as "UnderlyingType", KeyValue6 as "SettlementType", ListValue6 as "TemplateVersion",Maker as "lastmaker",MakerOperationTimestamp as "lastmakerdatetime",Checker as "lastchecker", CheckerOperationTimestamp as "lastcheckerdatetime",ExceptionString,DTCCID as "dtcc_id",ListValue1 as "MCA_type" '
                        
    select @SelectSql = @SelectSql +  ' from #DataMapRes'
    
    exec (@SelectSql)


/
EXEC sp_procxmode MCA_ControlReport, unchained;
DROP PROCEDURE MCA_FeedSync;
--/
CREATE PROCEDURE MCA_FeedSync(@isBulk int)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
    declare 
    @DataMapID varchar(100),
    @CreateTableSql varchar(1000),
    @UpdateSql varchar(1000),
    @SelectSql varchar(3000),
    @KeyFieldName varchar(50),
    @ListFieldName varchar(50),
    @KeyFieldCount int,
    --@ListFieldCount int,
	--@IsKeyColumnVisible varchar(1),
    @KeyFieldCounter int,
    @ListFieldCounter int,
    --@SingleElementList varchar(1),
    @KeyFieldValue varchar(255),
    @ListFieldValue varchar(1000),
    @DataInstanceNumber int,
	@ListElementNumber int,
    @Asof datetime,
    @currentTime datetime
	
	select @DataMapID ='MnemonicMCAMapping'
    select
        @KeyFieldCount = KeyFieldCount
        --@ListFieldCount = ListFieldCount,
        --@SingleElementList = SingleElementList,
        --@IsKeyColumnVisible = IsKeyColumnVisible
    from
        CDB..DataMapConfig
    where
        DataMapID = @DataMapID
	
    create table #DataMapRes
    (
        AsOf  varchar(255) null,
        Status varchar(255) null,
        DataMapSequenceNumber int,
        DataInstanceNumber int,
        LongName varchar(255) null,
        UserOperationType varchar(40) null,
        Maker varchar(100) null,
        MakerOperationTimestamp datetime null,
        Checker varchar(100) null,
        CheckerOperationTimestamp datetime null,
        DTCCID varchar(40) null,
        ExceptionString varchar(40) null,
        KeyValue1 varchar(255) null,
        KeyValue2 varchar(255) null,
        KeyValue3 varchar(255) null,
        KeyValue4 varchar(255) null,
        KeyValue5 varchar(255) null,
        KeyValue6 varchar(255) null,
        KeyValue7 varchar(255) null,
        KeyValue8 varchar(255) null,
        KeyValue9 varchar(255) null,
        KeyValue10 varchar(255) null,
        KeyValue11 varchar(255) null,
        KeyValue12 varchar(255) null,
        KeyValue13 varchar(255) null,
        ListValue1 varchar(255) null,
        ListValue2 varchar(255) null,
        ListValue3 varchar(255) null,
        ListValue4 varchar(255) null,
        ListValue5 varchar(255) null,
        ListValue6 varchar(255) null,
        ListValue7 varchar(255) null,
        ListValue8 varchar(255) null,
        ListValue9 varchar(255) null,
        ListValue10 varchar(255) null
    )
	
    IF (@isBulk != 0 AND @isBulk != 1)
      return
--BEGIN
    select @Asof=AsOf from EODDB..LastCycleDate where Application = 'MCA_FeedSync'
    --select @Asof
    select @currentTime = getDate()
    --select @currentTime
    IF @isBulk = 0 
    BEGIN
            insert into #DataMapRes
            (
                Status,
                DataMapSequenceNumber,
                DataInstanceNumber,
                UserOperationType,
                Checker,
                CheckerOperationTimestamp,
                Maker,
                MakerOperationTimestamp
                
            )
            select   DataMapInstanceStatus,
                     DataMapSequenceNumber,
                     DataInstanceNumber,
                     UserOperationType,
                     Checker,
                     CheckerOperationTimestamp,
                     Maker,
                     MakerOperationTimestamp
            from
            CDB..DataMapContent a, CDB..UserActivity b
            where
            a.DataMapID = @DataMapID 
            and a.DataMapSequenceNumber = b.ReferenceKey 
            and b.IsLastAuditEntry = 'Y' 
            --and a.DataMapInstanceStatus = 'Active'
            and b.MakerOperationTimestamp >= @Asof and b.MakerOperationTimestamp < @currentTime
    END
    ELSE IF @isBulk = 1
    BEGIN
            insert into #DataMapRes
            (
                Status,
                DataMapSequenceNumber,
                DataInstanceNumber,
                UserOperationType,
                Checker,
                CheckerOperationTimestamp,
                Maker,
                MakerOperationTimestamp
                
            )
            select   DataMapInstanceStatus,
                 DataMapSequenceNumber,
                 DataInstanceNumber,
                 UserOperationType,
                 Checker,
                 CheckerOperationTimestamp,
                 Maker,
                 MakerOperationTimestamp
            from
            CDB..DataMapContent a, CDB..UserActivity b
                where
                a.DataMapID = @DataMapID 
                and a.DataMapSequenceNumber = b.ReferenceKey 
                and b.IsLastAuditEntry = 'Y' 
    END
    create table #DataMap
    (
        DataInstanceNumber int,
        ListValue1 varchar(255) null,
        ListValue2 varchar(255) null,
        ListValue3 varchar(255) null,
        ListValue4 varchar(255) null,
        ListValue5 varchar(255) null,
        ListValue6 varchar(255) null,
        ListValue7 varchar(255) null,
        ListValue8 varchar(255) null,
        ListValue9 varchar(255) null,
        ListValue10 varchar(255) null
    )
    
    
    
    --if @SingleElementList = 'Y' 
    BEGIN
    
        insert into #DataMap(
            DataInstanceNumber,
            ListValue1,
            ListValue2,
            ListValue3,
            ListValue4,
            ListValue5,
            ListValue6,
            ListValue7,
            ListValue8,
            ListValue9,
            ListValue10)
        select 
            ldc.DataInstanceNumber,
            max(case when ldc.ListFieldNumber = 1 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 2 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 3 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 4 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 5 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 6 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 7 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 8 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 9 then ListFieldValue end),
            max(case when ldc.ListFieldNumber = 10 then ListFieldValue end)
        from CDB..ListDataContent ldc
        where ldc.DataMapID = @DataMapID
        group by ldc.DataMapID, ldc.DataInstanceNumber   
    END
    
    select @KeyFieldCounter = 0
    while (@KeyFieldCounter < @KeyFieldCount)
    begin 
        select @UpdateSql = 'update #DataMapRes set KeyValue' + convert(varchar,@KeyFieldCounter+1) + ' =  kdc.KeyFieldValue from CDB..KeyDataContent kdc where kdc.DataMapID = @DataMapID and kdc.DataInstanceNumber = #DataMapRes.DataInstanceNumber and kdc.KeyFieldNumber = ' + convert(varchar,@KeyFieldCounter+1)
        
        exec (@UpdateSql)
        
        select @KeyFieldCounter = @KeyFieldCounter + 1
    end
    
    update #DataMapRes 
    set  
        ListValue1 = dm.ListValue1,
        ListValue2 = dm.ListValue2,
        ListValue3 = dm.ListValue3,
        ListValue4 = dm.ListValue4,
        ListValue5 = dm.ListValue5,
        ListValue6 = dm.ListValue6,
        ListValue7 = dm.ListValue7,
        ListValue8 = dm.ListValue8,
        ListValue9 = dm.ListValue9,
        ListValue10 = dm.ListValue10
    from #DataMap dm
    where #DataMapRes.DataInstanceNumber = dm.DataInstanceNumber
    
   update #DataMapRes
      set LongName = ca.LongName
   from ADB..CustomerAccount ca, #DataMapRes dmr
   where ca.Mnemonic = dmr.KeyValue1   
 
   update  #DataMapRes
      set DTCCID = da.DTCCCustomerID
   from WFDB..DTCCCustAccLink da, #DataMapRes dmr
   where da.CustomerMnemonic = dmr.KeyValue1
   update  #DataMapRes
      set AsOf= convert(varchar(255),@Asof,9), ExceptionString = '',Status='Active'
      
   update EODDB..LastCycleDate 
      set AsOf=convert(varchar(255),@currentTime,9)
      where Application = 'MCA_FeedSync'
      
   select @SelectSql = 'select distinct AsOf,Status, KeyValue1 as "Cp_Mnemonic", KeyValue2 as "Product",KeyValue3 as "Region",KeyValue4 as "LegalVehicle",KeyValue5 as "UnderlyingType",KeyValue6 as "SettlementType", ListValue4 as "CounterpartyType",ListValue2 as "SignedDate", ListValue5 as "Party",  ListValue6 as "TemplateVersion",Maker as "LastMaker",MakerOperationTimestamp as "LastMakerDateTime",Checker as "LastChecker", CheckerOperationTimestamp as "LastCheckerDateTime",DTCCID as "DTCC_ID",ListValue1 as "MCA_Type" '
   
   
-- select @SelectSql = 'select distinct Status, KeyValue1 as "Cp-Mnemonic", LongName, KeyValue2 as "product",KeyValue3 as "region",KeyValue4 as "citiEntity",ListValue4 as "CounterpartyType",ListValue2 as "SignedDate", ListValue5 as "Party",KeyValue5 as "UnderlyingType", KeyValue6 as "SettlementType", ListValue6 as "TemplateVersion",Maker as "lastmaker",MakerOperationTimestamp as "lastmakerdatetime",Checker as "lastchecker", CheckerOperationTimestamp as "lastcheckerdatetime",ExceptionString,DTCCID as "dtcc_id",ListValue1 as "MCA_type" '
                        
    select @SelectSql = @SelectSql +  ' from #DataMapRes' -- where DTCCID is not null'
    
    exec (@SelectSql)


/
EXEC sp_procxmode MCA_FeedSync, unchained;
DROP PROCEDURE MarginTimeZoneAsCode;
--/
CREATE PROCEDURE MarginTimeZoneAsCode
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "%W% %G%"
select "CodeType", "MarginTimeZone", NULL, NULL, NULL, NULL
select "MarginTimeZone", Code, NULL, NULL, NULL, NULL
from CDB..Code 
where Type = 'TimeZoneType'


/
EXEC sp_procxmode MarginTimeZoneAsCode, unchained;
DROP PROCEDURE MarkFilesByHostName;
--/
CREATE PROCEDURE MarkFilesByHostName (
/**********************************************************************************
**
**
** Procedure : MarkFilesByHostName
**
** Version   : %W% %G%
**
** Notes     :
**
**********************************************************************************/
        @HostName 	varchar(50)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
        declare  @version  varchar(255)
        select   @version = "%W% %G%"
        select
               	E.UsersHomeDir + ',' + F.InputFileDir +','+ F.MarkFileName
        from
                CDB..MarkImportEnvConfig E, CDB..MarkImportFeedConfig F
	where
		F.Machine	= @HostName
	and 
		E.Environment 	= F.Environment
	and 
		E.Machine	= F.Machine
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode MarkFilesByHostName, unchained;
DROP PROCEDURE MarkFilesByMarkingSystem;
--/
CREATE PROCEDURE MarkFilesByMarkingSystem(
/**********************************************************************************
**
**
** Procedure : MarkFilesByMarkingSystem
**
** Version   : %W% %G%
**
** Notes     :
**
**********************************************************************************/
        @MarkingSystem varchar(25)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
        declare  @version  varchar(255)
        select   @version = "%W% %G%"
        /* Adaptive Server has expanded all '*' elements in the following statement */ select
               	CDB..MarkImportFeedConfig.MarkFileName, CDB..MarkImportFeedConfig.MarkingSystem, CDB..MarkImportFeedConfig.FeedType, CDB..MarkImportFeedConfig.InputFileDir, CDB..MarkImportFeedConfig.CalculateBrowserMarks, CDB..MarkImportFeedConfig.MakeSwapBufferOnly, CDB..MarkImportFeedConfig.NoMarkAdjustment, CDB..MarkImportFeedConfig.NoMarkAdjPmtOnValueDate, CDB..MarkImportFeedConfig.NoMarkAdjPerStartMisMatch, CDB..MarkImportFeedConfig.NoMarkFeeAdjustment, CDB..MarkImportFeedConfig.PrintSwapBufferOnly, CDB..MarkImportFeedConfig.SaveBrowserMarksToDB, CDB..MarkImportFeedConfig.SaveMarksToDB, CDB..MarkImportFeedConfig.TestSwapBuffer, CDB..MarkImportFeedConfig.TrxMarkAdjustment, CDB..MarkImportFeedConfig.UseActualMTMPolicy, CDB..MarkImportFeedConfig.CollectorMarkOption, CDB..MarkImportFeedConfig.BrowserMarkFlag, CDB..MarkImportFeedConfig.CollectorMarkFlag, CDB..MarkImportFeedConfig.CreditMarkFlag, CDB..MarkImportFeedConfig.FinancialMarkFlag, CDB..MarkImportFeedConfig.JobStatusFlag, CDB..MarkImportFeedConfig.ImportMarkFlag, CDB..MarkImportFeedConfig.MarkFileSplitFlag, CDB..MarkImportFeedConfig.MarkFileSplitSize, CDB..MarkImportFeedConfig.MaxFileSplitNumber, CDB..MarkImportFeedConfig.MaxReprocessNumber, CDB..MarkImportFeedConfig.MarkFileSourceLocation, CDB..MarkImportFeedConfig.OafnLocationCode, CDB..MarkImportFeedConfig.OafnDeskCode, CDB..MarkImportFeedConfig.OafnSwapCode, CDB..MarkImportFeedConfig.Environment, CDB..MarkImportFeedConfig.Machine, CDB..MarkImportFeedConfig.DataBaseServer, CDB..MarkImportFeedConfig.OafnTargetDir, CDB..MarkImportFeedConfig.OafnContTargetDir, CDB..MarkImportFeedConfig.JobStatusTargetServer, CDB..MarkImportFeedConfig.JobStatusTargetDir, CDB..MarkImportFeedConfig.JobStatusFtpID, CDB..MarkImportFeedConfig.JobStatusFtpPassword, CDB..MarkImportFeedConfig.MarkingSystemContact, CDB..MarkImportFeedConfig.MarkingSystemGroupEmail, CDB..MarkImportFeedConfig.MarkingSysPassedFlag, CDB..MarkImportFeedConfig.CheckMarkFileSize, CDB..MarkImportFeedConfig.CPMBrowserMarkFlag, CDB..MarkImportFeedConfig.CPMFinancialMarkFlag, CDB..MarkImportFeedConfig.FinancialSftpFlag, CDB..MarkImportFeedConfig.JobStatusSftpFlag, CDB..MarkImportFeedConfig.SkipPFSFlag, CDB..MarkImportFeedConfig.FinMarkFileGenFirst
        from
                CDB..MarkImportFeedConfig 
	where
		MarkingSystem = @MarkingSystem
	and 
		Machine not like '%BAK'
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode MarkFilesByMarkingSystem, unchained;
DROP PROCEDURE MarkImportEnvConfigDelete;
--/
CREATE PROCEDURE MarkImportEnvConfigDelete (
/**************************************************************************
**
** Procedure:	MarkImportEnvConfigDelete
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Environment       varchar(25) ,
	@Machine           varchar(50)
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from MarkImportEnvConfig 
where Environment = @Environment
and    Machine = @Machine
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from MarkImportEnvConfig table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from MarkImportEnvConfig table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Environment '" + convert(varchar(255), @Environment) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "Machine '" + convert(varchar(255), @Machine) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode MarkImportEnvConfigDelete, unchained;
DROP PROCEDURE MarkImportEnvConfigInsert;
--/
CREATE PROCEDURE MarkImportEnvConfigInsert (
/**************************************************************************
**
** Procedure:	MarkImportEnvConfigInsert
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Environment       varchar(25) ,
	@Machine           varchar(50),
	@DataBaseServer    varchar(50) = NULL,
	@ArchiveMarkDir    varchar(150)   = NULL,
	@BrowserMarkDir    varchar(150)   = NULL,
	@CollectorMarkDir  varchar(150)   = NULL,
	@CreditMarkDir     varchar(150)   = NULL,
	@FinancialMarkDir  varchar(150)   = NULL,
	@StatusDir         varchar(150)   = NULL,
	@UploadMarkDir     varchar(150)   = NULL,
	@CreditMTMKeyDir   varchar(150)   = NULL,
	@CreditMTMKeyQADir varchar(150)   = NULL,
	@OafnServer        varchar(50) = NULL,
	@OafnContServer    varchar(50) = NULL,
	@FtpID             varchar(25)  = NULL,
	@FtpPassword       varchar(25)  = NULL,
	@SwapcoServer      varchar(50) = NULL,
	@SwapcoContServer  varchar(50) = NULL,
	@SwapcoFtpID       varchar(25)  = NULL,
	@SwapcoFtpPassword varchar(25)  = NULL,
	@OperatorHomeDir   varchar(150)   = NULL,
	@UsersHomeDir      varchar(150)   = NULL,
	@FtpHomeDir        varchar(150)   = NULL,
	@OatcFtpServer     varchar(50) = NULL,
	@OatcContFtpServer varchar(50) = NULL,
	@CPMBrowserMarkDir varchar(150)   = NULL
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into MarkImportEnvConfig (
	Environment,
	Machine,
	DataBaseServer,
	ArchiveMarkDir,
	BrowserMarkDir,
	CollectorMarkDir,
	CreditMarkDir,
	FinancialMarkDir,
	StatusDir,
	UploadMarkDir,
	CreditMTMKeyDir,
	CreditMTMKeyQADir,
	OafnServer,
	OafnContServer,
	FtpID,
	FtpPassword,
	SwapcoServer,
	SwapcoContServer,
	SwapcoFtpID,
	SwapcoFtpPassword,
	OperatorHomeDir,
	UsersHomeDir,
	FtpHomeDir,
	OatcFtpServer,
	OatcContFtpServer,
	CPMBrowserMarkDir )
values (
	@Environment,
	@Machine,
	@DataBaseServer,
	@ArchiveMarkDir,
	@BrowserMarkDir,
	@CollectorMarkDir,
	@CreditMarkDir,
	@FinancialMarkDir,
	@StatusDir,
	@UploadMarkDir,
	@CreditMTMKeyDir,
	@CreditMTMKeyQADir,
	@OafnServer,
	@OafnContServer,
	@FtpID,
	@FtpPassword,
	@SwapcoServer,
	@SwapcoContServer,
	@SwapcoFtpID,
	@SwapcoFtpPassword,
	@OperatorHomeDir,
	@UsersHomeDir,
	@FtpHomeDir,
	@OatcFtpServer,
	@OatcContFtpServer,
	@CPMBrowserMarkDir )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into MarkImportEnvConfig table for key(s) "
	select @ErrorMessage = @ErrorMessage + "Environment '" + convert(varchar(255), @Environment) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "Machine '" + convert(varchar(255), @Machine) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode MarkImportEnvConfigInsert, unchained;
DROP PROCEDURE MarkImportEnvConfigUpdate;
--/
CREATE PROCEDURE MarkImportEnvConfigUpdate (
/**************************************************************************
**
** Procedure:	MarkImportEnvConfigUpdate
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Environment       varchar(25) ,
	@Machine           varchar(50),
	@DataBaseServer    varchar(50) = "#$%@",
	@ArchiveMarkDir    varchar(150)   = "#$%@",
	@BrowserMarkDir    varchar(150)   = "#$%@",
	@CollectorMarkDir  varchar(150)   = "#$%@",
	@CreditMarkDir     varchar(150)   = "#$%@",
	@FinancialMarkDir  varchar(150)   = "#$%@",
	@StatusDir         varchar(150)   = "#$%@",
	@UploadMarkDir     varchar(150)   = "#$%@",
	@CreditMTMKeyDir   varchar(150)   = "#$%@",
	@CreditMTMKeyQADir varchar(150)   = "#$%@",
	@OafnServer        varchar(50) = "#$%@",
	@OafnContServer    varchar(50) = "#$%@",
	@FtpID             varchar(25)  = "#$%@",
	@FtpPassword       varchar(25)  = "#$%@",
	@SwapcoServer      varchar(50) = "#$%@",
	@SwapcoContServer  varchar(50) = "#$%@",
	@SwapcoFtpID       varchar(25)  = "#$%@",
	@SwapcoFtpPassword varchar(25)  = "#$%@",
	@OperatorHomeDir   varchar(150)   = "#$%@",
	@UsersHomeDir      varchar(150)   = "#$%@",
	@FtpHomeDir        varchar(150)   = "#$%@",
	@OatcFtpServer     varchar(50) = "#$%@",
	@OatcContFtpServer varchar(50) = "#$%@",
	@CPMBrowserMarkDir varchar(150)   = "#$%@"
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @dataBaseServer    varchar(50),
        @archiveMarkDir    varchar(150)  ,
        @browserMarkDir    varchar(150)  ,
        @collectorMarkDir  varchar(150)  ,
        @creditMarkDir     varchar(150)  ,
        @financialMarkDir  varchar(150)  ,
        @statusDir         varchar(150)  ,
        @uploadMarkDir     varchar(150)  ,
        @creditMTMKeyDir   varchar(150)  ,
        @creditMTMKeyQADir varchar(150)  ,
        @oafnServer        varchar(50),
        @oafnContServer    varchar(50),
        @ftpID             varchar(25) ,
        @ftpPassword       varchar(25) ,
        @swapcoServer      varchar(50),
        @swapcoContServer  varchar(50),
        @swapcoFtpID       varchar(25) ,
        @swapcoFtpPassword varchar(25) ,
        @operatorHomeDir   varchar(150)  ,
        @usersHomeDir      varchar(150)  ,
        @ftpHomeDir        varchar(150)  ,
        @oatcFtpServer     varchar(50),
        @oatcContFtpServer varchar(50),
        @cpmBrowserMarkDir varchar(150)  
Select @dataBaseServer = DataBaseServer,
       @archiveMarkDir = ArchiveMarkDir,
       @browserMarkDir = BrowserMarkDir,
       @collectorMarkDir = CollectorMarkDir,
       @creditMarkDir = CreditMarkDir,
       @financialMarkDir = FinancialMarkDir,
       @statusDir = StatusDir,
       @uploadMarkDir = UploadMarkDir,
       @creditMTMKeyDir = CreditMTMKeyDir,
       @creditMTMKeyQADir = CreditMTMKeyQADir,
       @oafnServer = OafnServer,
       @oafnContServer = OafnContServer,
       @ftpID = FtpID,
       @ftpPassword = FtpPassword,
       @swapcoServer = SwapcoServer,
       @swapcoContServer = SwapcoContServer,
       @swapcoFtpID = SwapcoFtpID,
       @swapcoFtpPassword = SwapcoFtpPassword,
       @operatorHomeDir = OperatorHomeDir,
       @usersHomeDir = UsersHomeDir,
       @ftpHomeDir = FtpHomeDir,
       @oatcFtpServer = OatcFtpServer,
       @oatcContFtpServer = OatcContFtpServer,
       @cpmBrowserMarkDir = CPMBrowserMarkDir
from MarkImportEnvConfig
  where Environment = @Environment
  and Machine = @Machine
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from MarkImportEnvConfig table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from MarkImportEnvConfig table for key(s) "
	goto ERROR_EXIT
end
if @DataBaseServer != "#$%@"
	select @dataBaseServer = @DataBaseServer
if @ArchiveMarkDir != "#$%@"
	select @archiveMarkDir = @ArchiveMarkDir
if @BrowserMarkDir != "#$%@"
	select @browserMarkDir = @BrowserMarkDir
if @CollectorMarkDir != "#$%@"
	select @collectorMarkDir = @CollectorMarkDir
if @CreditMarkDir != "#$%@"
	select @creditMarkDir = @CreditMarkDir
if @FinancialMarkDir != "#$%@"
	select @financialMarkDir = @FinancialMarkDir
if @StatusDir != "#$%@"
	select @statusDir = @StatusDir
if @UploadMarkDir != "#$%@"
	select @uploadMarkDir = @UploadMarkDir
if @CreditMTMKeyDir != "#$%@"
	select @creditMTMKeyDir = @CreditMTMKeyDir
if @CreditMTMKeyQADir != "#$%@"
	select @creditMTMKeyQADir = @CreditMTMKeyQADir
if @OafnServer != "#$%@"
	select @oafnServer = @OafnServer
if @OafnContServer != "#$%@"
	select @oafnContServer = @OafnContServer
if @FtpID != "#$%@"
	select @ftpID = @FtpID
if @FtpPassword != "#$%@"
	select @ftpPassword = @FtpPassword
if @SwapcoServer != "#$%@"
	select @swapcoServer = @SwapcoServer
if @SwapcoContServer != "#$%@"
	select @swapcoContServer = @SwapcoContServer
if @SwapcoFtpID != "#$%@"
	select @swapcoFtpID = @SwapcoFtpID
if @SwapcoFtpPassword != "#$%@"
	select @swapcoFtpPassword = @SwapcoFtpPassword
if @OperatorHomeDir != "#$%@"
	select @operatorHomeDir = @OperatorHomeDir
if @UsersHomeDir != "#$%@"
	select @usersHomeDir = @UsersHomeDir
if @FtpHomeDir != "#$%@"
	select @ftpHomeDir = @FtpHomeDir
if @OatcFtpServer != "#$%@"
	select @oatcFtpServer = @OatcFtpServer
if @OatcContFtpServer != "#$%@"
	select @oatcContFtpServer = @OatcContFtpServer
if @CPMBrowserMarkDir != "#$%@"
	select @cpmBrowserMarkDir = @CPMBrowserMarkDir
Update MarkImportEnvConfig
set	DataBaseServer = @dataBaseServer,
	ArchiveMarkDir = @archiveMarkDir,
	BrowserMarkDir = @browserMarkDir,
	CollectorMarkDir = @collectorMarkDir,
	CreditMarkDir = @creditMarkDir,
	FinancialMarkDir = @financialMarkDir,
	StatusDir = @statusDir,
	UploadMarkDir = @uploadMarkDir,
	CreditMTMKeyDir = @creditMTMKeyDir,
	CreditMTMKeyQADir = @creditMTMKeyQADir,
	OafnServer = @oafnServer,
	OafnContServer = @oafnContServer,
	FtpID = @ftpID,
	FtpPassword = @ftpPassword,
	SwapcoServer = @swapcoServer,
	SwapcoContServer = @swapcoContServer,
	SwapcoFtpID = @swapcoFtpID,
	SwapcoFtpPassword = @swapcoFtpPassword,
	OperatorHomeDir = @operatorHomeDir,
	UsersHomeDir = @usersHomeDir,
	FtpHomeDir = @ftpHomeDir,
	OatcFtpServer = @oatcFtpServer,
	OatcContFtpServer = @oatcContFtpServer,
	CPMBrowserMarkDir = @cpmBrowserMarkDir
  where Environment = @Environment
  and Machine = @Machine
if @@error != 0
begin
	select @ErrorMessage = "Could not update MarkImportEnvConfig table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Environment '" + convert(varchar(255), @Environment) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "Machine '" + convert(varchar(255), @Machine) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode MarkImportEnvConfigUpdate, unchained;
DROP PROCEDURE MarkImportFeedConfigDelete;
--/
CREATE PROCEDURE MarkImportFeedConfigDelete (
/**************************************************************************
**
** Procedure:	MarkImportFeedConfigDelete
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@MarkFileName              varchar(150)        ,
	@MarkingSystem             varchar(25)       
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from MarkImportFeedConfig 
where MarkFileName = @MarkFileName
and    MarkingSystem = @MarkingSystem
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from MarkImportFeedConfig table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from MarkImportFeedConfig table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "MarkFileName '" + convert(varchar(255), @MarkFileName) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "MarkingSystem '" + convert(varchar(255), @MarkingSystem) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode MarkImportFeedConfigDelete, unchained;
DROP PROCEDURE MarkImportFeedConfigInsert;
--/
CREATE PROCEDURE MarkImportFeedConfigInsert (
/**************************************************************************
**
** Procedure:	MarkImportFeedConfigInsert
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@MarkFileName              varchar(150)        ,
	@MarkingSystem             varchar(25)       ,
	@FeedType                  varchar(25)        = NULL,
	@InputFileDir              varchar(150)         = NULL,
	@CalculateBrowserMarks     varchar(4) = NULL,
	@MakeSwapBufferOnly        varchar(4) = NULL,
	@NoMarkAdjustment          varchar(4) = NULL,
	@NoMarkAdjPmtOnValueDate   varchar(4) = NULL,
	@NoMarkAdjPerStartMisMatch varchar(4) = NULL,
	@NoMarkFeeAdjustment       varchar(4) = NULL,
	@PrintSwapBufferOnly       varchar(4) = NULL,
	@SaveBrowserMarksToDB      varchar(4) = NULL,
	@SaveMarksToDB             varchar(4) = NULL,
	@TestSwapBuffer            varchar(4) = NULL,
	@TrxMarkAdjustment         varchar(4) = NULL,
	@UseActualMTMPolicy        varchar(4) = NULL,
	@CollectorMarkOption       varchar(25)        = NULL,
	@BrowserMarkFlag           int        = NULL,
	@CollectorMarkFlag         int        = NULL,
	@CreditMarkFlag            int        = NULL,
	@FinancialMarkFlag         int        = NULL,
	@JobStatusFlag             int        = NULL,
	@ImportMarkFlag            int        = NULL,
	@MarkFileSplitFlag         int        = NULL,
	@MarkFileSplitSize         int      = NULL,
	@MaxFileSplitNumber        int      = NULL,
	@MaxReprocessNumber        int      = NULL,
	@MarkFileSourceLocation    varchar(40)        = NULL,
	@OafnLocationCode          varchar(25)        = NULL,
	@OafnDeskCode              varchar(25)        = NULL,
	@OafnSwapCode              varchar(25)        = NULL,
	@Environment               varchar(25)        = NULL,
	@Machine                   varchar(50)       = NULL,
	@DataBaseServer            varchar(50)       = NULL,
	@OafnTargetDir             varchar(150)         = NULL,
	@OafnContTargetDir         varchar(150)         = NULL,
	@JobStatusTargetServer     varchar(50)       = NULL,
	@JobStatusTargetDir        varchar(150)         = NULL,
	@JobStatusFtpID            varchar(25)        = NULL,
	@JobStatusFtpPassword      varchar(25)        = NULL,
	@MarkingSystemContact      varchar(255)             = NULL,
	@MarkingSystemGroupEmail   varchar(255)             = NULL,
	@MarkingSysPassedFlag      int        = NULL,
	@CheckMarkFileSize         int        = NULL,
	@CPMBrowserMarkFlag        int        = NULL,
	@CPMFinancialMarkFlag      int        = NULL,
	@FinancialSftpFlag         int        = NULL,
	@JobStatusSftpFlag         int        = NULL,
	@SkipPFSFlag               int        = NULL,
	@FinMarkFileGenFirst	   int        = NULL
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @ErrorMessage	varchar(255)
insert into MarkImportFeedConfig (
	MarkFileName,
	MarkingSystem,
	FeedType,
	InputFileDir,
	CalculateBrowserMarks,
	MakeSwapBufferOnly,
	NoMarkAdjustment,
	NoMarkAdjPmtOnValueDate,
	NoMarkAdjPerStartMisMatch,
	NoMarkFeeAdjustment,
	PrintSwapBufferOnly,
	SaveBrowserMarksToDB,
	SaveMarksToDB,
	TestSwapBuffer,
	TrxMarkAdjustment,
	UseActualMTMPolicy,
	CollectorMarkOption,
	BrowserMarkFlag,
	CollectorMarkFlag,
	CreditMarkFlag,
	FinancialMarkFlag,
	JobStatusFlag,
	ImportMarkFlag,
	MarkFileSplitFlag,
	MarkFileSplitSize,
	MaxFileSplitNumber,
	MaxReprocessNumber,
	MarkFileSourceLocation,
	OafnLocationCode,
	OafnDeskCode,
	OafnSwapCode,
	Environment,
	Machine,
	DataBaseServer,
	OafnTargetDir,
	OafnContTargetDir,
	JobStatusTargetServer,
	JobStatusTargetDir,
	JobStatusFtpID,
	JobStatusFtpPassword,
	MarkingSystemContact,
	MarkingSystemGroupEmail,
	MarkingSysPassedFlag,
	CheckMarkFileSize,
	CPMBrowserMarkFlag,
	CPMFinancialMarkFlag,
	FinancialSftpFlag,
	JobStatusSftpFlag,
    SkipPFSFlag,
	FinMarkFileGenFirst	)
values (
	@MarkFileName,
	@MarkingSystem,
	@FeedType,
	@InputFileDir,
	@CalculateBrowserMarks,
	@MakeSwapBufferOnly,
	@NoMarkAdjustment,
	@NoMarkAdjPmtOnValueDate,
	@NoMarkAdjPerStartMisMatch,
	@NoMarkFeeAdjustment,
	@PrintSwapBufferOnly,
	@SaveBrowserMarksToDB,
	@SaveMarksToDB,
	@TestSwapBuffer,
	@TrxMarkAdjustment,
	@UseActualMTMPolicy,
	@CollectorMarkOption,
	@BrowserMarkFlag,
	@CollectorMarkFlag,
	@CreditMarkFlag,
	@FinancialMarkFlag,
	@JobStatusFlag,
	@ImportMarkFlag,
	@MarkFileSplitFlag,
	@MarkFileSplitSize,
	@MaxFileSplitNumber,
	@MaxReprocessNumber,
	@MarkFileSourceLocation,
	@OafnLocationCode,
	@OafnDeskCode,
	@OafnSwapCode,
	@Environment,
	@Machine,
	@DataBaseServer,
	@OafnTargetDir,
	@OafnContTargetDir,
	@JobStatusTargetServer,
	@JobStatusTargetDir,
	@JobStatusFtpID,
	@JobStatusFtpPassword,
	@MarkingSystemContact,
	@MarkingSystemGroupEmail,
	@MarkingSysPassedFlag,
	@CheckMarkFileSize,
	@CPMBrowserMarkFlag,
	@CPMFinancialMarkFlag,
	@FinancialSftpFlag,
	@JobStatusSftpFlag,
    @SkipPFSFlag,
	@FinMarkFileGenFirst	)
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into MarkImportFeedConfig table for key(s) "
	select @ErrorMessage = @ErrorMessage + "MarkFileName '" + convert(varchar(255), @MarkFileName) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "MarkingSystem '" + convert(varchar(255), @MarkingSystem) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode MarkImportFeedConfigInsert, unchained;
DROP PROCEDURE MarkImportFeedConfigUpdate;
--/
CREATE PROCEDURE MarkImportFeedConfigUpdate (
/**************************************************************************
**
** Procedure:	MarkImportFeedConfigUpdate
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@MarkFileName              varchar(150)        ,
	@MarkingSystem             varchar(25)       ,
	@FeedType                  varchar(25)        = "#$%@",
	@InputFileDir              varchar(150)         = "#$%@",
	@CalculateBrowserMarks     varchar(4) = "#$%@",
	@MakeSwapBufferOnly        varchar(4) = "#$%@",
	@NoMarkAdjustment          varchar(4) = "#$%@",
	@NoMarkAdjPmtOnValueDate   varchar(4) = "#$%@",
	@NoMarkAdjPerStartMisMatch varchar(4) = "#$%@",
	@NoMarkFeeAdjustment       varchar(4) = "#$%@",
	@PrintSwapBufferOnly       varchar(4) = "#$%@",
	@SaveBrowserMarksToDB      varchar(4) = "#$%@",
	@SaveMarksToDB             varchar(4) = "#$%@",
	@TestSwapBuffer            varchar(4) = "#$%@",
	@TrxMarkAdjustment         varchar(4) = "#$%@",
	@UseActualMTMPolicy        varchar(4) = "#$%@",
	@CollectorMarkOption       varchar(25)        = "#$%@",
	@BrowserMarkFlag           int        = -2147483647,
	@CollectorMarkFlag         int        = -2147483647,
	@CreditMarkFlag            int        = -2147483647,
	@FinancialMarkFlag         int        = -2147483647,
	@JobStatusFlag             int        = -2147483647,
	@ImportMarkFlag            int        = -2147483647,
	@MarkFileSplitFlag         int        = -2147483647,
	@MarkFileSplitSize         int      = -2147483647,
	@MaxFileSplitNumber        int      = -2147483647,
	@MaxReprocessNumber        int      = -2147483647,
	@MarkFileSourceLocation    varchar(40)        = "#$%@",
	@OafnLocationCode          varchar(25)        = "#$%@",
	@OafnDeskCode              varchar(25)        = "#$%@",
	@OafnSwapCode              varchar(25)        = "#$%@",
	@Environment               varchar(25)        = "#$%@",
	@Machine                   varchar(50)       = "#$%@",
	@DataBaseServer            varchar(50)       = "#$%@",
	@OafnTargetDir             varchar(150)         = "#$%@",
	@OafnContTargetDir         varchar(150)         = "#$%@",
	@JobStatusTargetServer     varchar(50)       = "#$%@",
	@JobStatusTargetDir        varchar(150)         = "#$%@",
	@JobStatusFtpID            varchar(25)        = "#$%@",
	@JobStatusFtpPassword      varchar(25)        = "#$%@",
	@MarkingSystemContact      varchar(255)             = "#$%@",
	@MarkingSystemGroupEmail   varchar(255)             = "#$%@",
	@MarkingSysPassedFlag      int        = -2147483647,
	@CheckMarkFileSize         int        = -2147483647,
	@CPMBrowserMarkFlag        int        = -2147483647,
	@CPMFinancialMarkFlag      int        = -2147483647,
	@FinancialSftpFlag         int        = -2147483647,
	@JobStatusSftpFlag         int        = -2147483647,
	@SkipPFSFlag               int        = -2147483647,
	@FinMarkFileGenFirst       int        = -2147483647
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @feedType                  varchar(25)       ,
        @inputFileDir              varchar(150)        ,
        @calculateBrowserMarks     varchar(4),
        @makeSwapBufferOnly        varchar(4),
        @noMarkAdjustment          varchar(4),
        @noMarkAdjPmtOnValueDate   varchar(4),
        @noMarkAdjPerStartMisMatch varchar(4),
        @noMarkFeeAdjustment       varchar(4),
        @printSwapBufferOnly       varchar(4),
        @saveBrowserMarksToDB      varchar(4),
        @saveMarksToDB             varchar(4),
        @testSwapBuffer            varchar(4),
        @trxMarkAdjustment         varchar(4),
        @useActualMTMPolicy        varchar(4),
        @collectorMarkOption       varchar(25)       ,
        @browserMarkFlag           int       ,
        @collectorMarkFlag         int       ,
        @creditMarkFlag            int       ,
        @financialMarkFlag         int       ,
        @jobStatusFlag             int       ,
        @importMarkFlag            int       ,
        @markFileSplitFlag         int       ,
        @markFileSplitSize         int     ,
        @maxFileSplitNumber        int     ,
        @maxReprocessNumber        int     ,
        @markFileSourceLocation    varchar(40)       ,
        @oafnLocationCode          varchar(25)       ,
        @oafnDeskCode              varchar(25)       ,
        @oafnSwapCode              varchar(25)       ,
        @environment               varchar(25)       ,
        @machine                   varchar(50)      ,
        @dataBaseServer            varchar(50)      ,
        @oafnTargetDir             varchar(150)        ,
        @oafnContTargetDir         varchar(150)        ,
        @jobStatusTargetServer     varchar(50)      ,
        @jobStatusTargetDir        varchar(150)        ,
        @jobStatusFtpID            varchar(25)       ,
        @jobStatusPassword         varchar(25)       ,
        @markingSystemContact      varchar(255)            ,
        @markingSystemGroupEmail   varchar(255)            ,
        @markingSysPassedFlag      int       ,
        @checkMarkFileSize         int       ,
        @cpmBrowserMarkFlag        int       ,
        @cpmFinancialMarkFlag      int       ,
        @financialSftpFlag         int       ,
        @jobStatusSftpFlag         int       ,
		@skipPFSFlag               int	   ,
		@finMarkFileGenFirst       int
Select @feedType = FeedType,
       @inputFileDir = InputFileDir,
       @calculateBrowserMarks = CalculateBrowserMarks,
       @makeSwapBufferOnly = MakeSwapBufferOnly,
       @noMarkAdjustment = NoMarkAdjustment,
       @noMarkAdjPmtOnValueDate = NoMarkAdjPmtOnValueDate,
       @noMarkAdjPerStartMisMatch = NoMarkAdjPerStartMisMatch,
       @noMarkFeeAdjustment = NoMarkFeeAdjustment,
       @printSwapBufferOnly = PrintSwapBufferOnly,
       @saveBrowserMarksToDB = SaveBrowserMarksToDB,
       @saveMarksToDB = SaveMarksToDB,
       @testSwapBuffer = TestSwapBuffer,
       @trxMarkAdjustment = TrxMarkAdjustment,
       @useActualMTMPolicy = UseActualMTMPolicy,
       @collectorMarkOption = CollectorMarkOption,
       @browserMarkFlag = BrowserMarkFlag,
       @collectorMarkFlag = CollectorMarkFlag,
       @creditMarkFlag = CreditMarkFlag,
       @financialMarkFlag = FinancialMarkFlag,
       @jobStatusFlag = JobStatusFlag,
       @importMarkFlag = ImportMarkFlag,
       @markFileSplitFlag = MarkFileSplitFlag,
       @markFileSplitSize = MarkFileSplitSize,
       @maxFileSplitNumber = MaxFileSplitNumber,
       @maxReprocessNumber = MaxReprocessNumber,
       @markFileSourceLocation = MarkFileSourceLocation,
       @oafnLocationCode = OafnLocationCode,
       @oafnDeskCode = OafnDeskCode,
       @oafnSwapCode = OafnSwapCode,
       @environment = Environment,
       @machine = Machine,
       @dataBaseServer = DataBaseServer,
       @oafnTargetDir = OafnTargetDir,
       @oafnContTargetDir = OafnContTargetDir,
       @jobStatusTargetServer = JobStatusTargetServer,
       @jobStatusTargetDir = JobStatusTargetDir,
       @jobStatusFtpID = JobStatusFtpID,
       @jobStatusPassword = JobStatusFtpPassword,
       @markingSystemContact = MarkingSystemContact,
       @markingSystemGroupEmail = MarkingSystemGroupEmail,
       @markingSysPassedFlag = MarkingSysPassedFlag,
       @checkMarkFileSize = CheckMarkFileSize,
       @cpmBrowserMarkFlag = CPMBrowserMarkFlag,
       @cpmFinancialMarkFlag = CPMFinancialMarkFlag,
       @financialSftpFlag = FinancialSftpFlag,
       @jobStatusSftpFlag = JobStatusSftpFlag,
	   @skipPFSFlag = SkipPFSFlag,
	   @finMarkFileGenFirst = FinMarkFileGenFirst
	   
from MarkImportFeedConfig
  where MarkFileName = @MarkFileName
  and MarkingSystem = @MarkingSystem
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from MarkImportFeedConfig table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from MarkImportFeedConfig table for key(s) "
	goto ERROR_EXIT
end
if @FeedType != "#$%@"
	select @feedType = @FeedType
if @InputFileDir != "#$%@"
	select @inputFileDir = @InputFileDir
if @CalculateBrowserMarks != "#$%@"
	select @calculateBrowserMarks = @CalculateBrowserMarks
if @MakeSwapBufferOnly != "#$%@"
	select @makeSwapBufferOnly = @MakeSwapBufferOnly
if @NoMarkAdjustment != "#$%@"
	select @noMarkAdjustment = @NoMarkAdjustment
if @NoMarkAdjPmtOnValueDate != "#$%@"
	select @noMarkAdjPmtOnValueDate = @NoMarkAdjPmtOnValueDate
if @NoMarkAdjPerStartMisMatch != "#$%@"
	select @noMarkAdjPerStartMisMatch = @NoMarkAdjPerStartMisMatch
if @NoMarkFeeAdjustment != "#$%@"
	select @noMarkFeeAdjustment = @NoMarkFeeAdjustment
if @PrintSwapBufferOnly != "#$%@"
	select @printSwapBufferOnly = @PrintSwapBufferOnly
if @SaveBrowserMarksToDB != "#$%@"
	select @saveBrowserMarksToDB = @SaveBrowserMarksToDB
if @SaveMarksToDB != "#$%@"
	select @saveMarksToDB = @SaveMarksToDB
if @TestSwapBuffer != "#$%@"
	select @testSwapBuffer = @TestSwapBuffer
if @TrxMarkAdjustment != "#$%@"
	select @trxMarkAdjustment = @TrxMarkAdjustment
if @UseActualMTMPolicy != "#$%@"
	select @useActualMTMPolicy = @UseActualMTMPolicy
if @CollectorMarkOption != "#$%@"
	select @collectorMarkOption = @CollectorMarkOption
if @BrowserMarkFlag != -2147483647
	select @browserMarkFlag = @BrowserMarkFlag
if @CollectorMarkFlag != -2147483647
	select @collectorMarkFlag = @CollectorMarkFlag
if @CreditMarkFlag != -2147483647
	select @creditMarkFlag = @CreditMarkFlag
if @FinancialMarkFlag != -2147483647
	select @financialMarkFlag = @FinancialMarkFlag
if @JobStatusFlag != -2147483647
	select @jobStatusFlag = @JobStatusFlag
if @ImportMarkFlag != -2147483647
	select @importMarkFlag = @ImportMarkFlag
if @MarkFileSplitFlag != -2147483647
	select @markFileSplitFlag = @MarkFileSplitFlag
if @MarkFileSplitSize != -2147483647
	select @markFileSplitSize = @MarkFileSplitSize
if @MaxFileSplitNumber != -2147483647
	select @maxFileSplitNumber = @MaxFileSplitNumber
if @MaxReprocessNumber != -2147483647
	select @maxReprocessNumber = @MaxReprocessNumber
if @MarkFileSourceLocation != "#$%@"
	select @markFileSourceLocation = @MarkFileSourceLocation
if @OafnLocationCode != "#$%@"
	select @oafnLocationCode = @OafnLocationCode
if @OafnDeskCode != "#$%@"
	select @oafnDeskCode = @OafnDeskCode
if @OafnSwapCode != "#$%@"
	select @oafnSwapCode = @OafnSwapCode
if @Environment != "#$%@"
	select @environment = @Environment
if @Machine != "#$%@"
	select @machine = @Machine
if @DataBaseServer != "#$%@"
	select @dataBaseServer = @DataBaseServer
if @OafnTargetDir != "#$%@"
	select @oafnTargetDir = @OafnTargetDir
if @OafnContTargetDir != "#$%@"
	select @oafnContTargetDir = @OafnContTargetDir
if @JobStatusTargetServer != "#$%@"
	select @jobStatusTargetServer = @JobStatusTargetServer
if @JobStatusTargetDir != "#$%@"
	select @jobStatusTargetDir = @JobStatusTargetDir
if @JobStatusFtpID != "#$%@"
	select @jobStatusFtpID = @JobStatusFtpID
if @JobStatusFtpPassword != "#$%@"
	select @jobStatusPassword = @JobStatusFtpPassword
if @MarkingSystemContact != "#$%@"
	select @markingSystemContact = @MarkingSystemContact
if @MarkingSystemGroupEmail != "#$%@"
	select @markingSystemGroupEmail = @MarkingSystemGroupEmail
if @MarkingSysPassedFlag != -2147483647
	select @markingSysPassedFlag = @MarkingSysPassedFlag
if @CheckMarkFileSize != -2147483647
	select @checkMarkFileSize = @CheckMarkFileSize
if @CPMBrowserMarkFlag != -2147483647
	select @cpmBrowserMarkFlag = @CPMBrowserMarkFlag
if @CPMFinancialMarkFlag != -2147483647
	select @cpmFinancialMarkFlag = @CPMFinancialMarkFlag
if @FinancialSftpFlag != -2147483647
	select @financialSftpFlag = @FinancialSftpFlag
if @JobStatusSftpFlag != -2147483647
	select @jobStatusSftpFlag = @JobStatusSftpFlag
	
if @SkipPFSFlag != -2147483647
	select @skipPFSFlag = @SkipPFSFlag
if @FinMarkFileGenFirst != -2147483647
	select @finMarkFileGenFirst = @FinMarkFileGenFirst
Update MarkImportFeedConfig
set	FeedType = @feedType,
	InputFileDir = @inputFileDir,
	CalculateBrowserMarks = @calculateBrowserMarks,
	MakeSwapBufferOnly = @makeSwapBufferOnly,
	NoMarkAdjustment = @noMarkAdjustment,
	NoMarkAdjPmtOnValueDate = @noMarkAdjPmtOnValueDate,
	NoMarkAdjPerStartMisMatch = @noMarkAdjPerStartMisMatch,
	NoMarkFeeAdjustment = @noMarkFeeAdjustment,
	PrintSwapBufferOnly = @printSwapBufferOnly,
	SaveBrowserMarksToDB = @saveBrowserMarksToDB,
	SaveMarksToDB = @saveMarksToDB,
	TestSwapBuffer = @testSwapBuffer,
	TrxMarkAdjustment = @trxMarkAdjustment,
	UseActualMTMPolicy = @useActualMTMPolicy,
	CollectorMarkOption = @collectorMarkOption,
	BrowserMarkFlag = @browserMarkFlag,
	CollectorMarkFlag = @collectorMarkFlag,
	CreditMarkFlag = @creditMarkFlag,
	FinancialMarkFlag = @financialMarkFlag,
	JobStatusFlag = @jobStatusFlag,
	ImportMarkFlag = @importMarkFlag,
	MarkFileSplitFlag = @markFileSplitFlag,
	MarkFileSplitSize = @markFileSplitSize,
	MaxFileSplitNumber = @maxFileSplitNumber,
	MaxReprocessNumber = @maxReprocessNumber,
	MarkFileSourceLocation = @markFileSourceLocation,
	OafnLocationCode = @oafnLocationCode,
	OafnDeskCode = @oafnDeskCode,
	OafnSwapCode = @oafnSwapCode,
	Environment = @environment,
	Machine = @machine,
	DataBaseServer = @dataBaseServer,
	OafnTargetDir = @oafnTargetDir,
	OafnContTargetDir = @oafnContTargetDir,
	JobStatusTargetServer = @jobStatusTargetServer,
	JobStatusTargetDir = @jobStatusTargetDir,
	JobStatusFtpID = @jobStatusFtpID,
	JobStatusFtpPassword = @jobStatusPassword,
	MarkingSystemContact = @markingSystemContact,
	MarkingSystemGroupEmail = @markingSystemGroupEmail,
	MarkingSysPassedFlag = @markingSysPassedFlag,
	CheckMarkFileSize = @checkMarkFileSize,
	CPMBrowserMarkFlag = @cpmBrowserMarkFlag,
	CPMFinancialMarkFlag = @cpmFinancialMarkFlag,
	FinancialSftpFlag = @financialSftpFlag,
	JobStatusSftpFlag = @jobStatusSftpFlag,
	SkipPFSFlag       = @skipPFSFlag,
	FinMarkFileGenFirst       = @finMarkFileGenFirst
	
  where MarkFileName = @MarkFileName
  and MarkingSystem = @MarkingSystem
if @@error != 0
begin
	select @ErrorMessage = "Could not update MarkImportFeedConfig table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "MarkFileName '" + convert(varchar(255), @MarkFileName) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "MarkingSystem '" + convert(varchar(255), @MarkingSystem) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode MarkImportFeedConfigUpdate, unchained;
DROP PROCEDURE MarketData;
--/
CREATE PROCEDURE MarketData
/*******************************************************************************
***
**
**
** Procedure : MarketData
**
** Version   :
**
** Notes     :
**
********************************************************************************
**/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select distinct MarketDataObjectName from MDDB..MarketDataDefinition where Class = 2
 


/
EXEC sp_procxmode MarketData, unchained;
DROP PROCEDURE MasterAgreementExtension;
--/
CREATE PROCEDURE MasterAgreementExtension
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "%W% %G%"
select "CodeType", "MasterAgreementExtension", NULL, NULL, NULL, NULL
select "MasterAgreementExtension", Code, NULL, NULL, NULL, NULL
from CDB..Code
where Type='MasterAgreementExtension'
order by Code


/
EXEC sp_procxmode MasterAgreementExtension, unchained;
DROP PROCEDURE MasterAgreementShelf;
--/
CREATE PROCEDURE MasterAgreementShelf
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "%W% %G%"
select "CodeType", "MasterAgreementShelfCode", NULL, NULL, NULL, NULL
select "MasterAgreementShelfCode", Code, NULL, NULL, Description, NULL
from CDB..Code
where Type='MasterAgreementShelfCode'
order by Code


/
EXEC sp_procxmode MasterAgreementShelf, unchained;
DROP PROCEDURE MidMarkCtrlRptEmailRecepients;
--/
CREATE PROCEDURE MidMarkCtrlRptEmailRecepients
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
begin
select Code from CDB..Code where Type = 'MidMarkReportRecepients'
end


/
EXEC sp_procxmode MidMarkCtrlRptEmailRecepients, unchained;
DROP PROCEDURE NegotiationEntityType;
--/
CREATE PROCEDURE NegotiationEntityType
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "%W% %G%"
select "CodeType", "NegotiationEntityType", NULL, NULL, NULL, NULL
select "NegotiationEntityType", Code, NULL, NULL, NULL, NULL
from CDB.dbo.Code 
where Type = 'EntityType'


/
EXEC sp_procxmode NegotiationEntityType, unchained;
DROP PROCEDURE NegotiationPriority;
--/
CREATE PROCEDURE NegotiationPriority
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "%W% %G%"
select "CodeType", "NegotiationPriority", NULL, NULL, NULL, NULL
select "NegotiationPriority", Code, NULL, NULL, NULL, NULL
from CDB.dbo.Code 
where Type = 'ISDANegotiationPriority'


/
EXEC sp_procxmode NegotiationPriority, unchained;
DROP PROCEDURE NewOasysPublicKey;
--/
CREATE PROCEDURE NewOasysPublicKey 
/**********************************************************************************
**
**
** Procedure : NewOasysPublicKey
**
** Version   : @(#)NewOasysPublicKey.sp
**
** Notes     :
**
**********************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
        declare  @version  varchar(255)
        select   @version = "@(#)NewOasysPublicKey.sp "
	
	select PublicKey 
	from CDB..OasysPublicKey
	having StartDate = max(StartDate)
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode NewOasysPublicKey, unchained;
DROP PROCEDURE OpenTransaction;
--/
CREATE PROCEDURE OpenTransaction
/*M***************************************************************************
**
** Classes:	OpenTransaction
**
** Version: 	@(#)OpenTransaction.proc	63.1 08/06/01
**
** Notes:
**
*****************************************************************************/
	(
	@Class			varchar(255),
	@ClassKey			varchar(255),
	@TeamMember		varchar(75),
	@Application 		varchar(255),
	@LogTime 		datetime,
	@LogTimeZone		varchar(255),
	@Comment		varchar(255),
	@spid			int
	)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
	declare		@Version  varchar(255)
	select @Version = "@(#)OpenTransaction.proc	63.1 08/06/01"
declare	@NumberRows		int,
	@HostName		varchar(255),
	@StatusOther		int,
	@ErrorMessage		varchar(255)
declare @version varchar(255)
select  @version = "@(#)OpenADBTransaction.proc	37.1 5/5/95"
if (not (@Class != NULL and @Class != "")) begin select @ErrorMessage =  "Class can not be NULL." raiserror 20003 @ErrorMessage goto ERROR_EXIT end
if (not (@ClassKey != NULL and @ClassKey != "")) begin select @ErrorMessage =  "Key can not be NULL." raiserror 20003 @ErrorMessage goto ERROR_EXIT end
if (not (@Application != NULL and @Application != "")) begin select @ErrorMessage =   	"Application can not be NULL." raiserror 20003 @ErrorMessage goto ERROR_EXIT end
if (not (@TeamMember != NULL)) begin select @ErrorMessage =  "TeamMember can not be NULL." raiserror 20003 @ErrorMessage goto ERROR_EXIT end
if (not (@spid != NULL)) begin select @ErrorMessage =  "spid can not be NULL." raiserror 20003 @ErrorMessage goto ERROR_EXIT end
select @HostName = host_name()
insert into TransactionLog (Class, ClassKey, TeamMember, ApplicationName, HostName, LogTime, LogTimeZone, Status, Comment, spid) values ( @Class,  @ClassKey,  @TeamMember,  @Application,  @HostName,  @LogTime,  @LogTimeZone, 1,  @Comment,  @spid) if (@@error != 0) begin select  @TeamMember = TeamMember,  @HostName = HostName,  @Application = ApplicationName,  @StatusOther = Status from TransactionLog HOLDLOCK where Class =  @Class and ClassKey =  @ClassKey select  @NumberRows = @@rowcount if  @NumberRows > 1 begin select  @ErrorMessage = "There is more than one transaction in the " + "TransactionLog for the object requested to be OPENED; " + "Class: " +  @Class + " Key: " +  @ClassKey + ". Contact Programming staff." raiserror  20002  @ErrorMessage goto ERROR_EXIT end else if  @NumberRows = 1 begin select  @ErrorMessage = "Can not lock " +  @Class + " for Modify. " + "TeamMember '" +  @TeamMember + "' has " +  @ClassKey + " on host machine '" +  @HostName+ "', in program '" +  @Application + "', locked with a status of OPENED. To clear your own locks, please select Reset->ClearLocks on Oasys Control Panel.'" raiserror  20002  @ErrorMessage goto ERROR_EXIT end end
ERROR_EXIT:
NORMAL_EXIT:
 


/
EXEC sp_procxmode OpenTransaction, unchained;
DROP PROCEDURE PMCSecurities;
--/
CREATE PROCEDURE PMCSecurities
/**********************************************************************************
**
**
** Procedure : PMCSecurities
**
** Version   : %W% %G%
**
** Notes     :
**
**********************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "%W%"
select "CodeType", "PMCSecurities", NULL, NULL, NULL, NULL
select distinct 'PMCSecurities', 'PMC_' + convert(varchar(15), s.FIM_SID),
s.Cusip, "  " + s.Cusip + REPLICATE(' ', 15-datalength(s.Cusip)+1) + s.ISINCode, NULL, NULL, NULL
from SMCDB..FIMaster s, CMDB..SecurityPosition p
where s.FIM_SID = p.FIM_SID
order by p.Cusip


/
EXEC sp_procxmode PMCSecurities, unchained;
DROP PROCEDURE PaymentAuthorizationUsersAsCode;
--/
CREATE PROCEDURE PaymentAuthorizationUsersAsCode
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
select 'CodeType', 'PaymentAuthorizationUsers', NULL, NULL, NULL, NULL
select 'PaymentAuthorizationUsers', TeamMember, Limit, NULL, NULL, NULL from CDB..TeamMemberLimits
where  Type = 'PaymentAuthorization'
order by Limit

/
EXEC sp_procxmode PaymentAuthorizationUsersAsCode, unchained;
DROP PROCEDURE PaymentIndicesAsCode;
--/
CREATE PROCEDURE PaymentIndicesAsCode(
/**********************************************************************************
**
**
** Procedure : PaymentIndicesAsCode
**
** Version   : %W% %C%
**
** Notes     :
**
**********************************************************************************/
	@QuoteDate  int=NULL,
	@EffectiveDate int=NULL,
	@NullRewRates int = NULL
)
as
set compatibility_mode off
set plan optgoal allrows_oltp
set plan optlevel ase_current
declare @version varchar(255)
select  @version = "@(#)PaymentIndicesAsCode.proc	63.1 08/06/01"
if @EffectiveDate != NULL
  begin
	select "CodeType", "PaymentIndices", NULL, NULL, NULL, NULL
	if(@NullRewRates = 1 )
	begin	
		select distinct "PaymentIndices",P.IndexName,NULL,NULL,NULL,NULL from
		PDB..PaymentIndexObservation P,
  		ODB..CashFlowCorpus C, ODB..TransactionTable T, ODB..Deal D
                where P.IndexEffectiveDate=@EffectiveDate
		and P.Deal = C.Deal
		and P.TransactionID = C.TransactionID
		and P.ProductCorpus = C.ProductCorpus
		and (C.RateIndexAccessOperability != 1 or C.RateIndexAccessOperability is null)
		and P.Deal = T.Deal
		and P.TransactionID = T.TransactionID
		and ( T.TerminationDate  is null or T.TerminationDate > convert(int,convert(varchar(30),getdate(),112)) )
		and ( T.EarlyTerminationDate is null or T.EarlyTerminationDate > convert(int,convert(varchar(30),getdate(),112)) )
		and T.TradeStatus = 2
		and P.Deal = D.Deal
		and D.Type = 1
	end
	else
	begin
		select distinct MarketDataObjectID,IndexName
        	into #tmp
        	from PDB..PaymentIndexObservation P (index IndexName) ,MDDB..MarketDataDefinition M,
  		ODB..CashFlowCorpus C, ODB..TransactionTable T, ODB..Deal D
        	where IndexEffectiveDate=@EffectiveDate
        	and M.MarketDataObjectName = P.IndexName
		and P.Deal = C.Deal
		and P.TransactionID = C.TransactionID
		and P.ProductCorpus = C.ProductCorpus
		and (C.RateIndexAccessOperability != 1 or C.RateIndexAccessOperability is null)
		and P.Deal = T.Deal
		and P.TransactionID = T.TransactionID
		and ( T.TerminationDate  is null or T.TerminationDate > convert(int,convert(varchar(30),getdate(),112)) )
		and ( T.EarlyTerminationDate is null or T.EarlyTerminationDate > convert(int,convert(varchar(30),getdate(),112)) )
		and T.TradeStatus = 2
		and P.Deal = D.Deal
		and D.Type = 1
        	select distinct "PaymentIndices",IndexName,NULL,NULL,NULL,NULL
        	from #tmp T,MDDB..IndexObservation I
        	where
        	T.MarketDataObjectID = I.MarketDataObjectID
        	and QuoteDate =  @EffectiveDate  and SignedBy is NULL
        	select distinct "PaymentIndices",IndexName,NULL,NULL,NULL,NULL
        	from #tmp
        	where MarketDataObjectID not in
        	(select I.MarketDataObjectID from MDDB..IndexObservation I ,#tmp T where T.MarketDataObjectID = I.MarketDataObjectID and QuoteDate = @EffectiveDate )
	end
  end
else if @QuoteDate != NULL
  begin
	select "CodeType", "PaymentIndices", NULL, NULL, NULL, NULL
	if(@NullRewRates = 1 )
	begin
		select distinct "PaymentIndices",IndexName,NULL,NULL,NULL,NULL 
		from PDB..PaymentIndexObservation P,MDDB..MarketDataDefinition M,
  		ODB..CashFlowCorpus C, ODB..TransactionTable T, ODB..Deal D
 		where IndexQuoteDate=@QuoteDate
		and M.MarketDataObjectName = P.IndexName
		and M.Class != 6
		and P.Deal = C.Deal
		and P.TransactionID = C.TransactionID
		and P.ProductCorpus = C.ProductCorpus
		and (C.RateIndexAccessOperability != 1 or C.RateIndexAccessOperability is null)
		and P.Deal = T.Deal
		and P.TransactionID = T.TransactionID
		and ( T.TerminationDate  is null or T.TerminationDate > convert(int,convert(varchar(30),getdate(),112)) )
		and ( T.EarlyTerminationDate is null or T.EarlyTerminationDate > convert(int,convert(varchar(30),getdate(),112)) )
		and T.TradeStatus = 2
		and P.Deal = D.Deal
		and D.Type = 1
		union
		select distinct "PaymentIndices",OasysIndex,NULL,NULL,NULL,NULL from
		MDDB..IndicesToRateset where QuoteDate = @QuoteDate
	end
	else
	begin
		select distinct MarketDataObjectID,IndexName
        	into #tmp1
        	from PDB..PaymentIndexObservation P,MDDB..MarketDataDefinition M,
  		ODB..CashFlowCorpus C, ODB..TransactionTable T, ODB..Deal D
        	where IndexQuoteDate=@QuoteDate
        	and M.MarketDataObjectName = P.IndexName
		and M.Class != 6
		and P.Deal = C.Deal
		and P.TransactionID = C.TransactionID
		and P.ProductCorpus = C.ProductCorpus
		and (C.RateIndexAccessOperability != 1 or C.RateIndexAccessOperability is null)
		and P.Deal = T.Deal
		and P.TransactionID = T.TransactionID
		and ( T.TerminationDate  is null or T.TerminationDate > convert(int,convert(varchar(30),getdate(),112)) )
		and ( T.EarlyTerminationDate is null or T.EarlyTerminationDate > convert(int,convert(varchar(30),getdate(),112)) )
		and T.TradeStatus = 2
		and P.Deal = D.Deal
		and D.Type = 1
		insert into #tmp1
		select distinct MarketDataObjectID,OasysIndex "IndexName"
        	from MDDB..IndicesToRateset P,MDDB..MarketDataDefinition M
		where QuoteDate = @QuoteDate
        	and M.MarketDataObjectName = P.OasysIndex
        	select distinct "PaymentIndices",IndexName,NULL,NULL,NULL,NULL
        	from #tmp1 T,MDDB..IndexObservation I
        	where
        	T.MarketDataObjectID = I.MarketDataObjectID
        	and QuoteDate =  @QuoteDate  and SignedBy is NULL
        	select distinct "PaymentIndices",IndexName,NULL,NULL,NULL,NULL
        	from #tmp1
        	where MarketDataObjectID not in
        	(select I.MarketDataObjectID from MDDB..IndexObservation I ,#tmp1 T where T.MarketDataObjectID = I.MarketDataObjectID and QuoteDate = @QuoteDate )
	end
  end
else
  begin
	raiserror 20002 "Both date args cannot be NULL."
	return 20002
  end


/
EXEC sp_procxmode PaymentIndicesAsCode, unchained;
DROP PROCEDURE PaymentIndicesAsCodeNew;
--/
CREATE PROCEDURE PaymentIndicesAsCodeNew(
/**********************************************************************************
**
**
** Procedure : PaymentIndicesAsCode
**
** Version   : %W% %C%
**
** Notes     :
**
**********************************************************************************/
	@QuoteDate  int=NULL,
	@NullRewRates int = NULL
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select  @version = "@(#)PaymentIndicesAsCode.proc	63.1 08/06/01"
if @QuoteDate != NULL
  begin
	if(@NullRewRates = 0 )
	begin
		select distinct IndexName
		from PDB..PaymentIndexObservation P,MDDB..MarketDataDefinition M,
  		ODB..CashFlowCorpus C, ODB..TransactionTable T
 		where IndexQuoteDate=@QuoteDate
		and M.MarketDataObjectName = P.IndexName
		and M.Class != 6
		and P.Deal = C.Deal
		and P.TransactionID = C.TransactionID
		and P.ProductCorpus = C.ProductCorpus
		and (C.RateIndexAccessOperability != 1 or C.RateIndexAccessOperability is null)
		and P.Deal = T.Deal
		and P.TransactionID = T.TransactionID
		and ( T.TerminationDate  is null or T.TerminationDate > convert(int,convert(varchar(30),getdate(),112)) )
		and ( T.EarlyTerminationDate is null or T.EarlyTerminationDate > convert(int,convert(varchar(30),getdate(),112)) )
		and T.TradeStatus = 2
		union
		select OasysIndex from
		MDDB..IndicesToRateset where QuoteDate = @QuoteDate
	end
	else
	begin
		select IndexName
        	into #tmp1
        	from PDB..PaymentIndexObservation P,MDDB..MarketDataDefinition M,
		ODB..CashFlowCorpus C, ODB..TransactionTable T
        	where IndexQuoteDate=@QuoteDate
        	and M.MarketDataObjectName = P.IndexName
		and M.Class != 6
		and P.Deal = C.Deal
		and P.TransactionID = C.TransactionID
		and P.ProductCorpus = C.ProductCorpus
		and (C.RateIndexAccessOperability != 1 or C.RateIndexAccessOperability is null)
		and P.Deal = T.Deal
		and P.TransactionID = T.TransactionID
		and ( T.TerminationDate  is null or T.TerminationDate > convert(int,convert(varchar(30),getdate(),112)) )
		and ( T.EarlyTerminationDate is null or T.EarlyTerminationDate > convert(int,convert(varchar(30),getdate(),112)) )
		and T.TradeStatus = 2
		insert into #tmp1
		select OasysIndex 
        	from MDDB..IndicesToRateset P
		where QuoteDate = @QuoteDate
        	select distinct IndexName
        	from #tmp1 T,MDDB..IndexObservation I, MDDB..MarketDataDefinition M
        	where T.IndexName = M.MarketDataObjectName and M.MarketDataObjectID = I.MarketDataObjectID
        	and QuoteDate =  @QuoteDate  and SignedBy is NULL
		UNION
        	select distinct IndexName
        	from #tmp1
        	where not exists
        	(select 1 from MDDB..IndexObservation I ,#tmp1 T , MDDB..MarketDataDefinition M
		where T.IndexName = M.MarketDataObjectName and M.MarketDataObjectID = I.MarketDataObjectID and QuoteDate = @QuoteDate )
	end
  end


/
EXEC sp_procxmode PaymentIndicesAsCodeNew, unchained;
DROP PROCEDURE PaymentManagerAsCode;
--/
CREATE PROCEDURE PaymentManagerAsCode
/**********************************************************************************
**
**
** Procedure : PaymentManagerAsCode
**
** Version   :    @(#)PaymentManagerAsCode.proc    63.1 10/30/06
**
** Notes     :
**
**********************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select @version = "@(#)PaymentManagerAsCode.proc   63.1 10/30/06"
select "CodeType", "PaymentManagers", NULL, NULL, NULL, NULL
select "PaymentManagers", TeamMember, Limit, NULL, NULL, NULL from CDB..TeamMemberLimits
where  Type = 'PaymentAuthorization' and Limit > 10000 
order by Limit


/
EXEC sp_procxmode PaymentManagerAsCode, unchained;
DROP PROCEDURE Products;
--/
CREATE PROCEDURE Products
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "@(#)Products.sp	131.1 10/20/09"
select "CodeType", "Products", NULL, NULL, NULL, NULL
select "Products", Code, NULL, NULL, NULL, NULL
from CDB.dbo.Code 
where Type = 'ISDAProducts'


/
EXEC sp_procxmode Products, unchained;
DROP PROCEDURE RCMissingCusip;
--/
CREATE PROCEDURE RCMissingCusip
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
   select distinct rc.UnderlyingCusip  into #tempRCMCusip
   from ODB..TransactionTable tt,
        ODB..RecoveryCorpus rc,
        OPDB..FinancialInstrument fi
   where tt.ProductClass = 29
        and tt.TradeStatus = 2
         and rc.Deal = tt.Deal
        and rc.TransactionID = tt.TransactionID
        and fi.Cusip != rc.UnderlyingCusip
        and rc.UnderlyingCusip not in (SELECT distinct ExceptionKey from CDB..ExceptionHandling where ProcessStatus = 0)
   if @@rowcount = 0 goto STORED_PROCEDURE_EXIT
 
   INSERT INTO CDB..ExceptionHandling (ExceptionKey, ExceptionProcess, ProcessStatus, ApplicationName, ExceptionTime, ExceptionProcessSystem)
   SELECT UnderlyingCusip , 2, 1, 'RECOVERY CORPUS CUSIP', getdate(), 'RCMissingCusip' FROM #tempRCMCusip
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode RCMissingCusip, unchained;
DROP PROCEDURE RefreshCodeStrategyDesk;
--/
CREATE PROCEDURE RefreshCodeStrategyDesk
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @CNT int
select @CNT = count(*) from BusinessUnitRefresh
if ( @CNT > 1 )
begin
delete CDB..Code where Type = 'StrategyCode' 
insert CDB..Code(Type, Code, ExternalCode, LongName)
select 'StrategyCode', Strategy, BusinessUnitCode, BusinessUnitName from BusinessUnitRefresh
end


/
EXEC sp_procxmode RefreshCodeStrategyDesk, unchained;
DROP PROCEDURE ReportCustomizationDelete;
--/
CREATE PROCEDURE ReportCustomizationDelete (
/**************************************************************************
**
** Procedure:	ReportCustomizationDelete
**
** Version: 	@(#)ReportCustomizationDelete.proc	63.1 08/06/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@ReportType         varchar(40)     ,
	@Report             varchar(75)    ,
	@TeamMember         varchar(75),
	@ViewIndicator      int     ,
	@SortIndicator      int     ,
	@CustomizationOrder int   
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from ReportCustomization 
where ReportType = @ReportType
and    Report = @Report
and    TeamMember = @TeamMember
and    ViewIndicator = @ViewIndicator
and    SortIndicator = @SortIndicator
and    CustomizationOrder = @CustomizationOrder
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from ReportCustomization table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from ReportCustomization table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "ReportType '" + convert(varchar(255), @ReportType) + "'"
	select @ErrorMessage = @ErrorMessage + ","
	select @ErrorMessage = @ErrorMessage + "Report '" + convert(varchar(255), @Report) + "'"
	select @ErrorMessage = @ErrorMessage + ","
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage + ","
	select @ErrorMessage = @ErrorMessage + "ViewIndicator '" + convert(varchar(255), @ViewIndicator) + "'"
	select @ErrorMessage = @ErrorMessage + ","
	select @ErrorMessage = @ErrorMessage + "SortIndicator '" + convert(varchar(255), @SortIndicator) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "CustomizationOrder '" + convert(varchar(255), @CustomizationOrder) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode ReportCustomizationDelete, unchained;
DROP PROCEDURE ReportCustomizationInsert;
--/
CREATE PROCEDURE ReportCustomizationInsert (
/**************************************************************************
**
** Procedure:	ReportCustomizationInsert
**
** Version: 	@(#)ReportCustomizationInsert.proc	63.1 08/06/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@ReportType         varchar(40)     ,
	@Report             varchar(75)    ,
	@TeamMember         varchar(75),
	@ViewIndicator      int     ,
	@SortIndicator      int     ,
	@Attribute          varchar(255)           = NULL,
	@Header             varchar(255)           = NULL,
	@CustomizationOrder int   ,
	@Format             varchar(255)         = NULL,
	@NullRepresentation varchar(255)    = NULL,
	@Total              int      = NULL,
	@SubTotalLevel      int    = NULL
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into ReportCustomization (
	ReportType,
	Report,
	TeamMember,
	ViewIndicator,
	SortIndicator,
	Attribute,
	Header,
	CustomizationOrder,
	Format,
	NullRepresentation,
	Total,
	SubTotalLevel )
values (
	@ReportType,
	@Report,
	@TeamMember,
	@ViewIndicator,
	@SortIndicator,
	@Attribute,
	@Header,
	@CustomizationOrder,
	@Format,
	@NullRepresentation,
	@Total,
	@SubTotalLevel )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into ReportCustomization table for key(s) "
	select @ErrorMessage = @ErrorMessage + "ReportType '" + convert(varchar(255), @ReportType) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "Report '" + convert(varchar(255), @Report) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "ViewIndicator '" + convert(varchar(255), @ViewIndicator) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "SortIndicator '" + convert(varchar(255), @SortIndicator) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "CustomizationOrder '" + convert(varchar(255), @CustomizationOrder) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode ReportCustomizationInsert, unchained;
DROP PROCEDURE ReportCustomizationUpdate;
--/
CREATE PROCEDURE ReportCustomizationUpdate (
/**************************************************************************
**
** Procedure:	ReportCustomizationUpdate
**
** Version: 	@(#)ReportCustomizationUpdate.proc	63.1 08/06/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@ReportType         varchar(40)     ,
	@Report             varchar(75)    ,
	@TeamMember         varchar(75),
	@ViewIndicator      int     ,
	@SortIndicator      int     ,
	@Attribute          varchar(255)           = "#$%@",
	@Header             varchar(255)           = "#$%@",
	@CustomizationOrder int   ,
	@Format             varchar(255)         = "#$%@",
	@NullRepresentation varchar(255)    = "#$%@",
	@Total              int      = -2147483647,
	@SubTotalLevel      int    = -2147483647
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @attribute          varchar(255)          ,
        @header             varchar(255)          ,
        @format             varchar(255)        ,
        @nullRepresentation varchar(255)   ,
        @total              int     ,
        @subTotalLevel      int   
Select @attribute = Attribute,
       @header = Header,
       @format = Format,
       @nullRepresentation = NullRepresentation,
       @total = Total,
       @subTotalLevel = SubTotalLevel
from ReportCustomization
  where ReportType = @ReportType
  and Report = @Report
  and TeamMember = @TeamMember
  and ViewIndicator = @ViewIndicator
  and SortIndicator = @SortIndicator
  and CustomizationOrder = @CustomizationOrder
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from ReportCustomization table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from ReportCustomization table for key(s) "
	goto ERROR_EXIT
end
if @Attribute != "#$%@"
	select @attribute = @Attribute
if @Header != "#$%@"
	select @header = @Header
if @Format != "#$%@"
	select @format = @Format
if @NullRepresentation != "#$%@"
	select @nullRepresentation = @NullRepresentation
if @Total != -2147483647
	select @total = @Total
if @SubTotalLevel != -2147483647
	select @subTotalLevel = @SubTotalLevel
Update ReportCustomization
set	Attribute = @attribute,
	Header = @header,
	Format = @format,
	NullRepresentation = @nullRepresentation,
	Total = @total,
	SubTotalLevel = @subTotalLevel
  where ReportType = @ReportType
  and Report = @Report
  and TeamMember = @TeamMember
  and ViewIndicator = @ViewIndicator
  and SortIndicator = @SortIndicator
  and CustomizationOrder = @CustomizationOrder
if @@error != 0
begin
	select @ErrorMessage = "Could not update ReportCustomization table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "ReportType '" + convert(varchar(255), @ReportType) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "Report '" + convert(varchar(255), @Report) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "ViewIndicator '" + convert(varchar(255), @ViewIndicator) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "SortIndicator '" + convert(varchar(255), @SortIndicator) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "CustomizationOrder '" + convert(varchar(255), @CustomizationOrder) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode ReportCustomizationUpdate, unchained;
DROP PROCEDURE ReportDelete;
--/
CREATE PROCEDURE ReportDelete (
/**************************************************************************
**
** Procedure:	ReportDelete
**
** Version: 	@(#)ReportDelete.proc	63.1 08/06/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@ReportType                varchar(40)     ,
	@Report                    varchar(75)    ,
	@TeamMember                varchar(75)
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from Report 
where ReportType = @ReportType
and    Report = @Report
and    TeamMember = @TeamMember
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from Report table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from Report table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "ReportType '" + convert(varchar(255), @ReportType) + "'"
	select @ErrorMessage = @ErrorMessage + ","
	select @ErrorMessage = @ErrorMessage + "Report '" + convert(varchar(255), @Report) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode ReportDelete, unchained;
DROP PROCEDURE ReportInsert;
--/
CREATE PROCEDURE ReportInsert (
/**************************************************************************
**
** Procedure:	ReportInsert
**
** Version: 	@(#)ReportInsert.proc	63.1 08/06/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@ReportType                varchar(40)     ,
	@Report                    varchar(75)    ,
	@TeamMember                varchar(75),
	@DynamicSQLIndicator       int      = NULL,
	@OverRideDynamicQueryLimit int    = NULL,
	@FilterType                int        = NULL,
	@CustomResultsColumnName   varchar(255)           = NULL,
	@CRC                       int            = NULL
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into Report (
	ReportType,
	Report,
	TeamMember,
	DynamicSQLIndicator,
	OverRideDynamicQueryLimit,
	FilterType,
	CustomResultsColumnName,
	CRC )
values (
	@ReportType,
	@Report,
	@TeamMember,
	@DynamicSQLIndicator,
	@OverRideDynamicQueryLimit,
	@FilterType,
	@CustomResultsColumnName,
	@CRC )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into Report table for key(s) "
	select @ErrorMessage = @ErrorMessage + "ReportType '" + convert(varchar(255), @ReportType) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "Report '" + convert(varchar(255), @Report) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode ReportInsert, unchained;
DROP PROCEDURE ReportNameAsCode;
--/
CREATE PROCEDURE ReportNameAsCode(
/**********************************************************************************
**
**
** Procedure : ReportNameAsCode
**
** Version   : @(#)ReportNameAsCode.proc	63.1 08/06/01
**
** Notes     :
**
**********************************************************************************/
	@ReportType    varchar(255),
	@TeamMember    varchar(75)=NULL,
	@MutExcl       int=0
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
        declare    @version   varchar(255)
        select     @version = "@(#)ReportNameAsCode.proc	63.1 08/06/01"
select "CodeType", @ReportType+"Reports", NULL, NULL, NULL, NULL
if @MutExcl = 0 or @TeamMember=NULL
    begin
	select @ReportType+"Reports", Report, NULL, NULL, NULL, NULL
	from Report
	where ReportType=@ReportType and TeamMember = NULL
	order by Report
    end
if @MutExcl = 0 and @TeamMember != NULL
    begin
	select @ReportType+"Reports", Report+":"+TeamMember, NULL, NULL, NULL, NULL
	from Report
	where ReportType=@ReportType and TeamMember=@TeamMember
	order by Report
    end
if @MutExcl = 1 and @TeamMember != NULL
    begin
	select @ReportType+"Reports", Report, NULL, NULL, NULL, NULL
	from Report
	where ReportType=@ReportType and TeamMember=@TeamMember
	order by Report
    end


/
EXEC sp_procxmode ReportNameAsCode, unchained;
DROP PROCEDURE ReportSegmentDelete;
--/
CREATE PROCEDURE ReportSegmentDelete (
/**************************************************************************
**
** Procedure:	ReportSegmentDelete
**
** Version: 	@(#)ReportSegmentDelete.proc	63.1 08/06/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@ReportType    varchar(40)     ,
	@Report        varchar(75)    ,
	@TeamMember    varchar(75) = NULL,
	@Type          int ,
	@SegmentNumber int   
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from ReportSegment 
where ReportType = @ReportType
and    Report = @Report
and    TeamMember = @TeamMember
and    Type = @Type
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from ReportSegment table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "ReportType '" + convert(varchar(255), @ReportType) + "'"
	select @ErrorMessage = @ErrorMessage + ","
	select @ErrorMessage = @ErrorMessage + "Report '" + convert(varchar(255), @Report) + "'"
	select @ErrorMessage = @ErrorMessage + ","
	select @ErrorMessage = @ErrorMessage + "Type '" + convert(varchar(255), @Type) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "SegmentNumber '" + convert(varchar(255), @SegmentNumber) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode ReportSegmentDelete, unchained;
DROP PROCEDURE ReportSegmentInsert;
--/
CREATE PROCEDURE ReportSegmentInsert (
/**************************************************************************
**
** Procedure:	ReportSegmentInsert
**
** Version: 	@(#)ReportSegmentInsert.proc	63.1 08/06/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@ReportType    varchar(40)     ,
	@Report        varchar(75)    ,
	@TeamMember    varchar(75) = NULL,
	@Type          int ,
	@SegmentNumber int   ,
	@Segment       varchar(255)    = NULL
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @ErrorMessage	varchar(255)
insert into ReportSegment (
	ReportType,
	Report,
	TeamMember,
	Type,
	SegmentNumber,
	Segment )
values (
	@ReportType,
	@Report,
	@TeamMember,
	@Type,
	@SegmentNumber,
	@Segment )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into ReportSegment table for key(s) "
	select @ErrorMessage = @ErrorMessage + "ReportType '" + convert(varchar(255), @ReportType) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "Report '" + convert(varchar(255), @Report) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "Type '" + convert(varchar(255), @Type) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "SegmentNumber '" + convert(varchar(255), @SegmentNumber) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode ReportSegmentInsert, unchained;
DROP PROCEDURE ReportSegmentUpdate;
--/
CREATE PROCEDURE ReportSegmentUpdate (
/**************************************************************************
**
** Procedure:	ReportSegmentUpdate
**
** Version: 	@(#)ReportSegmentUpdate.proc	63.1 08/06/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@ReportType    varchar(40)     ,
	@Report        varchar(75)    ,
	@TeamMember    varchar(75) = "#$%@",
	@Type          int ,
	@SegmentNumber int   ,
	@Segment       varchar(255)    = "#$%@"
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @teamMember    varchar(75),
        @segment       varchar(255)   
Select @teamMember = TeamMember,
       @segment = Segment
from ReportSegment
  where ReportType = @ReportType
  and Report = @Report
  and Type = @Type
  and SegmentNumber = @SegmentNumber
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from ReportSegment table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from ReportSegment table for key(s) "
	goto ERROR_EXIT
end
if @TeamMember != "#$%@"
	select @teamMember = @TeamMember
if @Segment != "#$%@"
	select @segment = @Segment
Update ReportSegment
set	TeamMember = @teamMember,
	Segment = @segment
  where ReportType = @ReportType
  and Report = @Report
  and Type = @Type
  and SegmentNumber = @SegmentNumber
if @@error != 0
begin
	select @ErrorMessage = "Could not update ReportSegment table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "ReportType '" + convert(varchar(255), @ReportType) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "Report '" + convert(varchar(255), @Report) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "Type '" + convert(varchar(255), @Type) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "SegmentNumber '" + convert(varchar(255), @SegmentNumber) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode ReportSegmentUpdate, unchained;
DROP PROCEDURE ReportTypeAsCode;
--/
CREATE PROCEDURE ReportTypeAsCode(
/**********************************************************************************
**
**
** Procedure : ReportTypeAsCode
**
** Version   : @(#)ReportTypeAsCode.proc	63.1 08/06/01
**
** Notes     :
**
**********************************************************************************/
	@TeamMember  varchar(75)
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
        declare    @version   varchar(255)
        select     @version = "@(#)ReportTypeAsCode.proc	63.1 08/06/01"
select "CodeType", "ReportTypes", NULL, NULL, NULL, NULL
select distinct "ReportTypes", ReportType, NULL, NULL, NULL, NULL
from Report
where TeamMember=@TeamMember 
order by ReportType


/
EXEC sp_procxmode ReportTypeAsCode, unchained;
DROP PROCEDURE ReportUpdate;
--/
CREATE PROCEDURE ReportUpdate (
/**************************************************************************
**
** Procedure:	ReportUpdate
**
** Version: 	@(#)ReportUpdate.proc	63.1 08/06/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@ReportType                varchar(40)     ,
	@Report                    varchar(75)    ,
	@TeamMember                varchar(75),
	@DynamicSQLIndicator       int      = -2147483647,
	@OverRideDynamicQueryLimit int    = -2147483647,
	@FilterType                int        = -2147483647,
	@CustomResultsColumnName   varchar(255)           = "#$%@",
	@CRC                       int            = -2147483647
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @dynamicSQLIndicator       int     ,
        @overRideDynamicQueryLimit int   ,
        @filterType                int       ,
        @customResultsColumnName   varchar(255)          ,
        @crc                       int           
Select @dynamicSQLIndicator = DynamicSQLIndicator,
       @overRideDynamicQueryLimit = OverRideDynamicQueryLimit,
       @filterType = FilterType,
       @customResultsColumnName = CustomResultsColumnName,
       @crc = CRC
from Report
  where ReportType = @ReportType
  and Report = @Report
  and TeamMember = @TeamMember
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from Report table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from Report table for key(s) "
	goto ERROR_EXIT
end
if @DynamicSQLIndicator != -2147483647
	select @dynamicSQLIndicator = @DynamicSQLIndicator
if @OverRideDynamicQueryLimit != -2147483647
	select @overRideDynamicQueryLimit = @OverRideDynamicQueryLimit
if @FilterType != -2147483647
	select @filterType = @FilterType
if @CustomResultsColumnName != "#$%@"
	select @customResultsColumnName = @CustomResultsColumnName
if @CRC != -2147483647
	select @crc = @CRC
Update Report
set	DynamicSQLIndicator = @dynamicSQLIndicator,
	OverRideDynamicQueryLimit = @overRideDynamicQueryLimit,
	FilterType = @filterType,
	CustomResultsColumnName = @customResultsColumnName,
	CRC = @crc
  where ReportType = @ReportType
  and Report = @Report
  and TeamMember = @TeamMember
if @@error != 0
begin
	select @ErrorMessage = "Could not update Report table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "ReportType '" + convert(varchar(255), @ReportType) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "Report '" + convert(varchar(255), @Report) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode ReportUpdate, unchained;
DROP PROCEDURE RestrictedDAEDelete;
--/
CREATE PROCEDURE RestrictedDAEDelete (
/**************************************************************************
**
** Procedure:	RestrictedDAEDelete
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@AccessObject      varchar(40),
	@AccessEntity      varchar(40),
	@AccessEntityValue varchar(40)
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from RestrictedDataAccesEntity 
where AccessObject = @AccessObject
and    AccessEntity = @AccessEntity
and    AccessEntityValue = @AccessEntityValue
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from RestrictedDataAccesEntity table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from RestrictedDataAccesEntity table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "AccessObject '" + convert(varchar(255), @AccessObject) + "'"
	select @ErrorMessage = @ErrorMessage + ","
	select @ErrorMessage = @ErrorMessage + "AccessEntity '" + convert(varchar(255), @AccessEntity) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "AccessEntityValue '" + convert(varchar(255), @AccessEntityValue) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode RestrictedDAEDelete, unchained;
DROP PROCEDURE RestrictedDAEInsert;
--/
CREATE PROCEDURE RestrictedDAEInsert (
/**************************************************************************
**
** Procedure:	RestrictedDAEInsert
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@AccessObject      varchar(40),
	@AccessEntity      varchar(40),
	@AccessEntityValue varchar(40)
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into RestrictedDataAccesEntity (
	AccessObject,
	AccessEntity,
	AccessEntityValue )
values (
	@AccessObject,
	@AccessEntity,
	@AccessEntityValue )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into RestrictedDataAccesEntity table for key(s) "
	select @ErrorMessage = @ErrorMessage + "AccessObject '" + convert(varchar(255), @AccessObject) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "AccessEntity '" + convert(varchar(255), @AccessEntity) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "AccessEntityValue '" + convert(varchar(255), @AccessEntityValue) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode RestrictedDAEInsert, unchained;
DROP PROCEDURE RuleByAppAndRuleName;
--/
 CREATE PROCEDURE RuleByAppAndRuleName (
/**************************************************************************
**
** Procedure:   RuleByAppAndRuleName
**
** Version:     %W% %G%
**
** Notes:       Automatically Generated
**
**************************************************************************/
                     @App varchar(255), 
                     @RuleName varchar(255))
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
select RuleNumber, QueryID 
       into #tmp1 
       from RuleHeader 
where ApplicationName = @App and
RuleName = @RuleName
/* Adaptive Server has expanded all '*' elements in the following statement */ select RuleHeader.RuleNumber, RuleHeader.TeamMember, RuleHeader.LastModified, RuleHeader.ApplicationName, RuleHeader.RuleName, RuleHeader.QueryID, RuleHeader.DBLastModifiedTime, RuleHeader.SeqNumber, RuleHeader.RuleType, RuleHeader.Comments, RuleHeader.ReviewedBy, RuleHeader.ReviewedTimeStamp, RuleHeader.ReviewedTZ, RuleHeader.LastModifiedBy, RuleHeader.RuleApplicationMode, RuleHeader.Active, RuleHeader.USDEqvMax, RuleHeader.USDEqvMin
from RuleHeader where 
RuleNumber in (select RuleNumber from #tmp1)
/* Adaptive Server has expanded all '*' elements in the following statement */ select Query.QueryID, Query.SQLOperation from Query where QueryID in (select  QueryID from #tmp1)
/* Adaptive Server has expanded all '*' elements in the following statement */ select QueryCondition.QueryID, QueryCondition.ConditionNumber, QueryCondition.LogicalOperator, QueryCondition.Parent from QueryCondition where QueryID in (select QueryID from #tmp1)
/* Adaptive Server has expanded all '*' elements in the following statement */ select QueryConditionValue.QueryID, QueryConditionValue.ConditionNumber, QueryConditionValue.RelationalOperator, QueryConditionValue.TableName, QueryConditionValue.ColumnName, QueryConditionValue.Value from QueryConditionValue where QueryID in (select QueryID from #tmp1)
/* Adaptive Server has expanded all '*' elements in the following statement */ select QueryAction.QueryID, QueryAction.ActionID, QueryAction.TableName, QueryAction.ColumnName, QueryAction.Value from QueryAction where QueryID in (select QueryID from #tmp1)
/* Adaptive Server has expanded all '*' elements in the following statement */ select QueryIndex.QueryID, QueryIndex.TableName, QueryIndex.IndexName from QueryIndex where QueryID in (select QueryID from #tmp1)


/
EXEC sp_procxmode RuleByAppAndRuleName, unchained;
DROP PROCEDURE RuleHeaderDelete;
--/
CREATE PROCEDURE RuleHeaderDelete (
/**************************************************************************
**
** Procedure:	RuleHeaderDelete
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@RuleNumber         int   
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from RuleHeader 
where RuleNumber = @RuleNumber
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from RuleHeader table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from RuleHeader table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "RuleNumber '" + convert(varchar(255), @RuleNumber) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode RuleHeaderDelete, unchained;
DROP PROCEDURE RuleHeaderInsert;
--/
CREATE PROCEDURE RuleHeaderInsert (
/**************************************************************************
**
** Procedure:	RuleHeaderInsert
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@RuleNumber         int   ,
	@TeamMember         varchar(75) = NULL,
	@LastModified       datetime           = NULL,
	@ApplicationName    varchar(255)           = NULL,
	@RuleName           varchar(255)           = NULL,
	@QueryID            int    = NULL,
	@DBLastModifiedTime datetime           = NULL,
	@SeqNumber          int    = NULL
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into RuleHeader (
	RuleNumber,
	TeamMember,
	LastModified,
	ApplicationName,
	RuleName,
	QueryID,
	DBLastModifiedTime,
	SeqNumber )
values (
	@RuleNumber,
	@TeamMember,
	@LastModified,
	@ApplicationName,
	@RuleName,
	@QueryID,
	@DBLastModifiedTime,
	@SeqNumber )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into RuleHeader table for key(s) "
	select @ErrorMessage = @ErrorMessage + "RuleNumber '" + convert(varchar(255), @RuleNumber) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode RuleHeaderInsert, unchained;
DROP PROCEDURE RuleHeaderUpdate;
--/
CREATE PROCEDURE RuleHeaderUpdate (
/**************************************************************************
**
** Procedure:	RuleHeaderUpdate
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@RuleNumber         int   ,
	@TeamMember         varchar(75) = "#$%@",
	@LastModified       datetime           = '99991231',
	@ApplicationName    varchar(255)           = "#$%@",
	@RuleName           varchar(255)           = "#$%@",
	@QueryID            int    = -2147483647,
	@DBLastModifiedTime datetime           = '99991231',
	@SeqNumber          int    = -2147483647
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @teamMember         varchar(75),
        @lastModified       datetime          ,
        @applicationName    varchar(255)          ,
        @ruleName           varchar(255)          ,
        @queryID            int   ,
        @dBLastModifiedTime datetime          ,
        @seqNumber          int   
Select @teamMember = TeamMember,
       @lastModified = LastModified,
       @applicationName = ApplicationName,
       @ruleName = RuleName,
       @queryID = QueryID,
       @dBLastModifiedTime = DBLastModifiedTime,
       @seqNumber = SeqNumber
from RuleHeader
  where RuleNumber = @RuleNumber
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from RuleHeader table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from RuleHeader table for key(s) "
	goto ERROR_EXIT
end
if @TeamMember != "#$%@"
	select @teamMember = @TeamMember
if @LastModified != '99991231'
	select @lastModified = @LastModified
if @ApplicationName != "#$%@"
	select @applicationName = @ApplicationName
if @RuleName != "#$%@"
	select @ruleName = @RuleName
if @QueryID != -2147483647
	select @queryID = @QueryID
if @DBLastModifiedTime != '99991231'
	select @dBLastModifiedTime = @DBLastModifiedTime
if @SeqNumber != -2147483647
	select @seqNumber = @SeqNumber
Update RuleHeader
set	TeamMember = @teamMember,
	LastModified = @lastModified,
	ApplicationName = @applicationName,
	RuleName = @ruleName,
	QueryID = @queryID,
	DBLastModifiedTime = @dBLastModifiedTime,
	SeqNumber = @seqNumber
  where RuleNumber = @RuleNumber
if @@error != 0
begin
	select @ErrorMessage = "Could not update RuleHeader table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "RuleNumber '" + convert(varchar(255), @RuleNumber) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode RuleHeaderUpdate, unchained;
DROP PROCEDURE SMCIdentifier;
--/
CREATE PROCEDURE SMCIdentifier
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
select 'CodeType', 'SMCIdentifier', 'SMCIdentifierValueCode', 'SMCIdentifierValueDescription',NULL,NULL
select Type,Code,ExternalCode,LongName,NULL,NULL from CDB..Code where Type like 'SMCIdentifier' AND LongName = 'PE_YES_NO_RULES'
order by ExternalCode

/
EXEC sp_procxmode SMCIdentifier, unchained;
DROP PROCEDURE SSICheckerPrivilege;
--/
CREATE PROCEDURE SSICheckerPrivilege 
/**********************************************************************************
**
**
**
** Version   :    @(#)SSICheckerPrivilege.proc	63.1 08/07/01 
**
** Notes     :
**
**********************************************************************************/
as
declare         @version  varchar(255)
select @version = "@(#)SSICheckerPrivilege.proc	63.1 01/17/11"
select "CodeType", "SSIChecker", NULL, NULL, NULL, NULL
select "SSIChecker", Code, NULL, NULL, NULL, NULL from CDB..Code
where Type = 'SSIChecker'


/
EXEC sp_procxmode SSICheckerPrivilege, unchained;
DROP PROCEDURE SSIMakerPrivilege;
--/
CREATE PROCEDURE SSIMakerPrivilege 
/**********************************************************************************
**
**
**
** Version   :    @(#)SSIMakerPrivilege.proc	63.1 08/07/01 
**
** Notes     :
**
**********************************************************************************/
as
declare         @version  varchar(255)
select @version = "@(#)SSIMakerPrivilege.proc	63.1 01/17/11"
select "CodeType", "SSIMaker", NULL, NULL, NULL, NULL
select "SSIMaker", Code, NULL, NULL, NULL, NULL from CDB..Code
where Type = 'SSIMaker'


/
EXEC sp_procxmode SSIMakerPrivilege, unchained;
DROP PROCEDURE SSIVendorGroups;
--/
CREATE PROCEDURE SSIVendorGroups 
/**********************************************************************************
**
**
**
** Version   :    @(#)SSIVendorGroups.proc	63.1 08/07/01 
**
** Notes     :
**
**********************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select @version = "@(#)SSIVendorGroups.proc	63.1 01/17/11"
select "CodeType", "SSIVendorGroups", NULL, NULL, NULL, NULL
select "SSIVendorGroups", Code, NULL, NULL, NULL, NULL from CDB..Code
where Type = 'SSIVendorGroups'


/
EXEC sp_procxmode SSIVendorGroups, unchained;
DROP PROCEDURE SSIVendorManagerPrivilege;
--/
CREATE PROCEDURE SSIVendorManagerPrivilege 
/**********************************************************************************
**
**
**
** Version   :    @(#)SSIVendorManagerPrivilege.proc	63.1 08/07/01 
**
** Notes     :
**
**********************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select @version = "@(#)SSIVendorManagerPrivilege.proc	63.1 01/17/11"
select "CodeType", "SSIVendorManager", NULL, NULL, NULL, NULL
select "SSIVendorManager", Code, NULL, NULL, NULL, NULL from CDB..Code
where Type = 'SSIVendorManager'


/
EXEC sp_procxmode SSIVendorManagerPrivilege, unchained;
DROP PROCEDURE SalesPerson;
--/
CREATE PROCEDURE SalesPerson
/**********************************************************************
** Procedure : EquitySalesPerson
** Notes     :
**********************************************************************/
as 
set compatibility_mode off  
set plan optgoal allrows_oltp 
set plan optlevel ase_current
declare @version  varchar(255)
select @version = "%W% %G%"
select c.Type, c.Description, t.SybaseID, c.Code
from CDB..Code c, CDB..TeamMember t
where Type = 'Salesperson'
and c.Code *= t.TeamMember


/
EXEC sp_procxmode SalesPerson, unchained;
DROP PROCEDURE SalespersonList;
--/
CREATE PROCEDURE SalespersonList
as 
 set compatibility_mode off 
declare @version varchar(255)
select @version = '@(#)SalespersonList.sp	1.2 02/14/12'
select 'CodeType', 'SalespersonList', NULL, NULL, NULL, NULL
select distinct 'SalespersonList', Code, NULL, NULL, NULL, NULL
from CDB..Code where Type = 'Salesperson' and Code is not null order by lower(Code)

/
EXEC sp_procxmode SalespersonList, unchained;
DROP PROCEDURE SeniorityDomain;
--/
CREATE PROCEDURE SeniorityDomain
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
select 'CodeType', 'SeniorityDomain', 'ExternalCode', NULL, NULL, NULL
select 'SeniorityDomain', Code, ExternalCode, NULL, Description, NULL
from CDB..Code
where Type='SeniorityDomain'
order by Code


/
EXEC sp_procxmode SeniorityDomain, unchained;
DROP PROCEDURE ServiceRepAsCode;
--/
CREATE PROCEDURE ServiceRepAsCode
/**********************************************************************************
**
**
** Procedure : ServiceRepAsCode
**
** Version   :    @(#)ServiceRepAsCode.proc	63.1 08/07/01 
**
** Notes     : Updated where clause on 28/04/2011 
**
**********************************************************************************/
as 
 set compatibility_mode off 
declare         @version  varchar(255)
select @version = "@(#)ServiceRepAsCode.proc	63.1 08/07/01"
select "CodeType", "ServiceRep", NULL, NULL, NULL, NULL
select "ServiceRep", ServiceRep, NULL, NULL, NULL, NULL from CMDB..ServiceRepProfile where Type in (null,'SR')
 order by ServiceRep


/
EXEC sp_procxmode ServiceRepAsCode, unchained;
DROP PROCEDURE SingleSignOnServerHosts;
--/
CREATE PROCEDURE SingleSignOnServerHosts 
/**********************************************************************************
**
**
** Procedure : SingleSignOnServerHosts
**
** Version   : @(#)SingleSignOnServerHosts.sp
**
** Notes     :
**
**********************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
        declare  @version  varchar(255)
        select   @version = "@(#)SingleSignOnServerHosts.sp "
        select
                ExternalCode
        from
                CDB..Code C
        where
		C.Type = 'SingleSignOnServerHosts' and
		C.ExternalCode is not null
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode SingleSignOnServerHosts, unchained;
DROP PROCEDURE SiteMinderConfByDataServer;
--/
CREATE PROCEDURE SiteMinderConfByDataServer (
/**********************************************************************************
**
**
** Procedure : SiteMinderConfByDataServer
**
** Version   : @(#)SiteMinderConfByDataServer.sp 124.1 12/16/06
**
** Notes     :
**
**********************************************************************************/
        @dataServer         varchar(255) 
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
        declare  @version  varchar(255)
        select   @version = "@(#)SiteMinderConfByDataServer.sp   124.1 12/16/06"
        /* Adaptive Server has expanded all '*' elements in the following statement */ select
                S.Type, S.AgentName, S.AgentConfigObject, S.EmailPasswordURL, S.ChangePasswordURL
        from
                SiteMinderConfiguration S, DataServer D
        where
                D.Type = S.Type         AND
                D.DataServer = @dataServer
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode SiteMinderConfByDataServer, unchained;
DROP PROCEDURE SiteMinderConfigurationDelete;
--/
CREATE PROCEDURE SiteMinderConfigurationDelete (
/**************************************************************************
**
** Procedure:	SiteMinderConfigurationDelete
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@AgentName         varchar(255)
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from SiteMinderConfiguration 
where AgentName = @AgentName
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from SiteMinderConfiguration table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from SiteMinderConfiguration table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "AgentName '" + convert(varchar(255), @AgentName) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode SiteMinderConfigurationDelete, unchained;
DROP PROCEDURE SiteMinderConfigurationInsert;
--/
CREATE PROCEDURE SiteMinderConfigurationInsert (
/**************************************************************************
**
** Procedure:	SiteMinderConfigurationInsert
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Type              varchar(255) = NULL,
	@AgentName         varchar(255),
	@AgentConfigObject varchar(255) = NULL,
	@EmailPasswordURL  varchar(255) = NULL,
	@ChangePasswordURL varchar(255) = NULL
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into SiteMinderConfiguration (
	Type,
	AgentName,
	AgentConfigObject,
	EmailPasswordURL,
	ChangePasswordURL )
values (
	@Type,
	@AgentName,
	@AgentConfigObject,
	@EmailPasswordURL,
	@ChangePasswordURL )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into SiteMinderConfiguration table for key(s) "
	select @ErrorMessage = @ErrorMessage + "AgentName '" + convert(varchar(255), @AgentName) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode SiteMinderConfigurationInsert, unchained;
DROP PROCEDURE SiteMinderConfigurationUpdate;
--/
CREATE PROCEDURE SiteMinderConfigurationUpdate (
/**************************************************************************
**
** Procedure:	SiteMinderConfigurationUpdate
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Type              varchar(255) = "#$%@",
	@AgentName         varchar(255),
	@AgentConfigObject varchar(255) = "#$%@",
	@EmailPasswordURL  varchar(255) = "#$%@",
	@ChangePasswordURL varchar(255) = "#$%@"
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @type              varchar(255),
        @agentConfigObject varchar(255),
        @emailPasswordURL  varchar(255),
        @changePasswordURL varchar(255)
Select @type = Type,
       @agentConfigObject = AgentConfigObject,
       @emailPasswordURL = EmailPasswordURL,
       @changePasswordURL = ChangePasswordURL
from SiteMinderConfiguration
  where AgentName = @AgentName
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from SiteMinderConfiguration table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from SiteMinderConfiguration table for key(s) "
	goto ERROR_EXIT
end
if @Type != "#$%@"
	select @type = @Type
if @AgentConfigObject != "#$%@"
	select @agentConfigObject = @AgentConfigObject
if @EmailPasswordURL != "#$%@"
	select @emailPasswordURL = @EmailPasswordURL
if @ChangePasswordURL != "#$%@"
	select @changePasswordURL = @ChangePasswordURL
Update SiteMinderConfiguration
set	Type = @type,
	AgentConfigObject = @agentConfigObject,
	EmailPasswordURL = @emailPasswordURL,
	ChangePasswordURL = @changePasswordURL
  where AgentName = @AgentName
if @@error != 0
begin
	select @ErrorMessage = "Could not update SiteMinderConfiguration table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "AgentName '" + convert(varchar(255), @AgentName) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode SiteMinderConfigurationUpdate, unchained;
DROP PROCEDURE StructuredNoteDelete;
--/
CREATE PROCEDURE StructuredNoteDelete (
/**************************************************************************
**
** Procedure:	StructuredNoteDelete
**
** Version: 	@(#)StructuredNoteDelete.proc	63.1 08/07/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Class       varchar(40)  ,
	@Type        varchar(40)  
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from StructuredNote 
where Class = @Class
and    Type = @Type
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from StructuredNote table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from StructuredNote table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Class '" + convert(varchar(255), @Class) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "Type '" + convert(varchar(255), @Type) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode StructuredNoteDelete, unchained;
DROP PROCEDURE StructuredNoteInsert;
--/
CREATE PROCEDURE StructuredNoteInsert (
/**************************************************************************
**
** Procedure:	StructuredNoteInsert
**
** Version: 	@(#)StructuredNoteInsert.proc	63.1 08/07/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Class       varchar(40)  ,
	@Type        varchar(40)  ,
	@LongName    varchar(255)        = NULL,
	@Description varchar(255) = NULL,
	@CRC         int         = NULL
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into StructuredNote (
	Class,
	Type,
	LongName,
	Description,
	CRC )
values (
	@Class,
	@Type,
	@LongName,
	@Description,
	@CRC )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into StructuredNote table for key(s) "
	select @ErrorMessage = @ErrorMessage + "Class '" + convert(varchar(255), @Class) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "Type '" + convert(varchar(255), @Type) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode StructuredNoteInsert, unchained;
DROP PROCEDURE StructuredNoteSegmentDelete;
--/
CREATE PROCEDURE StructuredNoteSegmentDelete (
/**************************************************************************
**
** Procedure:	StructuredNoteSegmentDelete
**
** Version: 	@(#)StructuredNoteSegmentDelete.proc	63.1 08/07/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Class             varchar(40)  ,
	@Type              varchar(40)  ,
	@NoteSegmentNumber int
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from StructuredNoteSegment 
where Class = @Class
and    Type = @Type
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from StructuredNoteSegment table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Class '" + convert(varchar(255), @Class) + "'"
	select @ErrorMessage = @ErrorMessage + ","
	select @ErrorMessage = @ErrorMessage + "Type '" + convert(varchar(255), @Type) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "NoteSegmentNumber '" + convert(varchar(255), @NoteSegmentNumber) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode StructuredNoteSegmentDelete, unchained;
DROP PROCEDURE StructuredNoteSegmentInsert;
--/
CREATE PROCEDURE StructuredNoteSegmentInsert (
/**************************************************************************
**
** Procedure:	StructuredNoteSegmentInsert
**
** Version: 	@(#)StructuredNoteSegmentInsert.proc	63.1 08/07/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Class             varchar(40)  ,
	@Type              varchar(40)  ,
	@NoteSegmentNumber int,
	@NoteSegment       varchar(255) = NULL
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into StructuredNoteSegment (
	Class,
	Type,
	NoteSegmentNumber,
	NoteSegment )
values (
	@Class,
	@Type,
	@NoteSegmentNumber,
	@NoteSegment )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into StructuredNoteSegment table for key(s) "
	select @ErrorMessage = @ErrorMessage + "Class '" + convert(varchar(255), @Class) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "Type '" + convert(varchar(255), @Type) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "NoteSegmentNumber '" + convert(varchar(255), @NoteSegmentNumber) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode StructuredNoteSegmentInsert, unchained;
DROP PROCEDURE StructuredNoteSegmentUpdate;
--/
CREATE PROCEDURE StructuredNoteSegmentUpdate (
/**************************************************************************
**
** Procedure:	StructuredNoteSegmentUpdate
**
** Version: 	@(#)StructuredNoteSegmentUpdate.proc	63.1 08/07/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Class             varchar(40)  ,
	@Type              varchar(40)  ,
	@NoteSegmentNumber int,
	@NoteSegment       varchar(255) = "#$%@"
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @noteSegment       varchar(255)
Select @noteSegment = NoteSegment
from StructuredNoteSegment
  where Class = @Class
  and Type = @Type
  and NoteSegmentNumber = @NoteSegmentNumber
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from StructuredNoteSegment table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from StructuredNoteSegment table for key(s) "
	goto ERROR_EXIT
end
if @NoteSegment != "#$%@"
	select @noteSegment = @NoteSegment
Update StructuredNoteSegment
set	NoteSegment = @noteSegment
  where Class = @Class
  and Type = @Type
  and NoteSegmentNumber = @NoteSegmentNumber
if @@error != 0
begin
	select @ErrorMessage = "Could not update StructuredNoteSegment table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Class '" + convert(varchar(255), @Class) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "Type '" + convert(varchar(255), @Type) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "NoteSegmentNumber '" + convert(varchar(255), @NoteSegmentNumber) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode StructuredNoteSegmentUpdate, unchained;
DROP PROCEDURE StructuredNoteUpdate;
--/
CREATE PROCEDURE StructuredNoteUpdate (
/**************************************************************************
**
** Procedure:	StructuredNoteUpdate
**
** Version: 	@(#)StructuredNoteUpdate.proc	63.1 08/07/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Class       varchar(40)  ,
	@Type        varchar(40)  ,
	@LongName    varchar(255)        = "#$%@",
	@Description varchar(255) = "#$%@",
	@CRC         int         = -2147483647
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @longName    varchar(255)       ,
        @description varchar(255),
        @crc         int        
Select @longName = LongName,
       @description = Description,
       @crc = CRC
from StructuredNote
  where Class = @Class
  and Type = @Type
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from StructuredNote table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from StructuredNote table for key(s) "
	goto ERROR_EXIT
end
if @LongName != "#$%@"
	select @longName = @LongName
if @Description != "#$%@"
	select @description = @Description
if @CRC != -2147483647
	select @crc = @CRC
Update StructuredNote
set	LongName = @longName,
	Description = @description,
	CRC = @crc
  where Class = @Class
  and Type = @Type
if @@error != 0
begin
	select @ErrorMessage = "Could not update StructuredNote table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Class '" + convert(varchar(255), @Class) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "Type '" + convert(varchar(255), @Type) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode StructuredNoteUpdate, unchained;
DROP PROCEDURE SubBusinessGroups;
--/
CREATE PROCEDURE SubBusinessGroups
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "@(#)SubBusinessGroups.sp	130.1 06/25/09"
select "CodeType", "SubBusinessGroups", "ExternalCode", NULL, NULL, NULL
select "SubBusinessGroups", Code, ExternalCode, NULL, NULL, NULL
from CDB.dbo.Code 
where Type = 'ISDASubBusinessGroups'


/
EXEC sp_procxmode SubBusinessGroups, unchained;
DROP PROCEDURE SupportManagerTeamMembers;
--/
CREATE PROCEDURE SupportManagerTeamMembers
/**************************************************************************
**
** Procedure: SupportManagerTeamMembers
**
** Version: %W% %G%
**
** Notes:	Returns list of team member groups
**
****************************************** 
 ********************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
set nocount on
declare @version  varchar(255)
select @version = "@(#) %W% %G%"
select "CodeType", "SupportManagerTeamMembers", NULL, NULL, NULL, NULL
select "SupportManagerTeamMembers", TeamMember, EMailAddress, NULL, NULL, NULL
from TeamMember where TeamMemberType = 1 and SybaseID  not like '%ELE%' and SybaseID  not like '%ele%' and SybaseID not like '%operator%' and SybaseID not like '%PROFILE%' and TeamMember not like '%50034S%' and TeamMember not like '%508VLS%' order by TeamMember


/
EXEC sp_procxmode SupportManagerTeamMembers, unchained;
DROP PROCEDURE SybaseIDs;
--/
CREATE PROCEDURE SybaseIDs
/**********************************************************************************
**
**
** Procedure : SybaseIDs
**
** Version   :    @(#)SybaseIDs.proc	63.1 08/07/01
**
** Notes     :
**
**********************************************************************************/
as 
 set compatibility_mode off 
declare         @version  varchar(255)
select @version = "@(#)SybaseIDs.proc	63.1 08/07/01"
select "CodeType", "LoginIDs", NULL, NULL, NULL, NULL
select distinct "LoginIDs", SybaseID, NULL, TeamMember, NULL, NULL
from TeamMember
order by TeamMember


/
EXEC sp_procxmode SybaseIDs, unchained;
DROP PROCEDURE SynchronizePrivileges;
--/
CREATE PROCEDURE SynchronizePrivileges (
/**************************************************************************
**
** Procedure:   SynchronizePrivileges
**
** Version:     %W% %G%
**
** Notes:       
**
**************************************************************************/
        @ExistingPrivilege  varchar(255),
        @AdditionalPrivilege  varchar(255)
)
as 
 set compatibility_mode off 
declare @Version  varchar(255)
select  @Version = "%W%"
create table tempdb..temp_TMWithoutPriv ( TeamMember varchar(70), TeamMemberPrivilege varchar(255) )
--- select all users that have old privilege ( like AdjustTrade )
select distinct TeamMember into #tmp_TMHavePriv
  from CDB..TeamMemberPrivileges where TeamMemberPrivilege = @ExistingPrivilege
  
--- from the users above select who currently has corresponding new privilege 
--- ( for AdjustTrade it would be ModifyDeal )
select distinct TMP.TeamMember into #tmp_TMHaveBothPrivs
  from CDB..TeamMemberPrivileges TMP, #tmp_TMHavePriv tmp_TMP
 where TMP.TeamMember = tmp_TMP.TeamMember
   and TMP.TeamMemberPrivilege = @AdditionalPrivilege
   
insert into tempdb..temp_TMWithoutPriv
select TMP.TeamMember, @AdditionalPrivilege from #tmp_TMHavePriv TMP
 where TeamMember not in ( select TeamMember from #tmp_TMHaveBothPrivs )
 
update tempdb..temp_TMWithoutPriv set TeamMemberPrivilege = @AdditionalPrivilege
insert into CDB..TeamMemberPrivileges(TeamMember, TeamMemberPrivilege) 
select TeamMember, TeamMemberPrivilege from tempdb..temp_TMWithoutPriv
drop table tempdb..temp_TMWithoutPriv
drop table #tmp_TMHavePriv
drop table #tmp_TMHaveBothPrivs


/
EXEC sp_procxmode SynchronizePrivileges, unchained;
DROP PROCEDURE TBD_Unsent_UnConfirm;
--/
CREATE PROCEDURE TBD_Unsent_UnConfirm
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "%W% %G%"
select "CodeType", "TBD_Unsent_UnConfirm", NULL, NULL, NULL, NULL
select "TBD_Unsent_UnConfirm", Code, ExternalCode, NULL, NULL, NULL 
from CDB.dbo.Code 
where Type = 'TBD_Unsent_UnConfirm'
order by LongName, Description


/
EXEC sp_procxmode TBD_Unsent_UnConfirm, unchained;
DROP PROCEDURE TaxCenterDelete;
--/
CREATE PROCEDURE TaxCenterDelete (
/**************************************************************************
**
** Procedure:	TaxCenterDelete
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TaxCenterID   int
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from TaxCenter 
where TaxCenterID = @TaxCenterID
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from TaxCenter table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from TaxCenter table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "TaxCenterID '" + convert(varchar(255), @TaxCenterID) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TaxCenterDelete, unchained;
DROP PROCEDURE TaxCenterInsert;
--/
CREATE PROCEDURE TaxCenterInsert (
/**************************************************************************
**
** Procedure:	TaxCenterInsert
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TaxCenterID   int,
	@TaxCenterName varchar(255)        = NULL
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into TaxCenter (
	TaxCenterID,
	TaxCenterName )
values (
	@TaxCenterID,
	@TaxCenterName )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into TaxCenter table for key(s) "
	select @ErrorMessage = @ErrorMessage + "TaxCenterID '" + convert(varchar(255), @TaxCenterID) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TaxCenterInsert, unchained;
DROP PROCEDURE TaxCenterUpdate;
--/
CREATE PROCEDURE TaxCenterUpdate (
/**************************************************************************
**
** Procedure:	TaxCenterUpdate
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TaxCenterID   int,
	@TaxCenterName varchar(255)        = "#$%@"
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @taxCenterName varchar(255)       
Select @taxCenterName = TaxCenterName
from TaxCenter
  where TaxCenterID = @TaxCenterID
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from TaxCenter table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from TaxCenter table for key(s) "
	goto ERROR_EXIT
end
if @TaxCenterName != "#$%@"
	select @taxCenterName = @TaxCenterName
Update TaxCenter
set	TaxCenterName = @taxCenterName
  where TaxCenterID = @TaxCenterID
if @@error != 0
begin
	select @ErrorMessage = "Could not update TaxCenter table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "TaxCenterID '" + convert(varchar(255), @TaxCenterID) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TaxCenterUpdate, unchained;
DROP PROCEDURE TaxEventDelete;
--/
CREATE PROCEDURE TaxEventDelete (
/**************************************************************************
**
** Procedure:	TaxEventDelete
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TaxCenterID  int           ,
	@EventType    int              
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from TaxEvent 
where TaxCenterID = @TaxCenterID
and    EventType = @EventType
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from TaxEvent table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from TaxEvent table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "TaxCenterID '" + convert(varchar(255), @TaxCenterID) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "EventType '" + convert(varchar(255), @EventType) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TaxEventDelete, unchained;
DROP PROCEDURE TaxEventInsert;
--/
CREATE PROCEDURE TaxEventInsert (
/**************************************************************************
**
** Procedure:	TaxEventInsert
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TaxCenterID  int           ,
	@EventType    int              ,
	@EventSubType int = NULL
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into TaxEvent (
	TaxCenterID,
	EventType,
	EventSubType )
values (
	@TaxCenterID,
	@EventType,
	@EventSubType )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into TaxEvent table for key(s) "
	select @ErrorMessage = @ErrorMessage + "TaxCenterID '" + convert(varchar(255), @TaxCenterID) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "EventType '" + convert(varchar(255), @EventType) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TaxEventInsert, unchained;
DROP PROCEDURE TaxEventUpdate;
--/
CREATE PROCEDURE TaxEventUpdate (
/**************************************************************************
**
** Procedure:	TaxEventUpdate
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TaxCenterID  int           ,
	@EventType    int              ,
	@EventSubType int = -2147483647
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @eventSubType int
Select @eventSubType = EventSubType
from TaxEvent
  where TaxCenterID = @TaxCenterID
  and EventType = @EventType
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from TaxEvent table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from TaxEvent table for key(s) "
	goto ERROR_EXIT
end
if @EventSubType != -2147483647
	select @eventSubType = @EventSubType
Update TaxEvent
set	EventSubType = @eventSubType
  where TaxCenterID = @TaxCenterID
  and EventType = @EventType
if @@error != 0
begin
	select @ErrorMessage = "Could not update TaxEvent table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "TaxCenterID '" + convert(varchar(255), @TaxCenterID) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "EventType '" + convert(varchar(255), @EventType) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TaxEventUpdate, unchained;
DROP PROCEDURE TaxProductMappingDelete;
--/
CREATE PROCEDURE TaxProductMappingDelete (
/**************************************************************************
**
** Procedure:	TaxProductMappingDelete
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TaxCenterID      int ,
	@ProductClass     int,
	@TaxedType        int         
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from TaxProductMapping 
where TaxCenterID = @TaxCenterID
and    ProductClass = @ProductClass
and    TaxedType = @TaxedType
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from TaxProductMapping table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from TaxProductMapping table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "TaxCenterID '" + convert(varchar(255), @TaxCenterID) + "'"
	select @ErrorMessage = @ErrorMessage + ","
	select @ErrorMessage = @ErrorMessage + "ProductClass '" + convert(varchar(255), @ProductClass) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "TaxedType '" + convert(varchar(255), @TaxedType) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TaxProductMappingDelete, unchained;
DROP PROCEDURE TaxProductMappingInsert;
--/
CREATE PROCEDURE TaxProductMappingInsert (
/**************************************************************************
**
** Procedure:	TaxProductMappingInsert
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TaxCenterID      int ,
	@ProductClass     int,
	@TaxedType        int         ,
	@Taxable          int    = NULL,
	@TaxRetentionCode varchar(255)         = NULL
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into TaxProductMapping (
	TaxCenterID,
	ProductClass,
	TaxedType,
	Taxable,
	TaxRetentionCode )
values (
	@TaxCenterID,
	@ProductClass,
	@TaxedType,
	@Taxable,
	@TaxRetentionCode )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into TaxProductMapping table for key(s) "
	select @ErrorMessage = @ErrorMessage + "TaxCenterID '" + convert(varchar(255), @TaxCenterID) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "ProductClass '" + convert(varchar(255), @ProductClass) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "TaxedType '" + convert(varchar(255), @TaxedType) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TaxProductMappingInsert, unchained;
DROP PROCEDURE TaxProductMappingUpdate;
--/
CREATE PROCEDURE TaxProductMappingUpdate (
/**************************************************************************
**
** Procedure:	TaxProductMappingUpdate
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TaxCenterID      int ,
	@ProductClass     int,
	@TaxedType        int         ,
	@Taxable          int    = -2147483647,
	@TaxRetentionCode varchar(255)         = "#$%@"
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @taxable          int   ,
        @taxRetentionCode varchar(255)        
Select @taxable = Taxable,
       @taxRetentionCode = TaxRetentionCode
from TaxProductMapping
  where TaxCenterID = @TaxCenterID
  and ProductClass = @ProductClass
  and TaxedType = @TaxedType
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from TaxProductMapping table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from TaxProductMapping table for key(s) "
	goto ERROR_EXIT
end
if @Taxable != -2147483647
	select @taxable = @Taxable
if @TaxRetentionCode != "#$%@"
	select @taxRetentionCode = @TaxRetentionCode
Update TaxProductMapping
set	Taxable = @taxable,
	TaxRetentionCode = @taxRetentionCode
  where TaxCenterID = @TaxCenterID
  and ProductClass = @ProductClass
  and TaxedType = @TaxedType
if @@error != 0
begin
	select @ErrorMessage = "Could not update TaxProductMapping table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "TaxCenterID '" + convert(varchar(255), @TaxCenterID) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "ProductClass '" + convert(varchar(255), @ProductClass) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "TaxedType '" + convert(varchar(255), @TaxedType) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TaxProductMappingUpdate, unchained;
DROP PROCEDURE TaxRateDelete;
--/
CREATE PROCEDURE TaxRateDelete (
/**************************************************************************
**
** Procedure:	TaxRateDelete
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TaxCenterID    int,
	@TaxedType      int        ,
	@CustomerType   varchar(40)  ,
	@EffectiveStart int           ,
	@EffectiveEnd   int           ,
	@TenorStart     int        ,
	@TenorEnd       int        
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from TaxRate 
where TaxCenterID = @TaxCenterID
and    TaxedType = @TaxedType
and    CustomerType = @CustomerType
and    EffectiveStart = @EffectiveStart
and    EffectiveEnd = @EffectiveEnd
and    TenorStart = @TenorStart
and    TenorEnd = @TenorEnd
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from TaxRate table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from TaxRate table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "TaxCenterID '" + convert(varchar(255), @TaxCenterID) + "'"
	select @ErrorMessage = @ErrorMessage + ","
	select @ErrorMessage = @ErrorMessage + "TaxedType '" + convert(varchar(255), @TaxedType) + "'"
	select @ErrorMessage = @ErrorMessage + ","
	select @ErrorMessage = @ErrorMessage + "CustomerType '" + convert(varchar(255), @CustomerType) + "'"
	select @ErrorMessage = @ErrorMessage + ","
	select @ErrorMessage = @ErrorMessage + "EffectiveStart '" + convert(varchar(255), @EffectiveStart) + "'"
	select @ErrorMessage = @ErrorMessage + ","
	select @ErrorMessage = @ErrorMessage + "EffectiveEnd '" + convert(varchar(255), @EffectiveEnd) + "'"
	select @ErrorMessage = @ErrorMessage + ","
	select @ErrorMessage = @ErrorMessage + "TenorStart '" + convert(varchar(255), @TenorStart) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "TenorEnd '" + convert(varchar(255), @TenorEnd) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TaxRateDelete, unchained;
DROP PROCEDURE TaxRateInsert;
--/
CREATE PROCEDURE TaxRateInsert (
/**************************************************************************
**
** Procedure:	TaxRateInsert
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TaxCenterID    int,
	@TaxedType      int        ,
	@CustomerType   varchar(40)  ,
	@CustomerBranch varchar(255)        = NULL,
	@Domicile       varchar(255)        = NULL,
	@EffectiveStart int           ,
	@EffectiveEnd   int           ,
	@TenorStart     int        ,
	@TenorEnd       int        ,
	@TaxRate        float          = NULL,
        @LastModified         datetime           = NULL,
        @LastModifiedTimeZone varchar(255)           = NULL,
        @LastModifiedBy       varchar(75) = NULL,
        @LastSigned           datetime           = NULL,
        @LastSignedTimeZone   varchar(255)           = NULL,
        @LastSignedBy         varchar(75) = NULL,
	@ProductClass	int
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @ErrorMessage	varchar(255)
insert into TaxRate (
	TaxCenterID,
	TaxedType,
	CustomerType,
	CustomerBranch,
	Domicile,
	EffectiveStart,
	EffectiveEnd,
	TenorStart,
	TenorEnd,
	TaxRate,
        LastModified,
        LastModifiedTimeZone,
        LastModifiedBy,
        LastSigned,
        LastSignedTimeZone,
        LastSignedBy,
	ProductClass )
values (
	@TaxCenterID,
	@TaxedType,
	@CustomerType,
	@CustomerBranch,
	@Domicile,
	@EffectiveStart,
	@EffectiveEnd,
	@TenorStart,
	@TenorEnd,
	@TaxRate,
        @LastModified,
        @LastModifiedTimeZone,
        @LastModifiedBy,
        @LastSigned,
        @LastSignedTimeZone,
        @LastSignedBy,
	@ProductClass )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into TaxRate table for key(s) "
	select @ErrorMessage = @ErrorMessage + "TaxCenterID '" + convert(varchar(255), @TaxCenterID) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "TaxedType '" + convert(varchar(255), @TaxedType) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "CustomerType '" + convert(varchar(255), @CustomerType) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "EffectiveStart '" + convert(varchar(255), @EffectiveStart) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "EffectiveEnd '" + convert(varchar(255), @EffectiveEnd) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "TenorStart '" + convert(varchar(255), @TenorStart) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "TenorEnd '" + convert(varchar(255), @TenorEnd) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TaxRateInsert, unchained;
DROP PROCEDURE TaxRateUpdate;
--/
CREATE PROCEDURE TaxRateUpdate (
/**************************************************************************
**
** Procedure:	TaxRateUpdate
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TaxCenterID    int,
	@TaxedType      int        ,
	@CustomerType   varchar(40)  ,
	@CustomerBranch varchar(255)        = "#$%@",
	@Domicile       varchar(255)        = "#$%@",
	@EffectiveStart int           ,
	@EffectiveEnd   int           ,
	@TenorStart     int        ,
	@TenorEnd       int        ,
	@TaxRate        float          = -922337203685447.5807,
        @LastModified         datetime           = '99991231',
        @LastModifiedTimeZone varchar(255)           = "#$%@",
        @LastModifiedBy       varchar(75) = "#$%@",
        @LastSigned           datetime           = '99991231',
        @LastSignedTimeZone   varchar(255)           = "#$%@",
        @LastSignedBy         varchar(75) = "#$%@",
	@ProductClass	int
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @customerBranch varchar(255)       ,
        @domicile       varchar(255)       ,
        @taxRate        float         ,
        @lastModified         datetime          ,
        @lastModifiedTimeZone varchar(255)          ,
        @lastModifiedBy       varchar(75),
        @lastSigned           datetime          ,
        @lastSignedTimeZone   varchar(255)          ,
        @lastSignedBy         varchar(75),
		@productClass	int
Select @customerBranch = CustomerBranch,
       @domicile = Domicile,
       @taxRate = TaxRate,
       @lastModified = LastModified,
       @lastModifiedTimeZone = LastModifiedTimeZone,
       @lastModifiedBy = LastModifiedBy,
       @lastSigned = LastSigned,
       @lastSignedTimeZone = LastSignedTimeZone,
       @lastSignedBy = LastSignedBy,
		@productClass = ProductClass
from TaxRate
  where TaxCenterID = @TaxCenterID
  and TaxedType = @TaxedType
  and CustomerType = @CustomerType
  and EffectiveStart = @EffectiveStart
  and EffectiveEnd = @EffectiveEnd
  and TenorStart = @TenorStart
  and TenorEnd = @TenorEnd
  and ProductClass = @ProductClass
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from TaxRate table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from TaxRate table for key(s) "
	goto ERROR_EXIT
end
if @CustomerBranch != "#$%@"
	select @customerBranch = @CustomerBranch
if @Domicile != "#$%@"
	select @domicile = @Domicile
if @TaxRate != -922337203685447.5807
	select @taxRate = @TaxRate
if @LastModified != '99991231'
        select @lastModified = @LastModified
if @LastModifiedTimeZone != "#$%@"
        select @lastModifiedTimeZone = @LastModifiedTimeZone
if @LastModifiedBy != "#$%@"
        select @lastModifiedBy = @LastModifiedBy
if @LastSigned != '99991231'
        select @lastSigned = @LastSigned
if @LastSignedTimeZone != "#$%@"
        select @lastSignedTimeZone = @LastSignedTimeZone
if @LastSignedBy != "#$%@"
        select @lastSignedBy = @LastSignedBy
if @ProductClass != -2147483647
        select @productClass = @ProductClass
Update TaxRate
set	CustomerBranch = @customerBranch,
	Domicile = @domicile,
	TaxRate = @taxRate,
        LastModified = @lastModified,
        LastModifiedTimeZone = @lastModifiedTimeZone,
        LastModifiedBy = @lastModifiedBy,
        LastSigned = @lastSigned,
        LastSignedTimeZone = @lastSignedTimeZone,
        LastSignedBy = @lastSignedBy,
		ProductClass = @productClass
  where TaxCenterID = @TaxCenterID
  and TaxedType = @TaxedType
  and CustomerType = @CustomerType
  and EffectiveStart = @EffectiveStart
  and EffectiveEnd = @EffectiveEnd
  and TenorStart = @TenorStart
  and TenorEnd = @TenorEnd
  and ProductClass = @ProductClass
if @@error != 0
begin
	select @ErrorMessage = "Could not update TaxRate table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "TaxCenterID '" + convert(varchar(255), @TaxCenterID) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "TaxedType '" + convert(varchar(255), @TaxedType) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "CustomerType '" + convert(varchar(255), @CustomerType) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "EffectiveStart '" + convert(varchar(255), @EffectiveStart) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "EffectiveEnd '" + convert(varchar(255), @EffectiveEnd) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "TenorStart '" + convert(varchar(255), @TenorStart) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "TenorEnd '" + convert(varchar(255), @TenorEnd) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TaxRateUpdate, unchained;
DROP PROCEDURE TeamMember1Y5;
--/
CREATE PROCEDURE TeamMember1Y5 
/**************************************************************************
**
** Procedure:	TeamMember1Y5
**
** Version: 	@(#)TeamMember1Y5.proc	116.2 02/24/04
**
**************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @ErrorMessage	varchar(255)
declare @version  varchar(255)
select  @version = "@(#)TeamMember1Y5.proc	116.2 02/24/04"
select a.TeamMember,a.SybaseID, a.Disabled, a.ExpiryDate,
	Privilege = convert(varchar(255), b.TeamMemberPrivilege)
into #temp
from TeamMember a , TeamMemberPrivileges b
where a.TeamMember = b.TeamMember 
and (a.SybaseID not like "sybdba%" 
and a.SybaseID not like "dpsprod%" 
and a.SybaseID not like "oasystc%"
and a.CostCentre in (select distinct Code from CDB..Code where Type = 'TechnologyPL'))
and 
	(  b.TeamMemberPrivilege like "Create%" 
	or b.TeamMemberPrivilege like "Modify%" 
	or TeamMemberPrivilege like 'Execute%' 
	or TeamMemberPrivilege like 'Adj%'
	or TeamMemberPrivilege in (select distinct Code from Code where Type = 'RiskPrivileges') )
insert #temp
select b.TeamMember,a.SybaseID, a.Disabled, a.ExpiryDate,
	convert(varchar(255), c.TeamMemberPrivilege)
from TeamMember a , TeamMemberGroupLink b, TeamMemberPrivileges c
where b.TeamMember = a.TeamMember
and (a.SybaseID not like "sybdba%"
and a.SybaseID not like "dpsprod%" 
and a.SybaseID not like "oasystc%" 
and a.CostCentre in (select distinct Code from CDB..Code where Type = 'TechnologyPL'))
and b.TeamMemberGroup = c.TeamMember
and
	(  c.TeamMemberPrivilege like "Create%" 
	or c.TeamMemberPrivilege like "Modify%" 
	or c.TeamMemberPrivilege like 'Execute%' 
	or c.TeamMemberPrivilege like 'Adj%'
	or c.TeamMemberPrivilege in (select distinct Code from Code where Type = 'RiskPrivileges')) 
select	TeamMember, 
	AccessObject,
	Privilege = convert(varchar(6), AccessPrivilege),
	AccessEntity,
	AccessEntityValue,
	FilterType
into #temp2
from TeamMemberDataAccessPrivileges
update #temp2
set	Privilege =	case Privilege
				when "1" then "View"
				when "2" then "Modify"
				when "3" then "Delete"
				else Privilege
			end
insert #temp
select T.TeamMember, T.SybaseID, T.Disabled,T.ExpiryDate,
	Privilege + ":" + AccessObject + ":" + AccessEntity + ":" + AccessEntityValue + ":" FilterType
from TeamMember T, #temp2 TP
where T.TeamMember = TP.TeamMember
and (T.SybaseID not like "sybdba%"
and T.SybaseID not like "dpsprod%" 
and T.SybaseID not like "oasystc%"
and T.CostCentre in (select distinct Code from CDB..Code where Type = 'TechnologyPL'))
insert #temp
select T.TeamMember, T.SybaseID, T.Disabled,T.ExpiryDate,
	Privilege + ":" + AccessObject + ":" + AccessEntity + ":" + AccessEntityValue + ":" FilterType
from TeamMember T, #temp2 TP, TeamMemberGroupLink TG
where T.TeamMember = TG.TeamMember
and TG.TeamMemberGroup = TP.TeamMember
and (T.SybaseID not like "sybdba%"
and T.SybaseID not like "dpsprod%" 
and T.SybaseID not like "oasystc%"
and T.CostCentre in (select distinct Code from CDB..Code where Type = 'TechnologyPL'))
	
select convert(char(25),TeamMember)+"|"+convert(char(10),SybaseID)+"|"+
convert(char(1),Disabled)+"|"+convert(varchar(15),convert(datetime,convert(char(15),ExpiryDate)),101)+"|"+convert(varchar(255),Privilege)
from #temp
order by TeamMember,ExpiryDate
if @@error != 0
        goto STORED_PROCEDURE_EXIT
goto STORED_PROCEDURE_EXIT
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TeamMember1Y5, unchained;
DROP PROCEDURE TeamMemberAll;
--/
CREATE PROCEDURE TeamMemberAll
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "%W% %G%"
select "CodeType", "TeamMemberAll", NULL, NULL, NULL, NULL
select distinct "TeamMemberAll", TeamMember, NULL, NULL, NULL, NULL
from CDB.dbo.TeamMemberGroupLink
where TeamMemberGroup like 'ISDATicket-%'


/
EXEC sp_procxmode TeamMemberAll, unchained;
DROP PROCEDURE TeamMemberBusiness;
--/
CREATE PROCEDURE TeamMemberBusiness
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version  varchar(255)
select @version = "%W% %G%"
select "CodeType", "TeamMember", NULL, NULL, NULL, NULL
select "TeamMember", TeamMember, NULL, NULL, NULL, NULL
from CDB.dbo.TeamMemberGroupLink
where TeamMemberGroup in ('ISDATicket-Business-newyork-grp','ISDATicket-Business-london-grp','ISDATicket-RM-newyork-grp','ISDATicket-RM-london-grp')
order by TeamMember


/
EXEC sp_procxmode TeamMemberBusiness, unchained;
DROP PROCEDURE TeamMemberCBMAssigned;
--/
CREATE PROCEDURE TeamMemberCBMAssigned
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
select 'CodeType', 'TeamMemberCBMAssigned', NULL, NULL, NULL, NULL
select distinct 'TeamMemberCBMAssigned', GL.TeamMember, NULL, NULL, NULL, NULL
from CDB..TeamMemberGroupLink GL, CBDB..CBMLevelManagers LM
where (TeamMemberGroup like 'CashBreaks%')
  and (GL.TeamMember = LM.AssignedTo)
union
select distinct 'TeamMemberCBMAssigned',Code 'TeamMember', NULL, NULL, NULL, NULL from CDB..Code Where Type='zTeamMemberCBMAssigned'
order by TeamMember


/
EXEC sp_procxmode TeamMemberCBMAssigned, unchained;
DROP PROCEDURE TeamMemberCBMFXUser;
--/
CREATE PROCEDURE TeamMemberCBMFXUser
as 
 set compatibility_mode off 
declare @version varchar(255)
select @version = "%W% %G%"
select "CodeType", "TeamMemberCBMFXUser", NULL, NULL, NULL, NULL
select distinct "TeamMemberCBMFXUser", TeamMember, NULL, NULL, NULL, NULL
from CDB.dbo.TeamMemberGroupLink
where TeamMemberGroup like 'CashBreaksFX%'
order by TeamMember


/
EXEC sp_procxmode TeamMemberCBMFXUser, unchained;
DROP PROCEDURE TeamMemberCBMLoansUser;
--/
CREATE PROCEDURE TeamMemberCBMLoansUser
as 
 set compatibility_mode off 
declare @version varchar(255)
select @version = "%W% %G%"
select "CodeType", "TeamMemberCBMLoansUser", NULL, NULL, NULL, NULL
select distinct "TeamMemberCBMLoansUser", TeamMember, NULL, NULL, NULL, NULL
from CDB.dbo.TeamMemberGroupLink
where TeamMemberGroup like 'CashBreaksLoans%'
order by TeamMember


/
EXEC sp_procxmode TeamMemberCBMLoansUser, unchained;
DROP PROCEDURE TeamMemberCBMUser;
--/
CREATE PROCEDURE TeamMemberCBMUser
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "%W% %G%"
select "CodeType", "TeamMemberCBMUser", NULL, NULL, NULL, NULL
select distinct "TeamMemberCBMUser", TeamMember, NULL, NULL, NULL, NULL
from CDB.dbo.TeamMemberGroupLink
where TeamMemberGroup like 'CashBreaks%'
order by TeamMember


/
EXEC sp_procxmode TeamMemberCBMUser, unchained;
DROP PROCEDURE TeamMemberCMDUAdmin;
--/
CREATE PROCEDURE TeamMemberCMDUAdmin
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "%W% %G%"
select "CodeType", "TeamMemberCMDUAdmin", "TeamMemberGroupName", NULL, NULL, NULL
select "TeamMemberCMDUAdmin", TeamMember, TeamMemberGroup, NULL, NULL, NULL
from CDB.dbo.TeamMemberGroupLink
where TeamMemberGroup like 'ISDATicket%CMDUAdmin-%' order by TeamMember


/
EXEC sp_procxmode TeamMemberCMDUAdmin, unchained;
DROP PROCEDURE TeamMemberCMDUManager;
--/
CREATE PROCEDURE TeamMemberCMDUManager
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "%W% %G%"
select "CodeType", "TeamMemberCMDUManager", "TeamMemberGroup", NULL, NULL, NULL
select "TeamMemberCMDUManager", TeamMember,TeamMemberGroup, NULL, NULL, NULL
from CDB.dbo.TeamMemberGroupLink
where TeamMemberGroup like 'ISDATicket%CMDUManager-%' order by TeamMember


/
EXEC sp_procxmode TeamMemberCMDUManager, unchained;
DROP PROCEDURE TeamMemberCreditOfficer;
--/
CREATE PROCEDURE TeamMemberCreditOfficer 
as 
 set compatibility_mode off 
declare @version varchar(255)
select @version = "%W% %G%"
select "CodeType", "TeamMemberCreditOfficer", "TeamMemberGroupName", NULL, NULL, NULL
select "TeamMemberCreditOfficer", TeamMember, TeamMemberGroup, NULL, NULL, NULL
from CDB.dbo.TeamMemberGroupLink
where TeamMemberGroup like 'ISDATicket%CreditOfficer-%' order by TeamMember


/
EXEC sp_procxmode TeamMemberCreditOfficer, unchained;
DROP PROCEDURE TeamMemberDataAccessPrivileDel;
--/
CREATE PROCEDURE TeamMemberDataAccessPrivileDel (
/**************************************************************************
**
** Procedure:	TeamMemberDataAccessPrivileDel
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TeamMember        varchar(75) ,
	@AccessObject      varchar(255)           ,
	@AccessPrivilege   int,
	@AccessEntity      varchar(255)           ,
	@AccessEntityValue varchar(255)           
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from TeamMemberDataAccessPrivileges 
where TeamMember = @TeamMember
and    AccessObject = @AccessObject
and    AccessPrivilege = @AccessPrivilege
and    AccessEntity = @AccessEntity
and    AccessEntityValue = @AccessEntityValue
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from TeamMemberDataAccessPrivileges table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from TeamMemberDataAccessPrivileges table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage + ","
	select @ErrorMessage = @ErrorMessage + "AccessObject '" + convert(varchar(255), @AccessObject) + "'"
	select @ErrorMessage = @ErrorMessage + ","
	select @ErrorMessage = @ErrorMessage + "AccessPrivilege '" + convert(varchar(255), @AccessPrivilege) + "'"
	select @ErrorMessage = @ErrorMessage + ","
	select @ErrorMessage = @ErrorMessage + "AccessEntity '" + convert(varchar(255), @AccessEntity) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "AccessEntityValue '" + convert(varchar(255), @AccessEntityValue) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TeamMemberDataAccessPrivileDel, unchained;
DROP PROCEDURE TeamMemberDataAccessPrivileIns;
--/
CREATE PROCEDURE TeamMemberDataAccessPrivileIns (
/**************************************************************************
**
** Procedure:	TeamMemberDataAccessPrivileIns
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TeamMember        varchar(75) ,
	@AccessObject      varchar(255)           ,
	@AccessPrivilege   int,
	@AccessEntity      varchar(255)           ,
	@AccessEntityValue varchar(255)           ,
	@FilterType        varchar(255)            = NULL,
	@ApprovedBy        varchar(75)  = NULL,
	@Approved          datetime            = NULL,
	@ApprovedTimeZone  varchar(40)       = NULL
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into TeamMemberDataAccessPrivileges (
	TeamMember,
	AccessObject,
	AccessPrivilege,
	AccessEntity,
	AccessEntityValue,
	FilterType,
	ApprovedBy,
	Approved,
	ApprovedTimeZone )
values (
	@TeamMember,
	@AccessObject,
	@AccessPrivilege,
	@AccessEntity,
	@AccessEntityValue,
	@FilterType,
	@ApprovedBy,
	@Approved,
	@ApprovedTimeZone )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into TeamMemberDataAccessPrivileges table for key(s) "
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "AccessObject '" + convert(varchar(255), @AccessObject) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "AccessPrivilege '" + convert(varchar(255), @AccessPrivilege) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "AccessEntity '" + convert(varchar(255), @AccessEntity) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "AccessEntityValue '" + convert(varchar(255), @AccessEntityValue) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TeamMemberDataAccessPrivileIns, unchained;
DROP PROCEDURE TeamMemberDataAccessPrivileUpd;
--/
CREATE PROCEDURE TeamMemberDataAccessPrivileUpd (
/**************************************************************************
**
** Procedure:	TeamMemberDataAccessPrivileUpd
**
** Version: 	@(#)TeamMemberDataAccessPrivileUpd.sp	128.6 11/06/08
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TeamMember        varchar(75) ,
	@AccessObject      varchar(255)           ,
	@AccessPrivilege   int,
	@AccessEntity      varchar(255)           ,
	@AccessEntityValue varchar(255)           ,
	@FilterType        varchar(255)            = "#$%@",
	@ApprovedBy        varchar(75)  = "#$%@",
	@Approved          datetime            = '99991231',
	@ApprovedTimeZone  varchar(40)       = "#$%@"
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @filterType        varchar(255)           ,
        @approvedby        varchar(75) ,
        @approved          datetime           ,
        @approvedtimezone  varchar(40)      
Select @filterType = FilterType,
       @approvedby = ApprovedBy,
       @approved = Approved,
       @approvedtimezone = ApprovedTimeZone
from TeamMemberDataAccessPrivileges
  where TeamMember = @TeamMember
  and AccessObject = @AccessObject
  and AccessPrivilege = @AccessPrivilege
  and AccessEntity = @AccessEntity
  and AccessEntityValue = @AccessEntityValue
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from TeamMemberDataAccessPrivileges table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from TeamMemberDataAccessPrivileges table for key(s) "
	goto ERROR_EXIT
end
if @FilterType != "#$%@"
	select @filterType = @FilterType
if @ApprovedBy != "#$%@"
	select @approvedby = @ApprovedBy
if @Approved != '99991231'
	select @approved = @Approved
if @ApprovedTimeZone != "#$%@"
	select @approvedtimezone = @ApprovedTimeZone
Update TeamMemberDataAccessPrivileges
set	FilterType = @filterType,
	ApprovedBy = @approvedby,
	Approved = @approved,
	ApprovedTimeZone = @approvedtimezone
  where TeamMember = @TeamMember
  and AccessObject = @AccessObject
  and AccessPrivilege = @AccessPrivilege
  and AccessEntity = @AccessEntity
  and AccessEntityValue = @AccessEntityValue
if @@error != 0
begin
	select @ErrorMessage = "Could not update TeamMemberDataAccessPrivileges table for key(s) "
	goto ERROR_EXIT
end
---- UPDATE EMDB TeamMemberDataAccessPrivileges table ---
if ( select count(*)
     from EMDB..TeamMemberDataAccessPrivileges
     where TeamMember = @TeamMember
     and AccessObject = @AccessObject
     and AccessPrivilege = @AccessPrivilege
     and AccessEntity = @AccessEntity
     and AccessEntityValue = @AccessEntityValue ) = 1
     begin
	
	     --- update the record
	     update EMDB..TeamMemberDataAccessPrivileges
	     set FilterType = @filterType,
		 ApprovedBy = @approvedby,
		 Approved = @approved,
		 ApprovedTimeZone = @approvedtimezone
	     where TeamMember = @TeamMember
	     and AccessObject = @AccessObject
	     and AccessPrivilege = @AccessPrivilege
	     and AccessEntity = @AccessEntity
	     and AccessEntityValue = @AccessEntityValue
		
	     if @@error != 0
	     begin
		select @ErrorMessage = "Could not update the EMDB TeamMemberDataAccessPrivileges table for key(s) "
		goto ERROR_EXIT
	     end
     end
else
     begin
	     --- insert the record as its not present in the table
	     insert EMDB..TeamMemberDataAccessPrivileges
	         		select  TeamMember,
	        		AccessObject,
		        	AccessPrivilege,     
				AccessEntity,     
				AccessEntityValue,     
				FilterType,
				ApprovedBy,
				Approved,
				ApprovedTimeZone
	     from  CDB..TeamMemberDataAccessPrivileges CDB_TMDAP 
	     where CDB_TMDAP.TeamMember = @TeamMember
	     and CDB_TMDAP.AccessObject = @AccessObject
	     and CDB_TMDAP.AccessPrivilege = @AccessPrivilege
	     and CDB_TMDAP.AccessEntity = @AccessEntity
	     and CDB_TMDAP.AccessEntityValue = @AccessEntityValue
	
	     if @@error != 0
	     begin
		select @ErrorMessage = "Could not insert EMDB TeamMemberDataAccessPrivileges table for key(s) "
		goto ERROR_EXIT
	     end
     end
     goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "AccessObject '" + convert(varchar(255), @AccessObject) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "AccessPrivilege '" + convert(varchar(255), @AccessPrivilege) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "AccessEntity '" + convert(varchar(255), @AccessEntity) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "AccessEntityValue '" + convert(varchar(255), @AccessEntityValue) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TeamMemberDataAccessPrivileUpd, unchained;
DROP PROCEDURE TeamMemberDelete;
--/
CREATE PROCEDURE TeamMemberDelete (
/**************************************************************************
**
** Procedure:	TeamMemberDelete
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TeamMember               varchar(75) 
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from TeamMember 
where TeamMember = @TeamMember
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from TeamMember table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from TeamMember table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TeamMemberDelete, unchained;
DROP PROCEDURE TeamMemberEmailList;
--/
CREATE PROCEDURE TeamMemberEmailList
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "%W% %G%"
select "CodeType", "TeamMemberEmailList", "TeamMemberEmailAddress", NULL, NULL, NULL
select "TeamMemberEmailList",TeamMember,EMailAddress,NULL,NULL,NULL from TeamMember where TeamMember in(select TeamMember from TeamMemberGroupLink where TeamMemberGroup like '%ISDATicket%')


/
EXEC sp_procxmode TeamMemberEmailList, unchained;
DROP PROCEDURE TeamMemberGCO;
--/
CREATE PROCEDURE TeamMemberGCO
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "%W% %G%"
select "CodeType", "TeamMemberGCO", "TeamMemberGroupName", NULL, NULL, NULL
select "TeamMemberGCO", TeamMember, TeamMemberGroup, NULL, NULL, NULL
from CDB.dbo.TeamMemberGroupLink
where TeamMemberGroup like 'ISDATicket%GatekeeperCO-%' order by TeamMember


/
EXEC sp_procxmode TeamMemberGCO, unchained;
DROP PROCEDURE TeamMemberGatekeeper;
--/
CREATE PROCEDURE TeamMemberGatekeeper
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "%W% %G%"
select "CodeType", "TeamMemberGatekeeper","TeamMemberGroupName",NULL, NULL,NULL
select "TeamMemberGatekeeper", TeamMember,TeamMemberGroup,NULL,  NULL,NULL
from CDB.dbo.TeamMemberGroupLink
where TeamMemberGroup like 'ISDATicket%Gatekeeper-%'order by TeamMember


/
EXEC sp_procxmode TeamMemberGatekeeper, unchained;
DROP PROCEDURE TeamMemberGroupLinkDelete;
--/
CREATE PROCEDURE TeamMemberGroupLinkDelete (
/**************************************************************************
**
** Procedure:	TeamMemberGroupLinkDelete
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TeamMember       varchar(75),
	@TeamMemberGroup  varchar(75)
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from TeamMemberGroupLink 
where TeamMember = @TeamMember
and    TeamMemberGroup = @TeamMemberGroup
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from TeamMemberGroupLink table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from TeamMemberGroupLink table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "TeamMemberGroup '" + convert(varchar(255), @TeamMemberGroup) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TeamMemberGroupLinkDelete, unchained;
DROP PROCEDURE TeamMemberGroupLinkInsert;
--/
CREATE PROCEDURE TeamMemberGroupLinkInsert (
/**************************************************************************
**
** Procedure:	TeamMemberGroupLinkInsert
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TeamMember       varchar(75),
	@TeamMemberGroup  varchar(75),
	@ApprovedBy       varchar(75) = NULL,
	@Approved         datetime           = NULL,
	@ApprovedTimeZone varchar(40)      = NULL
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into TeamMemberGroupLink (
	TeamMember,
	TeamMemberGroup,
	ApprovedBy,
	Approved,
	ApprovedTimeZone )
values (
	@TeamMember,
	@TeamMemberGroup,
	@ApprovedBy,
	@Approved,
	@ApprovedTimeZone )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into TeamMemberGroupLink table for key(s) "
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "TeamMemberGroup '" + convert(varchar(255), @TeamMemberGroup) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TeamMemberGroupLinkInsert, unchained;
DROP PROCEDURE TeamMemberGroupLinkUpdate;
--/
CREATE PROCEDURE TeamMemberGroupLinkUpdate (
/**************************************************************************
**
** Procedure:	TeamMemberGroupLinkUpdate
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TeamMember       varchar(75),
	@TeamMemberGroup  varchar(75),
	@ApprovedBy       varchar(75) = "#$%@",
	@Approved         datetime           = '99991231',
	@ApprovedTimeZone varchar(40)      = "#$%@"
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @approvedby       varchar(75),
        @approved         datetime          ,
        @approvedtimezone varchar(40)     
Select @approvedby = ApprovedBy,
       @approved = Approved,
       @approvedtimezone = ApprovedTimeZone
from TeamMemberGroupLink
  where TeamMember = @TeamMember
  and TeamMemberGroup = @TeamMemberGroup
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from TeamMemberGroupLink table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from TeamMemberGroupLink table for key(s) "
	goto ERROR_EXIT
end
if @ApprovedBy != "#$%@"
	select @approvedby = @ApprovedBy
if @Approved != '99991231'
	select @approved = @Approved
if @ApprovedTimeZone != "#$%@"
	select @approvedtimezone = @ApprovedTimeZone
Update TeamMemberGroupLink
set	ApprovedBy = @approvedby,
	Approved = @approved,
	ApprovedTimeZone = @approvedtimezone
  where TeamMember = @TeamMember
  and TeamMemberGroup = @TeamMemberGroup
if @@error != 0
begin
	select @ErrorMessage = "Could not update TeamMemberGroupLink table for key(s) "
	goto ERROR_EXIT
end
--- EMDB TeamMemberGroupLink update ---
if ( select count(*)
     from EMDB..TeamMemberGroupLink
     where TeamMember = @TeamMember
     and TeamMemberGroup = @TeamMemberGroup ) = 1
	begin
		update EMDB..TeamMemberGroupLink
		set	ApprovedBy = @approvedby,
			Approved = @approved,
			ApprovedTimeZone = @approvedtimezone
		  where TeamMember = @TeamMember
		  and TeamMemberGroup = @TeamMemberGroup
		
		if @@error != 0
		begin
			select @ErrorMessage = "Could not update EMDB TeamMemberGroupLink table for key(s) "
			goto ERROR_EXIT
		end
	end
else
	begin
		--- insert in to EMDB..TeamMemberGroupLink ---
		insert EMDB..TeamMemberGroupLink
	        select  TeamMember,
			TeamMemberGroup,
	                ApprovedBy,
	                Approved,
	                ApprovedTimeZone
		from CDB..TeamMemberGroupLink CDB_TMGL
		where CDB_TMGL.TeamMember = @TeamMember
		and CDB_TMGL.TeamMemberGroup = @TeamMemberGroup
	
		if @@error != 0
		begin
			select @ErrorMessage = "Could not insert EMDB TeamMemberGroupLink table for key(s) "
			goto ERROR_EXIT
		end
	end
	
	goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "TeamMemberGroup '" + convert(varchar(255), @TeamMemberGroup) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TeamMemberGroupLinkUpdate, unchained;
DROP PROCEDURE TeamMemberGroupPrivileges;
--/
CREATE PROCEDURE TeamMemberGroupPrivileges(@SybaseID varchar(75))
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
select distinct TeamMemberPrivilege from CDB..TeamMember t, CDB..TeamMemberPrivileges p
where t.TeamMember = p.TeamMember and t.SybaseID=@SybaseID
union
select distinct TeamMemberPrivilege from CDB..TeamMember t, CDB..TeamMemberPrivileges p
where t.TeamMember = p.TeamMember
and t.TeamMember in 
(select TeamMemberGroup from CDB..TeamMember t, CDB..TeamMemberGroupLink g 
where t.TeamMember = g.TeamMember and t.SybaseID=@SybaseID)

/
EXEC sp_procxmode TeamMemberGroupPrivileges, unchained;
DROP PROCEDURE TeamMemberGroups;
--/
CREATE PROCEDURE TeamMemberGroups
/**************************************************************************
**
** Procedure: TeamMemberGroups
**
** Version: %W% %G%
**
** Notes:	Returns list of team member groups
**
**************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
set nocount on
declare @version  varchar(255)
select @version = "@(#) %W% %G%"
select "CodeType", "TeamMemberGroups", NULL, NULL, NULL, NULL
select "TeamMemberGroups", TeamMember, " ", " ", " ", " "
from TeamMember
where TeamMemberType = 2


/
EXEC sp_procxmode TeamMemberGroups, unchained;
DROP PROCEDURE TeamMemberInfoAndPrivgEERS;
--/
CREATE PROCEDURE TeamMemberInfoAndPrivgEERS
/**************************************************************************
**
** Procedure:   TeamMemberInfoAndPrivgEERS
**
** Version: %W% %G%
**
** Notes:       Gives the TeamMember information. This proc is created
                for Constantin Makralis
**
**************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
select T.TeamMember, 
    T.Department, 
    T.SybaseID, 
    T.EmployeeIdentification, 
    E.SOEID, 
    E.RITSID,
    TP.TeamMemberPrivilege Privilege,
    TP.TeamMemberPrivilege Description
into #temp
from TeamMemberPrivileges TP, 
        TeamMember T, 
        EmployeeDetails E
where T.EmployeeIdentification = E.EmployeeIdentification 
and T.TeamMember = TP.TeamMember
and ( upper(T.SybaseID) not like '%DELETED'
        or T.SybaseID not like '%DELTED')
and upper(T.SybaseID) not like '%PROFILE'
and T.TeamMemberType = 1
and ISNULL(T.FunctionalAccount,0) != 2
UNION
select T.TeamMember, 
    T.Department, 
    T.SybaseID, 
    T.EmployeeIdentification, 
    E.SOEID, 
    E.RITSID,
    TP.TeamMemberPrivilege Privilege,
    TP.TeamMemberPrivilege Description
from TeamMemberPrivileges TP,
    TeamMemberGroupLink TG,
    TeamMember T, 
    EmployeeDetails E
where T.EmployeeIdentification = E.EmployeeIdentification
and T.TeamMember = TG.TeamMember
and TP.TeamMember=TG.TeamMemberGroup
and ( upper(T.SybaseID) not like '%DELETED'
        or T.SybaseID not like '%DELTED')
and upper(T.SybaseID) not like '%PROFILE'
and ISNULL(T.FunctionalAccount,0)!=2
and T.TeamMemberType = 1
update #temp
set t.Description = c.Description
from #temp t, CDB..Code c
where t.Privilege = c.Code
and c.Type = 'TeamMemberPrivilegeDescription'
select "Application ID~Last Name~First Name~Login ID~RITS ID~GEID ID~Application Function Title Code~Application Function Title Code Description~SOE ID~Second Level Entitlement Description"
select distinct
        "000263" +"~"+
        convert(varchar(255),T.TeamMember) +"~"+
        "" +"~"+
       convert(varchar(255),T.SybaseID) +"~"+
        convert(varchar(255),T.RITSID) +"~"+
        convert(varchar(255),T.EmployeeIdentification) +"~"+
        convert(varchar(255),T.Privilege) +"~"+
        convert(varchar(255),T.Description) +"~"+
        convert(varchar(255),T.SOEID) +"~"+""
from #temp T
order by T.TeamMember
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TeamMemberInfoAndPrivgEERS, unchained;
DROP PROCEDURE TeamMemberInfoAndPrivileges;
--/
CREATE PROCEDURE TeamMemberInfoAndPrivileges 
/**************************************************************************
**
** Procedure:	TeamMemberInfoAndPrivileges
**
** Version: 	@(#)TeamMemberInfoAndPrivileges.proc	63.1 08/07/01
**
** Notes:	Gives the TeamMember information. This proc is created
		for Constantin Makralis
**
**************************************************************************/
as
declare @version varchar(255)
select @version = "@(#)TeamMemberInfoAndPrivileges.proc	63.1 08/07/01"
select  T.TeamMember, T.Department, T.SybaseID, T.EmployeeIdentification, 
	Privilege = convert(varchar(255), TP.TeamMemberPrivilege)
into #temp
from TeamMemberPrivileges TP, TeamMember T
where TP.TeamMember = T.TeamMember
and T.SybaseID not like '%DELETED'
and T.TeamMemberType = 1
UNION
select  T.TeamMember, T.Department, T.SybaseID, T.EmployeeIdentification, 
	convert(varchar(255), TP.TeamMemberPrivilege)
from TeamMemberPrivileges TP, TeamMember T, TeamMemberGroupLink TG
where T.TeamMember = TG.TeamMember
and TG.TeamMemberGroup = TP.TeamMember
and T.SybaseID not like '%DELETED'
and T.TeamMemberType = 1
select	TeamMember, 
	AccessObject,
	Privilege = convert(varchar(6), AccessPrivilege),
	AccessEntity,
	AccessEntityValue,
	FilterType
into #temp2
from TeamMemberDataAccessPrivileges
update #temp2
set	Privilege =	case Privilege
				when "1" then "View"
				when "2" then "Modify"
				when "3" then "Delete"
				else Privilege
			end
insert #temp
select T.TeamMember, T.Department, T.SybaseID, T.EmployeeIdentification,
	Privilege + ":" + AccessObject + ":" + AccessEntity + ":" + AccessEntityValue + ":" FilterType
from TeamMember T, #temp2 TP
where T.TeamMember = TP.TeamMember
and T.SybaseID not like '%DELETED'
and T.TeamMemberType = 1
UNION
select T.TeamMember, T.Department, T.SybaseID, T.EmployeeIdentification,
	Privilege + ":" + AccessObject + ":" + AccessEntity + ":" + AccessEntityValue + ":" FilterType
from TeamMember T, #temp2 TP, TeamMemberGroupLink TG
where T.TeamMember = TG.TeamMember
and TG.TeamMemberGroup = TP.TeamMember
and T.SybaseID not like '%DELETED'
and T.TeamMemberType = 1
	
select "TeamMember~Department~SybaseID~EmployeeID~TeamMemberPrivilege"
select  convert(varchar(255),T.TeamMember) +"~"+
        convert(varchar(255),T.Department) +"~"+
        convert(varchar(255),T.SybaseID) +"~"+
        convert(varchar(255),T.EmployeeIdentification) +"~"+
        convert(varchar(255),T.Privilege)
from #temp T
order by T.TeamMember
STORED_PROCEDURE_EXIT:

/
EXEC sp_procxmode TeamMemberInfoAndPrivileges, unchained;
DROP PROCEDURE TeamMemberInsert;
--/
CREATE PROCEDURE TeamMemberInsert (
/**************************************************************************
**
** Procedure:	TeamMemberInsert
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TeamMember               varchar(75) ,
	@Department               varchar(255)            = NULL,
	@SybaseID                 varchar(255) = NULL,
	@EmployeeIdentification   int         = NULL,
	@EMailAddress             varchar(255)    = NULL,
	@Telephone                varchar(255) = NULL,
	@CRC                      int             = NULL,
	@CostCentre               varchar(40)       = NULL,
	@PWD                      varchar(40)       = NULL,
	@OldPWD                   varchar(255)            = NULL,
	@PreExpired               int       = NULL,
	@Disabled                 int       = NULL,
	@LoginAttempts            int     = NULL,
	@EntryDate                int                = NULL,
	@ExpiryDate               int                = NULL,
	@TeamMemberType           int  = NULL,
	@SiteminderAuthentication int       = NULL,
	@FunctionalAccount        int       = NULL,
	@Owner                    varchar(255)            = NULL,
	@Description              varchar(255)            = NULL,
	@FirstName                varchar(75)  = NULL,
	@LastName                 varchar(75)  = NULL,
	@Supervisor               varchar(75)  = NULL,
	@Region                   varchar(40)       = NULL,
	@Country                  varchar(40)       = NULL,
	@Location                 varchar(255)            = NULL,
	@BusinessAreaID           int     = NULL,
	@ApprovedBy               varchar(75)  = NULL,
	@Approved                 datetime            = NULL,
	@ApprovedTimeZone         varchar(40)       = NULL,
	@CreatedBy                varchar(75)  = NULL,
	@Created                  datetime            = NULL,
	@CreatedTimeZone          varchar(40)       = NULL,
	@BusinessLine             varchar(40)       = NULL,
	@LastModifyBy             varchar(75)  = NULL,
	@LastModify               datetime            = NULL,
	@LastModifyTimeZone       varchar(40)       = NULL
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into TeamMember (
	TeamMember,
	Department,
	SybaseID,
	EmployeeIdentification,
	EMailAddress,
	Telephone,
	CRC,
	CostCentre,
	PWD,
	OldPWD,
	PreExpired,
	Disabled,
	LoginAttempts,
	EntryDate,
	ExpiryDate,
	TeamMemberType,
	SiteminderAuthentication,
	FunctionalAccount,
	Owner,
	Description,
	FirstName,
	LastName,
	Supervisor,
	Region,
	Country,
	Location,
	BusinessAreaID,
	ApprovedBy,
	Approved,
	ApprovedTimeZone,
	CreatedBy,
	Created,
	CreatedTimeZone,
	BusinessLine,
	LastModifyBy,
	LastModify,
	LastModifyTimeZone )
values (
	@TeamMember,
	@Department,
	@SybaseID,
	@EmployeeIdentification,
	@EMailAddress,
	@Telephone,
	@CRC,
	@CostCentre,
	@PWD,
	@OldPWD,
	@PreExpired,
	@Disabled,
	@LoginAttempts,
	@EntryDate,
	@ExpiryDate,
	@TeamMemberType,
	@SiteminderAuthentication,
	@FunctionalAccount,
	@Owner,
	@Description,
	@FirstName,
	@LastName,
	@Supervisor,
	@Region,
	@Country,
	@Location,
	@BusinessAreaID,
	@ApprovedBy,
	@Approved,
	@ApprovedTimeZone,
	@CreatedBy,
	@Created,
	@CreatedTimeZone,
	@BusinessLine,
	@LastModifyBy,
	@LastModify,
	@LastModifyTimeZone )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into TeamMember table for key(s) "
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TeamMemberInsert, unchained;
DROP PROCEDURE TeamMemberLimitsDelete;
--/
CREATE PROCEDURE TeamMemberLimitsDelete (
/**************************************************************************
**
** Procedure:	TeamMemberLimitsDelete
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TeamMember       varchar(75),
	@Type             varchar(255)          
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from TeamMemberLimits 
where TeamMember = @TeamMember
and    Type = @Type
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from TeamMemberLimits table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from TeamMemberLimits table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "Type '" + convert(varchar(255), @Type) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TeamMemberLimitsDelete, unchained;
DROP PROCEDURE TeamMemberLimitsInsert;
--/
CREATE PROCEDURE TeamMemberLimitsInsert (
/**************************************************************************
**
** Procedure:	TeamMemberLimitsInsert
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TeamMember       varchar(75),
	@Type             varchar(255)          ,
	@Limit            int            = NULL,
	@ApprovedBy       varchar(75) = NULL,
	@Approved         datetime           = NULL,
	@ApprovedTimeZone varchar(40)      = NULL
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into TeamMemberLimits (
	TeamMember,
	Type,
	Limit,
	ApprovedBy,
	Approved,
	ApprovedTimeZone )
values (
	@TeamMember,
	@Type,
	@Limit,
	@ApprovedBy,
	@Approved,
	@ApprovedTimeZone )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into TeamMemberLimits table for key(s) "
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "Type '" + convert(varchar(255), @Type) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TeamMemberLimitsInsert, unchained;
DROP PROCEDURE TeamMemberLimitsUpdate;
--/
CREATE PROCEDURE TeamMemberLimitsUpdate (
/**************************************************************************
**
** Procedure:	TeamMemberLimitsUpdate
**
** Version: 	@(#)TeamMemberLimitsUpdate.sp	128.3 11/06/08
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TeamMember       varchar(75),
	@Type             varchar(255)          ,
	@Limit            int            = -2147483647,
	@ApprovedBy       varchar(75) = "#$%@",
	@Approved         datetime           = '99991231',
	@ApprovedTimeZone varchar(40)      = "#$%@"
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @limit            int           ,
        @approvedby       varchar(75),
        @approved         datetime          ,
        @approvedtimezone varchar(40)     
Select @limit = Limit,
       @approvedby = ApprovedBy,
       @approved = Approved,
       @approvedtimezone = ApprovedTimeZone
from TeamMemberLimits
  where TeamMember = @TeamMember
  and Type = @Type
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from TeamMemberLimits table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from TeamMemberLimits table for key(s) "
	goto ERROR_EXIT
end
if @Limit != -2147483647
	select @limit = @Limit
if @ApprovedBy != "#$%@"
	select @approvedby = @ApprovedBy
if @Approved != '99991231'
	select @approved = @Approved
if @ApprovedTimeZone != "#$%@"
	select @approvedtimezone = @ApprovedTimeZone
Update TeamMemberLimits
set    Limit = @limit,
	ApprovedBy = @approvedby,
	Approved = @approved,
	ApprovedTimeZone = @approvedtimezone
where TeamMember = @TeamMember
and Type = @Type
if @@error != 0
begin
	select @ErrorMessage = "Could not update TeamMemberLimits table for key(s) "
	goto ERROR_EXIT
end
--- Update EMDB TeamMemberLimits ---
if ( select count(*)
	from EMDB..TeamMemberLimits
	where TeamMember = @TeamMember
	and Type = @Type ) = 1
	begin
	--- update the record ---
		update EMDB..TeamMemberLimits
		set	Limit = @limit,
			ApprovedBy = @approvedby,
			Approved = @approved,
			ApprovedTimeZone = @approvedtimezone
		  where TeamMember = @TeamMember
		  and Type = @Type
		
		if @@error != 0
		begin
			select @ErrorMessage = "Could not update EMDB TeamMemberLimits table for key(s) "
			goto ERROR_EXIT
		end
	end
else
	begin
	--- insert the record ---
		insert EMDB..TeamMemberLimits
	       	select  TeamMember,
			Type,
			Limit,
	                ApprovedBy,
	                Approved,
	                ApprovedTimeZone
		from CDB..TeamMemberLimits CDB_TML
		where CDB_TML.TeamMember = @TeamMember
		and CDB_TML.Type = @Type
	
		if @@error != 0
		begin
			select @ErrorMessage = "Could not insert EMDB TeamMemberLimits table for key(s) "
			goto ERROR_EXIT
		end
	end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "Type '" + convert(varchar(255), @Type) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TeamMemberLimitsUpdate, unchained;
DROP PROCEDURE TeamMemberNegotiator;
--/
CREATE PROCEDURE TeamMemberNegotiator
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "%W% %G%"
select "CodeType", "TeamMemberNegotiator", "TeamMemberGroupName", NULL, NULL, NULL
select "TeamMemberNegotiator", TeamMember, TeamMemberGroup, NULL, NULL, NULL
from CDB.dbo.TeamMemberGroupLink
where TeamMemberGroup like 'ISDATicket%Negotiator-%' order by TeamMember


/
EXEC sp_procxmode TeamMemberNegotiator, unchained;
DROP PROCEDURE TeamMemberPreferencesDelete;
--/
CREATE PROCEDURE TeamMemberPreferencesDelete (
/**************************************************************************
**
** Procedure:	TeamMemberPreferencesDelete
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TeamMember varchar(75),
	@Type       varchar(255)          
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from TeamMemberPreferences 
where TeamMember = @TeamMember
and    Type = @Type
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from TeamMemberPreferences table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from TeamMemberPreferences table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "Type '" + convert(varchar(255), @Type) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TeamMemberPreferencesDelete, unchained;
DROP PROCEDURE TeamMemberPreferencesInsert;
--/
CREATE PROCEDURE TeamMemberPreferencesInsert (
/**************************************************************************
**
** Procedure:	TeamMemberPreferencesInsert
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TeamMember varchar(75),
	@Type       varchar(255)          ,
	@Value      varchar(255)           = NULL
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into TeamMemberPreferences (
	TeamMember,
	Type,
	Value )
values (
	@TeamMember,
	@Type,
	@Value )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into TeamMemberPreferences table for key(s) "
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "Type '" + convert(varchar(255), @Type) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TeamMemberPreferencesInsert, unchained;
DROP PROCEDURE TeamMemberPreferencesUpdate;
--/
CREATE PROCEDURE TeamMemberPreferencesUpdate (
/**************************************************************************
**
** Procedure:	TeamMemberPreferencesUpdate
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TeamMember varchar(75),
	@Type       varchar(255)          ,
	@Value      varchar(255)           = "#$%@"
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @value      varchar(255)          
Select @value = Value
from TeamMemberPreferences
  where TeamMember = @TeamMember
  and Type = @Type
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from TeamMemberPreferences table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from TeamMemberPreferences table for key(s) "
	goto ERROR_EXIT
end
if @Value != "#$%@"
	select @value = @Value
Update TeamMemberPreferences
set	Value = @value
  where TeamMember = @TeamMember
  and Type = @Type
if @@error != 0
begin
	select @ErrorMessage = "Could not update TeamMemberPreferences table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "Type '" + convert(varchar(255), @Type) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TeamMemberPreferencesUpdate, unchained;
DROP PROCEDURE TeamMemberPrivilegesDelete;
--/
CREATE PROCEDURE TeamMemberPrivilegesDelete (
/**************************************************************************
**
** Procedure:	TeamMemberPrivilegesDelete
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TeamMember          varchar(75),
	@TeamMemberPrivilege varchar(255)          
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from TeamMemberPrivileges 
where TeamMember = @TeamMember
and    TeamMemberPrivilege = @TeamMemberPrivilege
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from TeamMemberPrivileges table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from TeamMemberPrivileges table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "TeamMemberPrivilege '" + convert(varchar(255), @TeamMemberPrivilege) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TeamMemberPrivilegesDelete, unchained;
DROP PROCEDURE TeamMemberPrivilegesInsert;
--/
CREATE PROCEDURE TeamMemberPrivilegesInsert (
/**************************************************************************
**
** Procedure:	TeamMemberPrivilegesInsert
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TeamMember          varchar(75),
	@TeamMemberPrivilege varchar(255)          ,
	@ApprovedBy          varchar(75) = NULL,
	@Approved            datetime           = NULL,
	@ApprovedTimeZone    varchar(40)      = NULL
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into TeamMemberPrivileges (
	TeamMember,
	TeamMemberPrivilege,
	ApprovedBy,
	Approved,
	ApprovedTimeZone )
values (
	@TeamMember,
	@TeamMemberPrivilege,
	@ApprovedBy,
	@Approved,
	@ApprovedTimeZone )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into TeamMemberPrivileges table for key(s) "
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "TeamMemberPrivilege '" + convert(varchar(255), @TeamMemberPrivilege) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TeamMemberPrivilegesInsert, unchained;
DROP PROCEDURE TeamMemberPrivilegesUpdate;
--/
CREATE PROCEDURE TeamMemberPrivilegesUpdate (
/**************************************************************************
**
** Procedure:	TeamMemberPrivilegesUpdate
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TeamMember          varchar(75),
	@TeamMemberPrivilege varchar(255)          ,
	@ApprovedBy          varchar(75) = "#$%@",
	@Approved            datetime           = '99991231',
	@ApprovedTimeZone    varchar(40)      = "#$%@"
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @approvedby          varchar(75),
        @approved            datetime          ,
        @approvedtimezone    varchar(40)     
Select @approvedby = ApprovedBy,
       @approved = Approved,
       @approvedtimezone = ApprovedTimeZone
from TeamMemberPrivileges
  where TeamMember = @TeamMember
  and TeamMemberPrivilege = @TeamMemberPrivilege
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from TeamMemberPrivileges table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from TeamMemberPrivileges table for key(s) "
	goto ERROR_EXIT
end
if @ApprovedBy != "#$%@"
	select @approvedby = @ApprovedBy
if @Approved != '99991231'
	select @approved = @Approved
if @ApprovedTimeZone != "#$%@"
	select @approvedtimezone = @ApprovedTimeZone
Update TeamMemberPrivileges
set	ApprovedBy = @approvedby,
	Approved = @approved,
	ApprovedTimeZone = @approvedtimezone
  where TeamMember = @TeamMember
  and TeamMemberPrivilege = @TeamMemberPrivilege
if @@error != 0
begin
	select @ErrorMessage = "Could not update TeamMemberPrivileges table for key(s) "
	goto ERROR_EXIT
end
--- update EMDB TeamMemberPrivileges table ---
if ( select count(*) 
	from EMDB..TeamMemberPrivileges
	where TeamMember = @TeamMember
	and TeamMemberPrivilege = @TeamMemberPrivilege ) = 1
	begin
	--- update the record 	
		Update EMDB..TeamMemberPrivileges
		set	ApprovedBy = @approvedby,
			Approved = @approved,
			ApprovedTimeZone = @approvedtimezone
		where TeamMember = @TeamMember
		and TeamMemberPrivilege = @TeamMemberPrivilege
	
		if @@error != 0
		begin
			select @ErrorMessage = "Could not update EMDB TeamMemberPrivileges table for key(s) "
			goto ERROR_EXIT
		end
	end
else
	begin
	--- insert the record ---
		insert EMDB..TeamMemberPrivileges
	        select TeamMember,
	               TeamMemberPrivilege,
	               ApprovedBy,
	               Approved,
	               ApprovedTimeZone
	        from CDB..TeamMemberPrivileges CDB_TMP
		where  CDB_TMP.TeamMember = @TeamMember
		and CDB_TMP.TeamMemberPrivilege = @TeamMemberPrivilege
	
		if @@error != 0
		begin
			select @ErrorMessage = "Could not insert EMDB TeamMemberPrivileges table for key(s) "
			goto ERROR_EXIT
		end
	end
	goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "TeamMemberPrivilege '" + convert(varchar(255), @TeamMemberPrivilege) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TeamMemberPrivilegesUpdate, unchained;
DROP PROCEDURE TeamMemberRM;
--/
CREATE PROCEDURE TeamMemberRM
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version varchar(255)
select @version = "%W% %G%"
select "CodeType", "TeamMemberRM", "TeamMemberGroupName", NULL, NULL, NULL
select "TeamMemberRM", TeamMember, TeamMemberGroup, NULL, NULL, NULL
from CDB.dbo.TeamMemberGroupLink
where TeamMemberGroup like 'ISDATicket-RM-%' order by TeamMember


/
EXEC sp_procxmode TeamMemberRM, unchained;
DROP PROCEDURE TeamMemberUpdate;
--/
CREATE PROCEDURE TeamMemberUpdate (
/**************************************************************************
**
** Procedure:	TeamMemberUpdate
**
** Version: 	@(#)TeamMemberUpdate.sp	128.7 11/06/08
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@TeamMember               varchar(75) ,
	@Department               varchar(255)            = "#$%@",
	@SybaseID                 varchar(255) = "#$%@",
	@EmployeeIdentification   int         = -2147483647,
	@EMailAddress             varchar(255)    = "#$%@",
	@Telephone                varchar(255) = "#$%@",
	@CRC                      int             = -2147483647,
	@CostCentre               varchar(40)       = "#$%@",
	@PWD                      varchar(40)       = "#$%@",
	@OldPWD                   varchar(255)            = "#$%@",
	@PreExpired               int       = -2147483647,
	@Disabled                 int       = -2147483647,
	@LoginAttempts            int     = -2147483647,
	@EntryDate                int                = -2147483647,
	@ExpiryDate               int                = -2147483647,
	@TeamMemberType           int  = -2147483647,
	@SiteminderAuthentication int       = -2147483647,
	@FunctionalAccount        int       = -2147483647,
	@Owner                    varchar(255)            = "#$%@",
	@Description              varchar(255)            = "#$%@",
	@FirstName                varchar(75)  = "#$%@",
	@LastName                 varchar(75)  = "#$%@",
	@Supervisor               varchar(75)  = "#$%@",
	@Region                   varchar(40)       = "#$%@",
	@Country                  varchar(40)       = "#$%@",
	@Location                 varchar(255)            = "#$%@",
	@BusinessAreaID           int     = -2147483647,
	@ApprovedBy               varchar(75)  = "#$%@",
	@Approved                 datetime            = '99991231',
	@ApprovedTimeZone         varchar(40)       = "#$%@",
	@CreatedBy                varchar(75)  = "#$%@",
	@Created                  datetime            = '99991231',
	@CreatedTimeZone          varchar(40)       = "#$%@",
	@BusinessLine             varchar(40)       = "#$%@",
	@LastModifyBy             varchar(75)  = "#$%@",
	@LastModify               datetime            = '99991231',
	@LastModifyTimeZone       varchar(40)       = "#$%@"
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @department              varchar(255)           ,
        @sybaseID                varchar(255),
        @employeeIdentification  int        ,
        @eMailAddress            varchar(255)   ,
        @telephone               varchar(255),
        @crc                     int            ,
        @costCenter              varchar(40)      ,
        @password                varchar(40)      ,
        @oldPasswords            varchar(255)           ,
        @preExpired              int      ,
        @disabled                int      ,
        @loginAttempts           int    ,
        @entryDate               int               ,
        @expiryDate              int               ,
        @teamMemberType          int ,
        @siteminderAuthentaction int      ,
        @functionalAccount       int      ,
        @owner                   varchar(255)           ,
        @description             varchar(255)           ,
        @firstname               varchar(75) ,
        @lastname                varchar(75) ,
        @supervisor              varchar(75) ,
        @region                  varchar(40)      ,
        @country                 varchar(40)      ,
        @location                varchar(255)           ,
        @businessareaid          int    ,
        @approvedby              varchar(75) ,
        @approved                datetime           ,
        @approvedtimezone        varchar(40)      ,
        @createdby               varchar(75) ,
        @created                 datetime           ,
        @createdtimezone         varchar(40)      ,
        @businessline            varchar(40)      ,
        @lastmodifyby            varchar(75) ,
        @lastmodify              datetime           ,
        @lastmodifytimezone      varchar(40)      
Select @department = Department,
       @sybaseID = SybaseID,
       @employeeIdentification = EmployeeIdentification,
       @eMailAddress = EMailAddress,
       @telephone = Telephone,
       @crc = CRC,
       @costCenter = CostCentre,
       @password = PWD,
       @oldPasswords = OldPWD,
       @preExpired = PreExpired,
       @disabled = Disabled,
       @loginAttempts = LoginAttempts,
       @entryDate = EntryDate,
       @expiryDate = ExpiryDate,
       @teamMemberType = TeamMemberType,
       @siteminderAuthentaction = SiteminderAuthentication,
       @functionalAccount = FunctionalAccount,
       @owner = Owner,
       @description = Description,
       @firstname = FirstName,
       @lastname = LastName,
       @supervisor = Supervisor,
       @region = Region,
       @country = Country,
       @location = Location,
       @businessareaid = BusinessAreaID,
       @approvedby = ApprovedBy,
       @approved = Approved,
       @approvedtimezone = ApprovedTimeZone,
       @createdby = CreatedBy,
       @created = Created,
       @createdtimezone = CreatedTimeZone,
       @businessline = BusinessLine,
       @lastmodifyby = LastModifyBy,
       @lastmodify = LastModify,
       @lastmodifytimezone = LastModifyTimeZone
from TeamMember
  where TeamMember = @TeamMember
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from TeamMember table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from TeamMember table for key(s) "
	goto ERROR_EXIT
end
if @Department != "#$%@"
	select @department = @Department
if @SybaseID != "#$%@"
	select @sybaseID = @SybaseID
if @EmployeeIdentification != -2147483647
	select @employeeIdentification = @EmployeeIdentification
if @EMailAddress != "#$%@"
	select @eMailAddress = @EMailAddress
if @Telephone != "#$%@"
	select @telephone = @Telephone
if @CRC != -2147483647
	select @crc = @CRC
if @CostCentre != "#$%@"
	select @costCenter = @CostCentre
if @PWD != "#$%@"
	select @password = @PWD
if @OldPWD != "#$%@"
	select @oldPasswords = @OldPWD
if @PreExpired != -2147483647
	select @preExpired = @PreExpired
if @Disabled != -2147483647
	select @disabled = @Disabled
if @LoginAttempts != -2147483647
	select @loginAttempts = @LoginAttempts
if @EntryDate != -2147483647
	select @entryDate = @EntryDate
if @ExpiryDate != -2147483647
	select @expiryDate = @ExpiryDate
if @TeamMemberType != -2147483647
	select @teamMemberType = @TeamMemberType
if @SiteminderAuthentication != -2147483647
	select @siteminderAuthentaction = @SiteminderAuthentication
if @FunctionalAccount != -2147483647
	select @functionalAccount = @FunctionalAccount
if @Owner != "#$%@"
	select @owner = @Owner
if @Description != "#$%@"
	select @description = @Description
if @FirstName != "#$%@"
	select @firstname = @FirstName
if @LastName != "#$%@"
	select @lastname = @LastName
if @Supervisor != "#$%@"
	select @supervisor = @Supervisor
if @Region != "#$%@"
	select @region = @Region
if @Country != "#$%@"
	select @country = @Country
if @Location != "#$%@"
	select @location = @Location
if @BusinessAreaID != -2147483647
	select @businessareaid = @BusinessAreaID
if @ApprovedBy != "#$%@"
	select @approvedby = @ApprovedBy
if @Approved != '99991231'
	select @approved = @Approved
if @ApprovedTimeZone != "#$%@"
	select @approvedtimezone = @ApprovedTimeZone
if @CreatedBy != "#$%@"
	select @createdby = @CreatedBy
if @Created != '99991231'
	select @created = @Created
if @CreatedTimeZone != "#$%@"
	select @createdtimezone = @CreatedTimeZone
if @BusinessLine != "#$%@"
	select @businessline = @BusinessLine
if @LastModifyBy != "#$%@"
	select @lastmodifyby = @LastModifyBy
if @LastModify != '99991231'
	select @lastmodify = @LastModify
if @LastModifyTimeZone != "#$%@"
	select @lastmodifytimezone = @LastModifyTimeZone
Update TeamMember
set	Department = @department,
	SybaseID = @sybaseID,
	EmployeeIdentification = @employeeIdentification,
	EMailAddress = @eMailAddress,
	Telephone = @telephone,
	CRC = @crc,
	CostCentre = @costCenter,
	PWD = @password,
	OldPWD = @oldPasswords,
	PreExpired = @preExpired,
	Disabled = @disabled,
	LoginAttempts = @loginAttempts,
	EntryDate = @entryDate,
	ExpiryDate = @expiryDate,
	TeamMemberType = @teamMemberType,
	SiteminderAuthentication = @siteminderAuthentaction,
	FunctionalAccount = @functionalAccount,
	Owner = @owner,
	Description = @description,
	FirstName = @firstname,
	LastName = @lastname,
	Supervisor = @supervisor,
	Region = @region,
	Country = @country,
	Location = @location,
	BusinessAreaID = @businessareaid,
	ApprovedBy = @approvedby,
	Approved = @approved,
	ApprovedTimeZone = @approvedtimezone,
	CreatedBy = @createdby,
	Created = @created,
	CreatedTimeZone = @createdtimezone,
	BusinessLine = @businessline,
	LastModifyBy = @lastmodifyby,
	LastModify = @lastmodify,
	LastModifyTimeZone = @lastmodifytimezone
  where TeamMember = @TeamMember
if @@error != 0
begin
	select @ErrorMessage = "Could not update TeamMember table for key(s) "
	goto ERROR_EXIT
end
---     		EMDB update starts below                ---
if ( select count(*)
     from EMDB..TeamMember 
     where TeamMember = @TeamMember ) = 1
	begin
	     --- update the row if the record is found
		Update  EMDB..TeamMember
		set	Department = @department,
			SybaseID = @sybaseID,
			EmployeeIdentification = @employeeIdentification,
			EmailAddress = @eMailAddress,
			Telephone = @telephone,
			CRC = @crc,
			CostCentre = @costCenter,
			PWD = @password,
			OldPWD = @oldPasswords,
			PreExpired = @preExpired,
			Disabled = @disabled,
			LoginAttempts = @loginAttempts,
			EntryDate = @entryDate,
			ExpiryDate = @expiryDate,
			TeamMemberType = @teamMemberType,
			SiteMinderAuthentication = @siteminderAuthentaction,
			FunctionalAccount = @functionalAccount,
			Owner = @owner,
			Description = @description,
			FirstName = @firstname,
			LastName = @lastname,
			Supervisor = @supervisor,
			Region = @region,
			Country = @country,
			Location = @location,
			BusinessAreaID = @businessareaid,
			ApprovedBy = @approvedby,
			Approved = @approved,
			ApprovedTimeZone = @approvedtimezone,
			CreatedBy = @createdby,
			Created = @created,
			CreatedTimeZone = @createdtimezone,
			BusinessLine = @businessline,
			LastModifyBy = @lastmodifyby,
			LastModify = @lastmodify,
			LastModifyTimeZone = @lastmodifytimezone
		  where TeamMember = @TeamMember
		
		
		if @@error != 0
		begin
		        select @ErrorMessage = "Could not update EMDB..TeamMember table for key(s) "
		        goto ERROR_EXIT
		end
	end
else
	begin
	    --- Insert the row as the record itself not present in the EMDB TeamMember.
		 insert EMDB..TeamMember
	         select TeamMember,
	                EmployeeIdentification,
	                Department,
	                SybaseID,
	                EMailAddress,
	                Telephone,
	                CRC,
	                CostCentre,
	                PWD,
	                OldPWD,
	                PreExpired,
	                Disabled,
	                LoginAttempts,
	                EntryDate,
	                ExpiryDate,
	                TeamMemberType,
	                SiteminderAuthentication,
	                FunctionalAccount,
	                Owner,
	                Description,
	                FirstName,
	                LastName,
	                Supervisor,
	                Region,
	                Country,
	                Location,
	                BusinessAreaID,
	                ApprovedBy,
	                Approved,
	                ApprovedTimeZone,
	                CreatedBy,
	                Created,
	                CreatedTimeZone,
	                BusinessLine,
	                LastModifyBy,
	                LastModify,
	                LastModifyTimeZone
	         from CDB..TeamMember CDBTM
		 where CDBTM.TeamMember = @TeamMember	
	
		 if @@error != 0
		 begin
		        select @ErrorMessage = "Could not insert into the EMDB..TeamMember table for key(s) "
		        goto ERROR_EXIT
		 end
	 end
	 goto STORED_PROCEDURE_EXIT
---     		EMDB update ends below                ---
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "TeamMember '" + convert(varchar(255), @TeamMember) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode TeamMemberUpdate, unchained;
DROP PROCEDURE TeamMembersAsCode;
--/
CREATE PROCEDURE TeamMembersAsCode
/**********************************************************************************
**
**
** Procedure : TeamMembersAsCode
**
** Version   :    @(#)TeamMembersAsCode.proc	63.1 08/07/01 
**
** Notes     :
**
**********************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select @version = "@(#)TeamMembersAsCode.proc	63.1 08/07/01"
select "CodeType", "TeamMember", NULL, NULL, NULL, NULL
select "TeamMember", TeamMember, SybaseID,
(case TeamMemberType when 2 then "GROUP: " + TeamMember else TeamMember end), 
"Department:"+Department
+convert(char(1), 0x0a)+"Telephone:"+Telephone
+convert(char(1), 0x0a)+"EMail:"+EMailAddress, NULL
from TeamMember
order by TeamMember


/
EXEC sp_procxmode TeamMembersAsCode, unchained;
DROP PROCEDURE Trader;
--/
CREATE PROCEDURE Trader
/**********************************************************************
** Procedure : Traders
** Notes     :
**********************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @version  varchar(255)
select @version = "%W% %G%"
select c.Type, c.LongName, t.SybaseID, c.Code
from CDB..Code c, CDB..TeamMember t
where Type = 'Trader'
and c.Code *= t.TeamMember


/
EXEC sp_procxmode Trader, unchained;
DROP PROCEDURE Traders;
--/
CREATE PROCEDURE Traders
/**********************************************************************************
**
**
** Procedure : Traders
**
** Version   :    @(#)Traders.proc	63.1 08/07/01
**
** Notes     :
**
**********************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare         @version  varchar(255)
select @version = "@(#)Traders.proc	63.1 08/07/01"
select "CodeType", "Trader", NULL, NULL, NULL, NULL
select "Trader", TeamMember, NULL, NULL, 
"Telephone:"+Telephone
+convert(char(1), 0x0a)+ "EMail:"+EMailAddress, NULL
from TeamMember 
where TeamMember.Department in
(select Code from Code
where Type = 'TradingDepartment')
order by TeamMember


/
EXEC sp_procxmode Traders, unchained;
DROP PROCEDURE UpdateSingleSignOnStatistics;
--/
CREATE PROCEDURE UpdateSingleSignOnStatistics (
        @OS varchar(255)=NULL, @description varchar(255)=NULL
)
/**************************************************************************
**
** Procedure:   UpdateSingleSignOnStatistics
**
** Version:     @(#)UpdateSingleSignOnStatistics.sp     124.1 03/16/07
**
** Notes:
**
**************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @ErrorMessage   varchar(255),
        @rowcount       int,
        @HostName       varchar(255),
	@OSVersion	varchar(255),
	@Desc		varchar(255)
select @HostName = isnull(upper(host_name()),'NONAME')
select @HostName = Code,
       @OSVersion = ExternalCode,
       @Desc	= Description
from Code
  where Type = 'SingleSignOnStatistics'
  and Code = @HostName
select @rowcount = @@rowcount
if @@error != 0
begin
        select @ErrorMessage = "Could not query Code Table for SingleSignOnStatistics "
        goto ERROR_EXIT
end
if @rowcount = 0
begin
    insert into Code (Type,Code,ExternalCode,LongName, Description)
    values ( 'SingleSignOnStatistics', @HostName, @OS, getdate(), @description)
end
if @rowcount = 1 and (@OSVersion!=@OS or @Desc!=@description)
begin
    update Code
    set ExternalCode = @OS,
    LongName = getdate(),
    Description = @description
    where Type = 'SingleSignOnStatistics'
    and Code = @HostName
end
if @@error != 0
begin
        select @ErrorMessage = "Could not update Code for SingleSignOn Statistics "
        goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
        select @ErrorMessage = @ErrorMessage +  "."
        raiserror 20002 @ErrorMessage
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode UpdateSingleSignOnStatistics, unchained;
DROP PROCEDURE UpdateSwapBufferStatistics;
--/
CREATE PROCEDURE UpdateSwapBufferStatistics 
/**************************************************************************
**
** Procedure:	UpdateSwapBufferStatistics
**
** Version: 	%W% %G%
**
** Notes:	
**
**************************************************************************/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
declare @ErrorMessage	varchar(255),
        @rowcount	int,
	@HostName  	varchar(40),
	@Cnt  		varchar(40)
select @HostName = isnull(upper(host_name()),'NONAME')
select @Cnt = ExternalCode
from Code 
  where Type = 'SwapBufferStatistics'
  and Code = @HostName
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not update Code for Swap Buffer Statistics "
	goto ERROR_EXIT
end
if @rowcount = 0
begin
    insert into Code (Type,Code,ExternalCode,LongName)
    values ( 'SwapBufferStatistics', @HostName,'1',getdate())
end
if @rowcount = 1
begin
    update Code 
    set ExternalCode = convert(varchar,convert(int,ExternalCode)+1),
    LongName = getdate()
    where Type = 'SwapBufferStatistics'
    and Code = @HostName
end
if @@error != 0
begin
	select @ErrorMessage = "Could not update Code for Swap Buffer Statistics "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode UpdateSwapBufferStatistics, unchained;
DROP PROCEDURE UserNameBySybaseID;
--/
CREATE PROCEDURE UserNameBySybaseID (
/**************************************************************************
**
** Procedure:   GetTeamMemberBySybaseID
**
** Version:     @(#)UserNameBySybaseID.proc	63.1 08/07/01
**
** Notes:       
**
**************************************************************************/
	@SybaseID	varchar(255)
)
as
declare         @version  varchar(255)
select @version = "@(#)UserNameBySybaseID.proc	63.1 08/07/01"
select TeamMember from TeamMember where SybaseID = @SybaseID
	


/
EXEC sp_procxmode UserNameBySybaseID, unchained;
DROP PROCEDURE UserReportList;
--/
CREATE PROCEDURE UserReportList (
/**********************************************************************************
**
**
** Procedure : UserReportList
**
** Version   : %W% %G%
**
** Notes     :
**
**********************************************************************************/
        @TeamMember     varchar(255) 		= NULL
)
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
select distinct a.ReportType + ":" + a.Report
from   CDB..Report a, CDB..Code b 
where  ( a.TeamMember = @TeamMember or a.AccessType = 2)
and a.ReportType = b.Code
and b.Type = 'ReportTypes'
order by ReportType, Report


/
EXEC sp_procxmode UserReportList, unchained;
DROP PROCEDURE UsersNotLoggedIn;
--/
CREATE PROCEDURE UsersNotLoggedIn(
/**************************************************************************
**
** Procedure:   GetPasswordViolations
**
** Version:    @(#)UsersNotLoggedIn.sp	116.1 06/16/04
**
** Notes:
**
**************************************************************************/
	@DAYS int
) as
set compatibility_mode off  
set plan optgoal allrows_oltp 
set plan optlevel ase_current
set nocount on
print "Users who are not logged in to OASYS in the past %1! days", @DAYS
select ""
select "SybaseID,TeamMember,CostCentre,Department,EmployeeId,",
		"EMailAddress,Telephone,Status,LastLogInTime,EntryDate,NumOfDays" 
select ""
declare @startDate varchar(8)
select @startDate = convert(char(8), dateadd(day, -@DAYS, getdate()), 112)
create table #DisabledIDMap (DisabledEnum int not null,
         DisabledText varchar(255) not null)
insert into #DisabledIDMap (DisabledEnum, DisabledText)
      values (1, 'Active')
insert into #DisabledIDMap (DisabledEnum, DisabledText)
     values (2, 'Non-Active')
-- Query 1
select TeamMember, max(UserLogInTime) as UserLogInTime 
into
	#tmp001
from 
	DB..SessionLog 
group by TeamMember
-- Query 2
select TeamMember
into 
	#tmp002
from
	CDB..TeamMember t
where not exists (select *
				  from DB..SessionLog s
				  where s.TeamMember = t.TeamMember)
-- The total number of records from Query1, Query2, should be equal to the 
-- total number records of TeamMember table
declare @total1 int
declare @total2 int
declare @total int
select 
		"""" + convert(varchar(50), t.SybaseID) + """" + ",",
		"""" + convert(varchar(50), t.TeamMember) + """" + ",", 
		"""" + convert(varchar(50), e.CostCentre) + """" + ",", 
		"""" + convert(varchar(50), e.Department) + """" + ",", 
		"""" + convert(varchar(50), t.EmployeeIdentification) + """" + ",", 
		"""" + convert(varchar(50), e.EMailAddress) + """" + ",", 
		"""" + convert(varchar(20), e.Telephone) + """" + ",", 
		"""" + convert(varchar(50), d.DisabledText) + """" + ",",
		"""" + convert(varchar(50), T.UserLogInTime) + """" + ",",
		"""" + convert(varchar(50), t.EntryDate) + """" + ",",
		"""" + convert(varchar(50), datediff(day, T.UserLogInTime, getdate())) + """"
from 
		CDB..TeamMember t, #tmp001 T, #DisabledIDMap d, CDB..EmployeeDetails e
where 
        t.SybaseID not like '%-E'
and     t.SybaseID not like '%-e'
and		t.TeamMember = T.TeamMember
and             t.EmployeeIdentification = e.EmployeeIdentification
and		t.Disabled = d.DisabledEnum
and		(T.UserLogInTime < convert(datetime, @startDate))
and not exists ( select * 
				from 
					CDB..Code c
				where 
					c.Type = 'OASYSFunctionalIDs'
				and t.SybaseID = c.Code )
select @total1 = @@rowcount
-- Leaving UserLogInTime 'blank' because these Teammembers never logged in
select 
		"""" + convert(varchar(50), t.SybaseID) + """" + ",",
		"""" + convert(varchar(50), t.TeamMember) + """" + ",", 
		"""" + convert(varchar(50), e.CostCentre) + """" + ",", 
		"""" + convert(varchar(50), e.Department) + """" + ",", 
		"""" + convert(varchar(50), t.EmployeeIdentification) + """" + ",", 
		"""" + convert(varchar(50), e.EMailAddress) + """" + ",", 
		"""" + convert(varchar(50), e.Telephone) + """" + ",", 
		"""" + convert(varchar(50), d.DisabledText) + """" + ",",
		"""" + + """" + ",",
		"""" + convert(varchar(50), t.EntryDate) + """" + ",",
		"""" + convert(varchar(50), datediff(day, convert(datetime, convert(varchar(30), t.EntryDate)), getdate())) + """"
from 
		CDB..TeamMember t, #tmp002 T, #DisabledIDMap d, CDB..EmployeeDetails e
where 
     	t.SybaseID not like '%-E%'
and     t.SybaseID not like '%-e'
and		t.TeamMember = T.TeamMember
and		t.Disabled = d.DisabledEnum
and             t.EmployeeIdentification = e.EmployeeIdentification
and		t.EntryDate is not NULL
and 	(convert(datetime, convert(varchar(30), t.EntryDate)) < convert(datetime, @startDate))
and not exists ( select * 
				from 
					CDB..Code c
				where 
					c.Type = 'OASYSFunctionalIDs'
				and t.SybaseID = c.Code )
select @total2 = @@rowcount
select @total = @total1+@total2
select ""
print "Total number of TeamMembers : %1!", @total
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode UsersNotLoggedIn, unchained;
DROP PROCEDURE ViolationLogDelete;
--/
CREATE PROCEDURE ViolationLogDelete (
/**************************************************************************
**
** Procedure:	ViolationLogDelete
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@SybaseID         varchar(255),
	@ViolationTimeGMT datetime           ,
	@ViolationType    varchar(255)           
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
delete from ViolationLog 
where SybaseID = @SybaseID
and    ViolationTimeGMT = @ViolationTimeGMT
and    ViolationType = @ViolationType
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from ViolationLog table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from ViolationLog table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "SybaseID '" + convert(varchar(255), @SybaseID) + "'"
	select @ErrorMessage = @ErrorMessage + ","
	select @ErrorMessage = @ErrorMessage + "ViolationTimeGMT '" + convert(varchar(255), @ViolationTimeGMT) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "ViolationType '" + convert(varchar(255), @ViolationType) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode ViolationLogDelete, unchained;
DROP PROCEDURE ViolationLogInsert;
--/
CREATE PROCEDURE ViolationLogInsert (
/**************************************************************************
**
** Procedure:	ViolationLogInsert
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@SybaseID         varchar(255),
	@ViolationTimeGMT datetime           ,
	@ViolationType    varchar(255)           ,
	@TeamMember       varchar(75)  = NULL,
	@CostCentre       varchar(40)       = NULL,
	@PrivilegeName    varchar(255)            = NULL,
	@LoginAttempts    int     = NULL,
	@HostName         varchar(255)            = NULL,
	@HostTimeStamp    datetime            = NULL,
	@HostTimeZone     varchar(255)            = NULL,
	@Description      varchar(255)            = NULL
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
insert into ViolationLog (
	SybaseID,
	ViolationTimeGMT,
	ViolationType,
	TeamMember,
	CostCentre,
	PrivilegeName,
	LoginAttempts,
	HostName,
	HostTimeStamp,
	HostTimeZone,
	Description )
values (
	@SybaseID,
	@ViolationTimeGMT,
	@ViolationType,
	@TeamMember,
	@CostCentre,
	@PrivilegeName,
	@LoginAttempts,
	@HostName,
	@HostTimeStamp,
	@HostTimeZone,
	@Description )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "Could not insert into ViolationLog table for key(s) "
	select @ErrorMessage = @ErrorMessage + "SybaseID '" + convert(varchar(255), @SybaseID) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "ViolationTimeGMT '" + convert(varchar(255), @ViolationTimeGMT) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "ViolationType '" + convert(varchar(255), @ViolationType) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode ViolationLogInsert, unchained;
DROP PROCEDURE ViolationLogUpdate;
--/
CREATE PROCEDURE ViolationLogUpdate (
/**************************************************************************
**
** Procedure:	ViolationLogUpdate
**
** Version: 	%W% %G%
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@SybaseID         varchar(255),
	@ViolationTimeGMT datetime           ,
	@ViolationType    varchar(255)           ,
	@TeamMember       varchar(75)  = "#$%@",
	@CostCentre       varchar(40)       = "#$%@",
	@PrivilegeName    varchar(255)            = "#$%@",
	@LoginAttempts    int     = -2147483647,
	@HostName         varchar(255)            = "#$%@",
	@HostTimeStamp    datetime            = '99991231',
	@HostTimeZone     varchar(255)            = "#$%@",
	@Description      varchar(255)            = "#$%@"
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @teamMember       varchar(75) ,
        @costCentre       varchar(40)      ,
        @privilegeName    varchar(255)           ,
        @loginAttempts    int    ,
        @hostName         varchar(255)           ,
        @hostTimeStamp    datetime           ,
        @hostTimeZone     varchar(255)           ,
        @description      varchar(255)           
Select @teamMember = TeamMember,
       @costCentre = CostCentre,
       @privilegeName = PrivilegeName,
       @loginAttempts = LoginAttempts,
       @hostName = HostName,
       @hostTimeStamp = HostTimeStamp,
       @hostTimeZone = HostTimeZone,
       @description = Description
from ViolationLog
  where SybaseID = @SybaseID
  and ViolationTimeGMT = @ViolationTimeGMT
  and ViolationType = @ViolationType
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not select before update from ViolationLog table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Selected "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) before update from ViolationLog table for key(s) "
	goto ERROR_EXIT
end
if @TeamMember != "#$%@"
	select @teamMember = @TeamMember
if @CostCentre != "#$%@"
	select @costCentre = @CostCentre
if @PrivilegeName != "#$%@"
	select @privilegeName = @PrivilegeName
if @LoginAttempts != -2147483647
	select @loginAttempts = @LoginAttempts
if @HostName != "#$%@"
	select @hostName = @HostName
if @HostTimeStamp != '99991231'
	select @hostTimeStamp = @HostTimeStamp
if @HostTimeZone != "#$%@"
	select @hostTimeZone = @HostTimeZone
if @Description != "#$%@"
	select @description = @Description
Update ViolationLog
set	TeamMember = @teamMember,
	CostCentre = @costCentre,
	PrivilegeName = @privilegeName,
	LoginAttempts = @loginAttempts,
	HostName = @hostName,
	HostTimeStamp = @hostTimeStamp,
	HostTimeZone = @hostTimeZone,
	Description = @description
  where SybaseID = @SybaseID
  and ViolationTimeGMT = @ViolationTimeGMT
  and ViolationType = @ViolationType
if @@error != 0
begin
	select @ErrorMessage = "Could not update ViolationLog table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage + "SybaseID '" + convert(varchar(255), @SybaseID) + "'"
	select @ErrorMessage = @ErrorMessage + ", "
	select @ErrorMessage = @ErrorMessage + "ViolationTimeGMT '" + convert(varchar(255), @ViolationTimeGMT) + "'"
	select @ErrorMessage = @ErrorMessage + " and "
	select @ErrorMessage = @ErrorMessage + "ViolationType '" + convert(varchar(255), @ViolationType) + "'"
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode ViolationLogUpdate, unchained;
DROP PROCEDURE WeeklyPaymentID;
--/
CREATE PROCEDURE WeeklyPaymentID(@iStartDate int = NULL, 
                                 @iEndDate int = NULL,
								 @sCodeType varchar(40) = 'CBM_WeeklyPayment_PLE')
/*
	This procedure retrieves breaks with CBDB..ReconBreak.PaymentID = NDB..Payment.PaymentID
	and specified range of NDB..Payment.PaymentDate values. Both, CBDB and CBDBArchive 
	databases are used. If any of the dates is not selected - find dates of the previous week,
	Monday - Sunday.
*/
as 
 set compatibility_mode off  
 set plan optgoal allrows_oltp 
 set plan optlevel ase_current  
begin
    if ((@iStartDate = null) or (@iEndDate = null))
    begin
      declare @dToday datetime
      select @dToday = getdate()
      declare @iWeekDay int
      select @iWeekDay = datepart(weekday, @dToday)
      declare @dMonday datetime
      select @dMonday = dateadd(day, 2 - @iWeekDay, @dToday)
      select @dMonday = dateadd(day, -7, @dMonday)
      declare @dSunday datetime
      select @dSunday = dateadd(day, 6, @dMonday)
      select @iStartDate = convert(int, convert(varchar, @dMonday, 112))
      select @iEndDate = convert(int, convert(varchar, @dSunday, 112))
    end
    CREATE TABLE #yr_ReconID 
    (   Id     	varchar(40) NOT NULL,
        Company	varchar(40) NOT NULL 
    )
    declare @nDaysDiff int
    select @nDaysDiff = datediff(day, convert(datetime, convert(varchar, @iStartDate), 112), 
                                      convert(datetime, convert(varchar, @iEndDate), 112))
    if (@nDaysDiff > 31)
    begin
  	  	RAISERROR 50000 'Error: Maximum period of time is 31 days.'
  	  	return
    end
    insert into #yr_ReconID
    SELECT Id, Company
    FROM CBDBArchive..ReconBreak RB, NDB..Payment PM, CDB..Code CD
    WHERE (RB.PaymentID is not null)
      AND (RB.PaymentID = PM.PaymentID)
      AND (RB.ItemState in ('1', '4104'))
      AND (RB.USDEquivalentAbsolute >= 250)
      AND (PM.PaymentDate >= @iStartDate)
      AND (PM.PaymentDate <= @iEndDate)
      AND (PM.Cancelled is not NULL)
      AND (PM.Cancelled <> 2)
	  AND (CD.Type = @sCodeType)
	  AND (PM.PartyLegalEntity = CD.Code)
    insert into #yr_ReconID
    SELECT Id, Company
    FROM CBDB..ReconBreak RB, NDB..Payment PM, CDB..Code CD
    WHERE (RB.PaymentID is not null)
      AND (RB.PaymentID = PM.PaymentID)
      AND (RB.ItemState in ('1', '4104'))
      AND (RB.USDEquivalentAbsolute >= 250)
      AND (PM.PaymentDate >= @iStartDate)
      AND (PM.PaymentDate <= @iEndDate)
      AND (PM.Cancelled is not NULL)
      AND (PM.Cancelled <> 2)
	  AND (CD.Type = @sCodeType)
	  AND (PM.PartyLegalEntity = CD.Code)
    SELECT ReconBreak.PaymentID, ReconBreak.Id, ReconBreak.Company, ReconBreak.Department, ReconBreak.PartyLegalEntity, ReconBreak.AvailOrPaid, ReconBreak.Currency, ReconBreak.Amount, ReconBreak.DCIP, ReconBreak.USDEquivalentAbsolute, ReconBreak.Aged, ReconBreak.AgeBucket, ReconBreakDetails.CounterPartyName, ReconBreak.ReconCustomerName, ReconBreakDetails.ManagerGroupName, ReconBreak.BreakCategory, ReconBreak.AssignedTo, ReconBreak.USDEquivalent, TransactionBrowser.ProductClass, ReconBreak.AccountPool, FirmAccount.StrategyCode, FirmAccount.Strategy, ReconBreak.Deal, ReconBreak.TransactionID, TransactionBrowser.OperationsFile, ReconBreak.HedgeFundFlag, ReconBreak.MasterAgreementEntity, ReconBreak.NetId, ReconBreak.NettedBy, ReconBreakDetails.ReconTxnDesc, TransactionBrowser.PartyRelationship, ReconBreak.PostedOrIssue, ReconBreak.ItemState, ReconBreak.FlagItem, ReconBreak.GroupName, ReconBreak.GroupedBy, TransactionBrowser.UnderlyingDescription, ReconBreak.PostingSource, ReconBreak.EntryType, ReconBreak.ClientMoney, TransactionBrowser.TerminationDate, TransactionBrowser.ReferenceEntity, TransactionBrowser.CustomerReference, TransactionBrowser.CDSReference, TransactionBrowser.SSTReference, TransactionBrowser.SalesPerson, TransactionBrowser.Trader, ReconBreak.AffirmationComments, ReconBreak.AffirmationStatus, ReconBreak.BreakCurrentStatus, ReconBreak.PaymentCategory, FirmAccount.Mnemonic, ReconBreak.PaymentApprovalOperability, ReconBreak.AffirmationRequired, ReconBreak.PaymentAffirmedBy, ReconBreak.PaymentSignedBy, ReconBreak.FirstEntryDate, ReconBreak.FirstEntryDateTimeZone, ReconBreak.NetTimestamp, TransactionBrowser.CounterPartyAccount, ReconBreak.PaymentReferenceNumber, ReconBreak.EffectiveDate, TransactionBrowser.TradeDate, TransactionBrowser.Notional, TransactionBrowser.AccrualRate, TransactionBrowser.PaySideNotional, TransactionBrowser.PaySideAccrualRate, TransactionBrowser.PaySideCurrency, TransactionBrowser.RcvSideNotional, TransactionBrowser.RcvSideAccrualRate, TransactionBrowser.RcvSideCurrency, ReconBreak.AcccountName, ReconBreak.CommentAge, ReconBreak.BreakCausal, ReconBreakDetails.LastComment, ReconBreak.BreakGoals, TransactionBrowser.UnderlyingCusip, ReconBreakDetails.ServiceTier, ReconBreakDetails.DTCCCLSFunding, ReconBreakDetails.DTCCCLSEligible, ReconBreakDetails.DTCCCalcStatus, ReconBreakDetails.DTCCEligible, ReconBreakDetails.ParentCounterPartyName, ReconBreakDetails.AlternateCreditContact, ReconBreakDetails.SettlementCategory, ReconBreakDetails.TypeOfConfirm, ReconBreakDetails.WarehouseStatus, ReconBreakDetails.IsDTCC, ReconBreakDetails.CreditCategory, ReconBreakDetails.CreditContact, TransactionBrowser.CDSTradeType, ReconBreak.BreakRootCause, ReconBreak.BreakRootCauseDetail, ReconBreakDetails.AssetClass, ReconBreakDetails.MarkitExclude, ReconBreakDetails.MatchApprover, ReconBreakDetails.MatchLastModified, ReconBreakDetails.MatchStatus, ReconBreakDetails.MatchedBy, StrategyDesk.CashBreakDeskManager
    FROM #yr_ReconID yr, CBDB..ReconBreak ReconBreak, CBDB..ReconBreakDetails ReconBreakDetails,
         TBDB..TransactionBrowser TransactionBrowser,ADB..FirmAccount FirmAccount,CBDB..StrategyDesk StrategyDesk
    WHERE ReconBreak.Deal *= TransactionBrowser.Deal AND ReconBreak.TransactionID *= TransactionBrowser.TransactionID AND TransactionBrowser.PartyAccountNumber *= FirmAccount.AccountNumber AND FirmAccount.Strategy *= StrategyDesk.Strategy AND ReconBreak.Id = ReconBreakDetails.Id AND ReconBreak.Company = ReconBreakDetails.Company 
      AND ReconBreak.Id = yr.Id
      AND ReconBreak.Company = yr.Company
    union
    SELECT ReconBreak.PaymentID, ReconBreak.Id, ReconBreak.Company, ReconBreak.Department, ReconBreak.PartyLegalEntity, ReconBreak.AvailOrPaid, ReconBreak.Currency, ReconBreak.Amount, ReconBreak.DCIP, ReconBreak.USDEquivalentAbsolute, ReconBreak.Aged, ReconBreak.AgeBucket, ReconBreakDetails.CounterPartyName, ReconBreak.ReconCustomerName, ReconBreakDetails.ManagerGroupName, ReconBreak.BreakCategory, ReconBreak.AssignedTo, ReconBreak.USDEquivalent, TransactionBrowser.ProductClass, ReconBreak.AccountPool, FirmAccount.StrategyCode, FirmAccount.Strategy, ReconBreak.Deal, ReconBreak.TransactionID, TransactionBrowser.OperationsFile, ReconBreak.HedgeFundFlag, ReconBreak.MasterAgreementEntity, ReconBreak.NetId, ReconBreak.NettedBy, ReconBreakDetails.ReconTxnDesc, TransactionBrowser.PartyRelationship, ReconBreak.PostedOrIssue, ReconBreak.ItemState, ReconBreak.FlagItem, ReconBreak.GroupName, ReconBreak.GroupedBy, TransactionBrowser.UnderlyingDescription, ReconBreak.PostingSource, ReconBreak.EntryType, ReconBreak.ClientMoney, TransactionBrowser.TerminationDate, TransactionBrowser.ReferenceEntity, TransactionBrowser.CustomerReference, TransactionBrowser.CDSReference, TransactionBrowser.SSTReference, TransactionBrowser.SalesPerson, TransactionBrowser.Trader, ReconBreak.AffirmationComments, ReconBreak.AffirmationStatus, ReconBreak.BreakCurrentStatus, ReconBreak.PaymentCategory, FirmAccount.Mnemonic, ReconBreak.PaymentApprovalOperability, ReconBreak.AffirmationRequired, ReconBreak.PaymentAffirmedBy, ReconBreak.PaymentSignedBy, ReconBreak.FirstEntryDate, ReconBreak.FirstEntryDateTimeZone, ReconBreak.NetTimestamp, TransactionBrowser.CounterPartyAccount, ReconBreak.PaymentReferenceNumber, ReconBreak.EffectiveDate, TransactionBrowser.TradeDate, TransactionBrowser.Notional, TransactionBrowser.AccrualRate, TransactionBrowser.PaySideNotional, TransactionBrowser.PaySideAccrualRate, TransactionBrowser.PaySideCurrency, TransactionBrowser.RcvSideNotional, TransactionBrowser.RcvSideAccrualRate, TransactionBrowser.RcvSideCurrency, ReconBreak.AcccountName, ReconBreak.CommentAge, ReconBreak.BreakCausal, ReconBreakDetails.LastComment, ReconBreak.BreakGoals, TransactionBrowser.UnderlyingCusip, ReconBreakDetails.ServiceTier, ReconBreakDetails.DTCCCLSFunding, ReconBreakDetails.DTCCCLSEligible, ReconBreakDetails.DTCCCalcStatus, ReconBreakDetails.DTCCEligible, ReconBreakDetails.ParentCounterPartyName, ReconBreakDetails.AlternateCreditContact, ReconBreakDetails.SettlementCategory, ReconBreakDetails.TypeOfConfirm, ReconBreakDetails.WarehouseStatus, ReconBreakDetails.IsDTCC, ReconBreakDetails.CreditCategory, ReconBreakDetails.CreditContact, TransactionBrowser.CDSTradeType, ReconBreak.BreakRootCause, ReconBreak.BreakRootCauseDetail, ReconBreakDetails.AssetClass, ReconBreakDetails.MarkitExclude, ReconBreakDetails.MatchApprover, ReconBreakDetails.MatchLastModified, ReconBreakDetails.MatchStatus, ReconBreakDetails.MatchedBy, StrategyDesk.CashBreakDeskManager
    FROM #yr_ReconID yr, CBDBArchive..ReconBreak ReconBreak, CBDBArchive..ReconBreakDetails ReconBreakDetails,
         TBDB..TransactionBrowser TransactionBrowser,ADB..FirmAccount FirmAccount,CBDB..StrategyDesk StrategyDesk
    WHERE ReconBreak.Deal *= TransactionBrowser.Deal AND ReconBreak.TransactionID *= TransactionBrowser.TransactionID AND TransactionBrowser.PartyAccountNumber *= FirmAccount.AccountNumber AND FirmAccount.Strategy *= StrategyDesk.Strategy AND ReconBreak.Id = ReconBreakDetails.Id AND ReconBreak.Company = ReconBreakDetails.Company 
    AND ReconBreak.Id = yr.Id
    AND ReconBreak.Company = yr.Company
end


/
EXEC sp_procxmode WeeklyPaymentID, unchained;
DROP PROCEDURE WordDelete;
--/
CREATE PROCEDURE WordDelete (
/**************************************************************************
**
** Procedure:	WordDelete
**
** Version: 	@(#)WordDelete.proc	63.1 08/07/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Word varchar(255)
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255),
        @rowcount		int
declare @version  varchar(255)
select  @version = "@(#)WordDelete.proc	63.1 08/07/01"
delete from Word
where Word = @Word
select @rowcount = @@rowcount
if @@error != 0
begin
	select @ErrorMessage = "Could not delete from Word table for key(s) "
	goto ERROR_EXIT
end
if @rowcount != 1
begin
	select @ErrorMessage = "Deleted "
	select @ErrorMessage = @ErrorMessage + convert(varchar(255), @rowcount)
	select @ErrorMessage = @ErrorMessage + " row(s) from Word table for key(s) "
	goto ERROR_EXIT
end
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode WordDelete, unchained;
DROP PROCEDURE WordInsert;
--/
CREATE PROCEDURE WordInsert (
/**************************************************************************
**
** Procedure:	WordInsert
**
** Version: 	@(#)WordInsert.proc	63.1 08/07/01
**
** Notes:	Automatically Generated
**
**************************************************************************/
	@Word varchar(255)
)
as 
 set compatibility_mode off 
declare @ErrorMessage	varchar(255)
declare @version  varchar(255)
select  @version = "@(#)WordInsert.proc	63.1 08/07/01"
insert into Word (
	Word )
values (
	@Word )
if @@error != 0
	goto ERROR_EXIT
goto STORED_PROCEDURE_EXIT
ERROR_EXIT:
	select @ErrorMessage = @ErrorMessage +  "."
	raiserror 20002 @ErrorMessage 
STORED_PROCEDURE_EXIT:


/
EXEC sp_procxmode WordInsert, unchained;
DROP PROCEDURE rs_check_repl_stat;
--/

/* Create the procedure which checks replicate status */
CREATE PROCEDURE rs_check_repl_stat 
	@rs_repl_name varchar(255)
as
	declare @current_status smallint
	select @current_status = sysstat
		from sysobjects
		where id=object_id(@rs_repl_name)
	if (@current_status & -32768) = -32768
		select 1
	else
		select 0

 
/
EXEC sp_procxmode rs_check_repl_stat, unchained;
DROP PROCEDURE rs_get_lastcommit;
--/

/* Create the procedure to get the last commit for all origins. */
CREATE PROCEDURE rs_get_lastcommit
as
	select origin, origin_qid, secondary_qid
		from rs_lastcommit
 
/
EXEC sp_procxmode rs_get_lastcommit, unchained;
DROP PROCEDURE rs_initialize_threads;
--/
/* Create the procedure to update the table. */
CREATE PROCEDURE rs_initialize_threads
        @rs_id          int
as
	delete from rs_threads where id = @rs_id
	insert into rs_threads values (@rs_id, 0, "", "", "", "")
/
EXEC sp_procxmode rs_initialize_threads, unchained;
DROP PROCEDURE rs_marker;
--/

/* Create the procedure which marks the log when a subscription is created. */
CREATE PROCEDURE rs_marker 
	@rs_api varchar(255)
as
	/* Setup the bit that reflects a SQL Server replicated object. */
	declare	@rep_constant	smallint
	select @rep_constant = -32768

	/* First make sure that this procedure is marked as replicated! */
	if not exists (select sysstat
			from sysobjects
			where name = 'rs_marker'
				and type = 'P'
				and sysstat & @rep_constant != 0)
	begin
		print "Have your DBO execute 'sp_setreplicate' on the procedure 'rs_marker'"
		return(1)
	end

	/*
	** There is nothing else to do in this procedure. It's execution
	** should have been logged into the transaction log and picked up
	** by the SQL Server LTM.
	*/
 
/
EXEC sp_procxmode rs_marker, unchained;
DROP PROCEDURE rs_update_lastcommit;
--/
/* Create the procedure to update the table. */
CREATE PROCEDURE rs_update_lastcommit
	@origin		int,
	@origin_qid	binary(36),
	@secondary_qid	binary(36),
	@origin_time	datetime
as
	update rs_lastcommit
		set origin_qid = @origin_qid, secondary_qid = @secondary_qid,
			origin_time = @origin_time,
			dest_commit_time = getdate()
		where origin = @origin
	if (@@rowcount = 0)
	begin
		insert rs_lastcommit (origin, origin_qid, secondary_qid,
				origin_time, dest_commit_time,
				pad1, pad2, pad3, pad4, pad5, pad6, pad7, pad8)
			values (@origin, @origin_qid, @secondary_qid,
				@origin_time, getdate(),
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
	end
 
/
EXEC sp_procxmode rs_update_lastcommit, unchained;
DROP PROCEDURE rs_update_threads;
--/
/* Create the procedure to update the table. */
CREATE PROCEDURE rs_update_threads
        @rs_id          int,
        @rs_seq         int
as
        update rs_threads set seq = @rs_seq where id = @rs_id
 
/
EXEC sp_procxmode rs_update_threads, unchained;
DROP TRIGGER CodeTableAuditTrigger;
--/

CREATE TRIGGER CodeTableAuditTrigger
ON Code
FOR UPDATE, DELETE
AS
DECLARE @RowCount INT
SELECT @RowCount = @@RowCount
IF UPDATE(Type) OR UPDATE(Code) OR UPDATE(ExternalCode) OR UPDATE(LongName) OR UPDATE(Description) OR UPDATE(CRC)
BEGIN
    IF @RowCount = 1
    BEGIN
        INSERT CodeTableAudit
        SELECT DISTINCT
               GETDATE(),
               'UPDATE',
               S.hostname,
               S.ipaddr,
               S.hostprocess,
               S.program_name,
               SUSER_NAME(S.suid),
               @@spid,
               D.Type,
               I.Type,
               D.Code,
               I.Code,
               D.ExternalCode,
               I.ExternalCode,
               D.LongName,
               I.LongName,
               D.Description,
               I.Description,
               D.CRC,
               I.CRC
        FROM deleted D, inserted I, AuditedCodeEntries A, master..sysprocesses S
        WHERE (A.CodeName = D.Type OR A.CodeName = 'ALL CODES')
        AND A.Event = 'UPDATE'
        AND S.spid = @@spid
        AND S.suid = suser_id()
    END
    ELSE
    BEGIN
        INSERT CodeTableAudit
        SELECT DISTINCT
               GETDATE(),
               'UPDATE(DELETE)',
               S.hostname,
               S.ipaddr,
               S.hostprocess,
               S.program_name,
               SUSER_NAME(S.suid),
               @@spid,
               D.Type,
               NULL,
               D.Code,
               NULL,
               D.ExternalCode,
               NULL,
               D.LongName,
               NULL,
               D.Description,
               NULL,
               D.CRC,
               NULL
        FROM deleted D, AuditedCodeEntries A, master..sysprocesses S
        WHERE (A.CodeName = D.Type OR A.CodeName = 'ALL CODES')
        AND A.Event = 'UPDATE'
        AND S.spid = @@spid
        AND S.suid = suser_id()

        INSERT CodeTableAudit
        SELECT DISTINCT
               GETDATE(),
               'UPDATE(INSERT)',
               S.hostname,
               S.ipaddr,
               S.hostprocess,
               S.program_name,
               SUSER_NAME(S.suid),
               @@spid,
               NULL,
               I.Type,
               NULL,
               I.Code,
               NULL,
               I.ExternalCode,
               NULL,
               I.LongName,
               NULL,
               I.Description,
               NULL,
               I.CRC
        FROM inserted I, AuditedCodeEntries A, master..sysprocesses S
        WHERE (A.CodeName = I.Type OR A.CodeName = 'ALL CODES')
        AND A.Event = 'UPDATE'
        AND S.spid = @@spid
        AND S.suid = suser_id()
    END
END
ELSE
BEGIN 
    INSERT CodeTableAudit
    SELECT DISTINCT
           GETDATE(),
           'DELETE',
           S.hostname,
           S.ipaddr,
           S.hostprocess,
           S.program_name,
           SUSER_NAME(S.suid),
           @@spid,
           D.Type,
           NULL,
           D.Code,
           NULL,
           D.ExternalCode,
           NULL,
           D.LongName,
           NULL,
           D.Description,
           NULL,
           D.CRC,
           NULL
    FROM deleted D, AuditedCodeEntries A, master..sysprocesses S
    WHERE (A.CodeName = D.Type OR A.CodeName = 'ALL CODES')
    AND A.Event = 'DELETE'
    AND S.spid = @@spid
    AND S.suid = suser_id()
END

/
DROP TRIGGER CodeTableAuditTrigger;
--/

CREATE TRIGGER CodeTableAuditTrigger
ON Code
FOR UPDATE, DELETE
AS
DECLARE @RowCount INT
SELECT @RowCount = @@RowCount
IF UPDATE(Type) OR UPDATE(Code) OR UPDATE(ExternalCode) OR UPDATE(LongName) OR UPDATE(Description) OR UPDATE(CRC)
BEGIN
    IF @RowCount = 1
    BEGIN
        INSERT CodeTableAudit
        SELECT DISTINCT
               GETDATE(),
               'UPDATE',
               S.hostname,
               S.ipaddr,
               S.hostprocess,
               S.program_name,
               SUSER_NAME(S.suid),
               @@spid,
               D.Type,
               I.Type,
               D.Code,
               I.Code,
               D.ExternalCode,
               I.ExternalCode,
               D.LongName,
               I.LongName,
               D.Description,
               I.Description,
               D.CRC,
               I.CRC
        FROM deleted D, inserted I, AuditedCodeEntries A, master..sysprocesses S
        WHERE (A.CodeName = D.Type OR A.CodeName = 'ALL CODES')
        AND A.Event = 'UPDATE'
        AND S.spid = @@spid
        AND S.suid = suser_id()
    END
    ELSE
    BEGIN
        INSERT CodeTableAudit
        SELECT DISTINCT
               GETDATE(),
               'UPDATE(DELETE)',
               S.hostname,
               S.ipaddr,
               S.hostprocess,
               S.program_name,
               SUSER_NAME(S.suid),
               @@spid,
               D.Type,
               NULL,
               D.Code,
               NULL,
               D.ExternalCode,
               NULL,
               D.LongName,
               NULL,
               D.Description,
               NULL,
               D.CRC,
               NULL
        FROM deleted D, AuditedCodeEntries A, master..sysprocesses S
        WHERE (A.CodeName = D.Type OR A.CodeName = 'ALL CODES')
        AND A.Event = 'UPDATE'
        AND S.spid = @@spid
        AND S.suid = suser_id()

        INSERT CodeTableAudit
        SELECT DISTINCT
               GETDATE(),
               'UPDATE(INSERT)',
               S.hostname,
               S.ipaddr,
               S.hostprocess,
               S.program_name,
               SUSER_NAME(S.suid),
               @@spid,
               NULL,
               I.Type,
               NULL,
               I.Code,
               NULL,
               I.ExternalCode,
               NULL,
               I.LongName,
               NULL,
               I.Description,
               NULL,
               I.CRC
        FROM inserted I, AuditedCodeEntries A, master..sysprocesses S
        WHERE (A.CodeName = I.Type OR A.CodeName = 'ALL CODES')
        AND A.Event = 'UPDATE'
        AND S.spid = @@spid
        AND S.suid = suser_id()
    END
END
ELSE
BEGIN 
    INSERT CodeTableAudit
    SELECT DISTINCT
           GETDATE(),
           'DELETE',
           S.hostname,
           S.ipaddr,
           S.hostprocess,
           S.program_name,
           SUSER_NAME(S.suid),
           @@spid,
           D.Type,
           NULL,
           D.Code,
           NULL,
           D.ExternalCode,
           NULL,
           D.LongName,
           NULL,
           D.Description,
           NULL,
           D.CRC,
           NULL
    FROM deleted D, AuditedCodeEntries A, master..sysprocesses S
    WHERE (A.CodeName = D.Type OR A.CodeName = 'ALL CODES')
    AND A.Event = 'DELETE'
    AND S.spid = @@spid
    AND S.suid = suser_id()
END

/
DROP TRIGGER CodeTableInsertAuditTrigger;
--/

CREATE TRIGGER CodeTableInsertAuditTrigger
ON Code
FOR INSERT
AS
INSERT CodeTableAudit
SELECT DISTINCT
       GETDATE(),
       'INSERT',
       S.hostname,
       S.ipaddr,
       S.hostprocess,
       S.program_name,
       SUSER_NAME(S.suid),
       @@spid,
       NULL,
       I.Type,
       NULL,
       I.Code,
       NULL,
       I.ExternalCode,
       NULL,
       I.LongName,
       NULL,
       I.Description,
       NULL,
       I.CRC
FROM inserted I, AuditedCodeEntries A, master..sysprocesses S
WHERE (A.CodeName = I.Type OR A.CodeName = 'ALL CODES')
AND A.Event IN ('UPDATE', 'INSERT')
AND S.spid = @@spid
AND S.suid = suser_id()

/
DROP TRIGGER cdb_emdb_TMDAP_delete_trig;
--/
CREATE TRIGGER cdb_emdb_TMDAP_delete_trig
	on TeamMemberDataAccessPrivileges
	for delete 
	as 
        	delete from EMDB..TeamMemberDataAccessPrivileges
		from deleted D_T , EMDB..TeamMemberDataAccessPrivileges EMDB_TMDAP
		where EMDB_TMDAP.TeamMember = D_T.TeamMember
		and EMDB_TMDAP.AccessObject = D_T.AccessObject
		and EMDB_TMDAP.AccessPrivilege = D_T.AccessPrivilege
		and EMDB_TMDAP.AccessEntity = D_T.AccessEntity
		and EMDB_TMDAP.AccessEntityValue = D_T.AccessEntityValue


/
DROP TRIGGER cdb_emdb_TMDAP_insert_trig;
--/
CREATE TRIGGER cdb_emdb_TMDAP_insert_trig
	on TeamMemberDataAccessPrivileges
	for insert 
	as 
		if ( select count(*) 
			 from EMDB..TeamMemberDataAccessPrivileges EMDB_T, inserted I_T
			 where EMDB_T.TeamMember = I_T.TeamMember 
			 and EMDB_T.AccessObject = I_T.AccessObject
			 and EMDB_T.AccessPrivilege = I_T.AccessPrivilege
			 and EMDB_T.AccessEntity = I_T.AccessEntity
			 and EMDB_T.AccessEntityValue = I_T.AccessEntityValue ) = 0
		begin
        	 	insert EMDB..TeamMemberDataAccessPrivileges
         		select  TeamMember,
	        		AccessObject,
		        	AccessPrivilege,     
				AccessEntity,     
				AccessEntityValue,     
				FilterType,
				ApprovedBy,
				Approved,
				ApprovedTimeZone
			from inserted
        	end


/
DROP TRIGGER cdb_emdb_TML_delete_trig;
--/
CREATE TRIGGER cdb_emdb_TML_delete_trig
	on TeamMemberLimits
	for delete 
	as 
         	delete EMDB..TeamMemberLimits
		from deleted D_T , EMDB..TeamMemberLimits EMDB_TML
		where EMDB_TML.TeamMember = D_T.TeamMember
		and EMDB_TML.Type = D_T.Type


/
DROP TRIGGER cdb_emdb_TML_insert_trig;
--/
CREATE TRIGGER cdb_emdb_TML_insert_trig
	on TeamMemberLimits
	for insert 
	as 
		if ( select count(*) 
		     from EMDB..TeamMemberLimits EMDB_T, inserted I_T
		     where EMDB_T.TeamMember = I_T.TeamMember 
		     and EMDB_T.Type = I_T.Type ) = 0
		begin
         		insert EMDB..TeamMemberLimits
         		select  TeamMember,
				Type,
				Limit,
				ApprovedBy,
				Approved,
				ApprovedTimeZone
			from inserted
        	end


/
DROP TRIGGER cdb_emdb_TM_delete_trig;
--/
CREATE TRIGGER cdb_emdb_TM_delete_trig
	on TeamMember
	for delete 
	as 
     	    delete EMDB..TeamMember
     	    from deleted D_T , EMDB..TeamMember  EMDB_TM
    	    where EMDB_TM.TeamMember = D_T.TeamMember


/
DROP TRIGGER cdb_emdb_TM_insert_trig;
--/
CREATE TRIGGER cdb_emdb_TM_insert_trig
	on TeamMember
	for insert 
	as 
		if ( select count(*) 
		     from EMDB..TeamMember EMDB_T, inserted I_T
		     where EMDB_T.TeamMember = I_T.TeamMember ) = 0
	begin
         insert EMDB..TeamMember
         select TeamMember,
		EmployeeIdentification,
		Department,
		SybaseID,
		EMailAddress,
        	Telephone,
		CRC,
		CostCentre,
		PWD,
		OldPWD,
	    	PreExpired,
		Disabled,
		LoginAttempts,
		EntryDate,
		ExpiryDate,
        	TeamMemberType,
		SiteminderAuthentication,
		FunctionalAccount,
		Owner,
		Description, 
		FirstName,
		LastName,
		Supervisor,
		Region,
		Country,
		Location,
		BusinessAreaID,
		ApprovedBy,
		Approved,
		ApprovedTimeZone,
		CreatedBy,
		Created,
		CreatedTimeZone,
		BusinessLine,
		LastModifyBy,
		LastModify,
		LastModifyTimeZone
         from inserted
    end


/
